import {
  __commonJS
} from "./chunk-LK32TJAX.js";

// node_modules/openseadragon/build/openseadragon/openseadragon.js
var require_openseadragon = __commonJS({
  "node_modules/openseadragon/build/openseadragon/openseadragon.js"(exports, module) {
    function OpenSeadragon(options) {
      return new OpenSeadragon.Viewer(options);
    }
    (function($2) {
      $2.version = {
        versionStr: "2.4.2",
        major: parseInt("2", 10),
        minor: parseInt("4", 10),
        revision: parseInt("2", 10)
      };
      var class2type = {
        "[object Boolean]": "boolean",
        "[object Number]": "number",
        "[object String]": "string",
        "[object Function]": "function",
        "[object Array]": "array",
        "[object Date]": "date",
        "[object RegExp]": "regexp",
        "[object Object]": "object"
      }, toString = Object.prototype.toString, hasOwn = Object.prototype.hasOwnProperty;
      $2.isFunction = function(obj) {
        return $2.type(obj) === "function";
      };
      $2.isArray = Array.isArray || function(obj) {
        return $2.type(obj) === "array";
      };
      $2.isWindow = function(obj) {
        return obj && typeof obj === "object" && "setInterval" in obj;
      };
      $2.type = function(obj) {
        return obj === null || obj === void 0 ? String(obj) : class2type[toString.call(obj)] || "object";
      };
      $2.isPlainObject = function(obj) {
        if (!obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $2.isWindow(obj)) {
          return false;
        }
        if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
          return false;
        }
        var lastKey;
        for (var key in obj) {
          lastKey = key;
        }
        return lastKey === void 0 || hasOwn.call(obj, lastKey);
      };
      $2.isEmptyObject = function(obj) {
        for (var name in obj) {
          return false;
        }
        return true;
      };
      $2.freezeObject = function(obj) {
        if (Object.freeze) {
          $2.freezeObject = Object.freeze;
        } else {
          $2.freezeObject = function(obj2) {
            return obj2;
          };
        }
        return $2.freezeObject(obj);
      };
      $2.supportsCanvas = function() {
        var canvasElement = document.createElement("canvas");
        return !!($2.isFunction(canvasElement.getContext) && canvasElement.getContext("2d"));
      }();
      $2.isCanvasTainted = function(canvas) {
        var isTainted = false;
        try {
          canvas.getContext("2d").getImageData(0, 0, 1, 1);
        } catch (e) {
          isTainted = true;
        }
        return isTainted;
      };
      $2.pixelDensityRatio = function() {
        if ($2.supportsCanvas) {
          var context = document.createElement("canvas").getContext("2d");
          var devicePixelRatio = window.devicePixelRatio || 1;
          var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
          return Math.max(devicePixelRatio, 1) / backingStoreRatio;
        } else {
          return 1;
        }
      }();
    })(OpenSeadragon);
    (function($) {
      $.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, length = arguments.length, deep = false, i = 1;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i = 2;
        }
        if (typeof target !== "object" && !OpenSeadragon.isFunction(target)) {
          target = {};
        }
        if (length === i) {
          target = this;
          --i;
        }
        for (; i < length; i++) {
          options = arguments[i];
          if (options !== null || options !== void 0) {
            for (name in options) {
              src = target[name];
              copy = options[name];
              if (target === copy) {
                continue;
              }
              if (deep && copy && (OpenSeadragon.isPlainObject(copy) || (copyIsArray = OpenSeadragon.isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && OpenSeadragon.isArray(src) ? src : [];
                } else {
                  clone = src && OpenSeadragon.isPlainObject(src) ? src : {};
                }
                target[name] = OpenSeadragon.extend(deep, clone, copy);
              } else if (copy !== void 0) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      var isIOSDevice = function() {
        if (typeof navigator !== "object") {
          return false;
        }
        var userAgent = navigator.userAgent;
        if (typeof userAgent !== "string") {
          return false;
        }
        return userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1 || userAgent.indexOf("iPod") !== -1;
      };
      $.extend(
        $,
        /** @lends OpenSeadragon */
        {
          /**
           * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
           * @static
           * @type {Object}
           */
          DEFAULT_SETTINGS: {
            //DATA SOURCE DETAILS
            xmlPath: null,
            tileSources: null,
            tileHost: null,
            initialPage: 0,
            crossOriginPolicy: false,
            ajaxWithCredentials: false,
            loadTilesWithAjax: false,
            ajaxHeaders: {},
            //PAN AND ZOOM SETTINGS AND CONSTRAINTS
            panHorizontal: true,
            panVertical: true,
            constrainDuringPan: false,
            wrapHorizontal: false,
            wrapVertical: false,
            visibilityRatio: 0.5,
            //-> how much of the viewer can be negative space
            minPixelRatio: 0.5,
            //->closer to 0 draws tiles meant for a higher zoom at this zoom
            defaultZoomLevel: 0,
            minZoomLevel: null,
            maxZoomLevel: null,
            homeFillsViewer: false,
            //UI RESPONSIVENESS AND FEEL
            clickTimeThreshold: 300,
            clickDistThreshold: 5,
            dblClickTimeThreshold: 300,
            dblClickDistThreshold: 20,
            springStiffness: 6.5,
            animationTime: 1.2,
            gestureSettingsMouse: {
              scrollToZoom: true,
              clickToZoom: true,
              dblClickToZoom: false,
              pinchToZoom: false,
              zoomToRefPoint: true,
              flickEnabled: false,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsTouch: {
              scrollToZoom: false,
              clickToZoom: false,
              dblClickToZoom: true,
              pinchToZoom: true,
              zoomToRefPoint: true,
              flickEnabled: true,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsPen: {
              scrollToZoom: false,
              clickToZoom: true,
              dblClickToZoom: false,
              pinchToZoom: false,
              zoomToRefPoint: true,
              flickEnabled: false,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsUnknown: {
              scrollToZoom: false,
              clickToZoom: false,
              dblClickToZoom: true,
              pinchToZoom: true,
              zoomToRefPoint: true,
              flickEnabled: true,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            zoomPerClick: 2,
            zoomPerScroll: 1.2,
            zoomPerSecond: 1,
            blendTime: 0,
            alwaysBlend: false,
            autoHideControls: true,
            immediateRender: false,
            minZoomImageRatio: 0.9,
            //-> closer to 0 allows zoom out to infinity
            maxZoomPixelRatio: 1.1,
            //-> higher allows 'over zoom' into pixels
            smoothTileEdgesMinZoom: 1.1,
            //-> higher than maxZoomPixelRatio disables it
            iOSDevice: isIOSDevice(),
            pixelsPerWheelLine: 40,
            pixelsPerArrowPress: 40,
            autoResize: true,
            preserveImageSizeOnResize: false,
            // requires autoResize=true
            minScrollDeltaTime: 50,
            rotationIncrement: 90,
            //DEFAULT CONTROL SETTINGS
            showSequenceControl: true,
            //SEQUENCE
            sequenceControlAnchor: null,
            //SEQUENCE
            preserveViewport: false,
            //SEQUENCE
            preserveOverlays: false,
            //SEQUENCE
            navPrevNextWrap: false,
            //SEQUENCE
            showNavigationControl: true,
            //ZOOM/HOME/FULL/ROTATION
            navigationControlAnchor: null,
            //ZOOM/HOME/FULL/ROTATION
            showZoomControl: true,
            //ZOOM
            showHomeControl: true,
            //HOME
            showFullPageControl: true,
            //FULL
            showRotationControl: false,
            //ROTATION
            showFlipControl: false,
            //FLIP
            controlsFadeDelay: 2e3,
            //ZOOM/HOME/FULL/SEQUENCE
            controlsFadeLength: 1500,
            //ZOOM/HOME/FULL/SEQUENCE
            mouseNavEnabled: true,
            //GENERAL MOUSE INTERACTIVITY
            //VIEWPORT NAVIGATOR SETTINGS
            showNavigator: false,
            navigatorId: null,
            navigatorPosition: null,
            navigatorSizeRatio: 0.2,
            navigatorMaintainSizeRatio: false,
            navigatorTop: null,
            navigatorLeft: null,
            navigatorHeight: null,
            navigatorWidth: null,
            navigatorAutoResize: true,
            navigatorAutoFade: true,
            navigatorRotate: true,
            navigatorBackground: "#000",
            navigatorOpacity: 0.8,
            navigatorBorderColor: "#555",
            navigatorDisplayRegionColor: "#900",
            // INITIAL ROTATION
            degrees: 0,
            // INITIAL FLIP STATE
            flipped: false,
            // APPEARANCE
            opacity: 1,
            preload: false,
            compositeOperation: null,
            imageSmoothingEnabled: true,
            placeholderFillStyle: null,
            //REFERENCE STRIP SETTINGS
            showReferenceStrip: false,
            referenceStripScroll: "horizontal",
            referenceStripElement: null,
            referenceStripHeight: null,
            referenceStripWidth: null,
            referenceStripPosition: "BOTTOM_LEFT",
            referenceStripSizeRatio: 0.2,
            //COLLECTION VISUALIZATION SETTINGS
            collectionRows: 3,
            //or columns depending on layout
            collectionColumns: 0,
            //columns in horizontal layout, rows in vertical layout
            collectionLayout: "horizontal",
            //vertical
            collectionMode: false,
            collectionTileSize: 800,
            collectionTileMargin: 80,
            //PERFORMANCE SETTINGS
            imageLoaderLimit: 0,
            maxImageCacheCount: 200,
            timeout: 3e4,
            useCanvas: true,
            // Use canvas element for drawing if available
            //INTERFACE RESOURCE SETTINGS
            prefixUrl: "/images/",
            navImages: {
              zoomIn: {
                REST: "zoomin_rest.png",
                GROUP: "zoomin_grouphover.png",
                HOVER: "zoomin_hover.png",
                DOWN: "zoomin_pressed.png"
              },
              zoomOut: {
                REST: "zoomout_rest.png",
                GROUP: "zoomout_grouphover.png",
                HOVER: "zoomout_hover.png",
                DOWN: "zoomout_pressed.png"
              },
              home: {
                REST: "home_rest.png",
                GROUP: "home_grouphover.png",
                HOVER: "home_hover.png",
                DOWN: "home_pressed.png"
              },
              fullpage: {
                REST: "fullpage_rest.png",
                GROUP: "fullpage_grouphover.png",
                HOVER: "fullpage_hover.png",
                DOWN: "fullpage_pressed.png"
              },
              rotateleft: {
                REST: "rotateleft_rest.png",
                GROUP: "rotateleft_grouphover.png",
                HOVER: "rotateleft_hover.png",
                DOWN: "rotateleft_pressed.png"
              },
              rotateright: {
                REST: "rotateright_rest.png",
                GROUP: "rotateright_grouphover.png",
                HOVER: "rotateright_hover.png",
                DOWN: "rotateright_pressed.png"
              },
              flip: {
                // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
                REST: "flip_rest.png",
                GROUP: "flip_grouphover.png",
                HOVER: "flip_hover.png",
                DOWN: "flip_pressed.png"
              },
              previous: {
                REST: "previous_rest.png",
                GROUP: "previous_grouphover.png",
                HOVER: "previous_hover.png",
                DOWN: "previous_pressed.png"
              },
              next: {
                REST: "next_rest.png",
                GROUP: "next_grouphover.png",
                HOVER: "next_hover.png",
                DOWN: "next_pressed.png"
              }
            },
            //DEVELOPER SETTINGS
            debugMode: false,
            debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"]
          },
          /**
           * TODO: get rid of this.  I can't see how it's required at all.  Looks
           *       like an early legacy code artifact.
           * @static
           * @ignore
           */
          SIGNAL: "----seadragon----",
          /**
           * Returns a function which invokes the method as if it were a method belonging to the object.
           * @function
           * @param {Object} object
           * @param {Function} method
           * @returns {Function}
           */
          delegate: function(object, method) {
            return function() {
              var args = arguments;
              if (args === void 0) {
                args = [];
              }
              return method.apply(object, args);
            };
          },
          /**
           * An enumeration of Browser vendors.
           * @static
           * @type {Object}
           * @property {Number} UNKNOWN
           * @property {Number} IE
           * @property {Number} FIREFOX
           * @property {Number} SAFARI
           * @property {Number} CHROME
           * @property {Number} OPERA
           */
          BROWSERS: {
            UNKNOWN: 0,
            IE: 1,
            FIREFOX: 2,
            SAFARI: 3,
            CHROME: 4,
            OPERA: 5
          },
          /**
           * Returns a DOM Element for the given id or element.
           * @function
           * @param {String|Element} element Accepts an id or element.
           * @returns {Element} The element with the given id, null, or the element itself.
           */
          getElement: function(element) {
            if (typeof element == "string") {
              element = document.getElementById(element);
            }
            return element;
          },
          /**
           * Determines the position of the upper-left corner of the element.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
           */
          getElementPosition: function(element) {
            var result = new $.Point(), isFixed, offsetParent;
            element = $.getElement(element);
            isFixed = $.getElementStyle(element).position == "fixed";
            offsetParent = getOffsetParent(element, isFixed);
            while (offsetParent) {
              result.x += element.offsetLeft;
              result.y += element.offsetTop;
              if (isFixed) {
                result = result.plus($.getPageScroll());
              }
              element = offsetParent;
              isFixed = $.getElementStyle(element).position == "fixed";
              offsetParent = getOffsetParent(element, isFixed);
            }
            return result;
          },
          /**
           * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
           */
          getElementOffset: function(element) {
            element = $.getElement(element);
            var doc = element && element.ownerDocument, docElement, win, boundingRect = { top: 0, left: 0 };
            if (!doc) {
              return new $.Point();
            }
            docElement = doc.documentElement;
            if (typeof element.getBoundingClientRect !== "undefined") {
              boundingRect = element.getBoundingClientRect();
            }
            win = doc == doc.window ? doc : doc.nodeType === 9 ? doc.defaultView || doc.parentWindow : false;
            return new $.Point(
              boundingRect.left + (win.pageXOffset || docElement.scrollLeft) - (docElement.clientLeft || 0),
              boundingRect.top + (win.pageYOffset || docElement.scrollTop) - (docElement.clientTop || 0)
            );
          },
          /**
           * Determines the height and width of the given element.
           * @function
           * @param {Element|String} element
           * @returns {OpenSeadragon.Point}
           */
          getElementSize: function(element) {
            element = $.getElement(element);
            return new $.Point(
              element.clientWidth,
              element.clientHeight
            );
          },
          /**
           * Returns the CSSStyle object for the given element.
           * @function
           * @param {Element|String} element
           * @returns {CSSStyle}
           */
          getElementStyle: document.documentElement.currentStyle ? function(element) {
            element = $.getElement(element);
            return element.currentStyle;
          } : function(element) {
            element = $.getElement(element);
            return window.getComputedStyle(element, "");
          },
          /**
           * Returns the property with the correct vendor prefix appended.
           * @param {String} property the property name
           * @returns {String} the property with the correct prefix or null if not
           * supported.
           */
          getCssPropertyWithVendorPrefix: function(property) {
            var memo = {};
            $.getCssPropertyWithVendorPrefix = function(property2) {
              if (memo[property2] !== void 0) {
                return memo[property2];
              }
              var style = document.createElement("div").style;
              var result = null;
              if (style[property2] !== void 0) {
                result = property2;
              } else {
                var prefixes = [
                  "Webkit",
                  "Moz",
                  "MS",
                  "O",
                  "webkit",
                  "moz",
                  "ms",
                  "o"
                ];
                var suffix = $.capitalizeFirstLetter(property2);
                for (var i = 0; i < prefixes.length; i++) {
                  var prop = prefixes[i] + suffix;
                  if (style[prop] !== void 0) {
                    result = prop;
                    break;
                  }
                }
              }
              memo[property2] = result;
              return result;
            };
            return $.getCssPropertyWithVendorPrefix(property);
          },
          /**
           * Capitalizes the first letter of a string
           * @param {String} string
           * @returns {String} The string with the first letter capitalized
           */
          capitalizeFirstLetter: function(string2) {
            return string2.charAt(0).toUpperCase() + string2.slice(1);
          },
          /**
           * Compute the modulo of a number but makes sure to always return
           * a positive value.
           * @param {Number} number the number to computes the modulo of
           * @param {Number} modulo the modulo
           * @returns {Number} the result of the modulo of number
           */
          positiveModulo: function(number, modulo) {
            var result = number % modulo;
            if (result < 0) {
              result += modulo;
            }
            return result;
          },
          /**
           * Determines if a point is within the bounding rectangle of the given element (hit-test).
           * @function
           * @param {Element|String} element
           * @param {OpenSeadragon.Point} point
           * @returns {Boolean}
           */
          pointInElement: function(element, point) {
            element = $.getElement(element);
            var offset = $.getElementOffset(element), size = $.getElementSize(element);
            return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y;
          },
          /**
           * Gets the latest event, really only useful internally since its
           * specific to IE behavior.
           * @function
           * @param {Event} [event]
           * @returns {Event}
           * @deprecated For internal use only
           * @private
           */
          getEvent: function(event) {
            if (event) {
              $.getEvent = function(event2) {
                return event2;
              };
            } else {
              $.getEvent = function() {
                return window.event;
              };
            }
            return $.getEvent(event);
          },
          /**
           * Gets the position of the mouse on the screen for a given event.
           * @function
           * @param {Event} [event]
           * @returns {OpenSeadragon.Point}
           */
          getMousePosition: function(event) {
            if (typeof event.pageX == "number") {
              $.getMousePosition = function(event2) {
                var result = new $.Point();
                event2 = $.getEvent(event2);
                result.x = event2.pageX;
                result.y = event2.pageY;
                return result;
              };
            } else if (typeof event.clientX == "number") {
              $.getMousePosition = function(event2) {
                var result = new $.Point();
                event2 = $.getEvent(event2);
                result.x = event2.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                result.y = event2.clientY + document.body.scrollTop + document.documentElement.scrollTop;
                return result;
              };
            } else {
              throw new Error(
                "Unknown event mouse position, no known technique."
              );
            }
            return $.getMousePosition(event);
          },
          /**
           * Determines the page's current scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getPageScroll: function() {
            var docElement = document.documentElement || {}, body = document.body || {};
            if (typeof window.pageXOffset == "number") {
              $.getPageScroll = function() {
                return new $.Point(
                  window.pageXOffset,
                  window.pageYOffset
                );
              };
            } else if (body.scrollLeft || body.scrollTop) {
              $.getPageScroll = function() {
                return new $.Point(
                  document.body.scrollLeft,
                  document.body.scrollTop
                );
              };
            } else if (docElement.scrollLeft || docElement.scrollTop) {
              $.getPageScroll = function() {
                return new $.Point(
                  document.documentElement.scrollLeft,
                  document.documentElement.scrollTop
                );
              };
            } else {
              return new $.Point(0, 0);
            }
            return $.getPageScroll();
          },
          /**
           * Set the page scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          setPageScroll: function(scroll) {
            if (typeof window.scrollTo !== "undefined") {
              $.setPageScroll = function(scroll2) {
                window.scrollTo(scroll2.x, scroll2.y);
              };
            } else {
              var originalScroll = $.getPageScroll();
              if (originalScroll.x === scroll.x && originalScroll.y === scroll.y) {
                return;
              }
              document.body.scrollLeft = scroll.x;
              document.body.scrollTop = scroll.y;
              var currentScroll = $.getPageScroll();
              if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
                $.setPageScroll = function(scroll2) {
                  document.body.scrollLeft = scroll2.x;
                  document.body.scrollTop = scroll2.y;
                };
                return;
              }
              document.documentElement.scrollLeft = scroll.x;
              document.documentElement.scrollTop = scroll.y;
              currentScroll = $.getPageScroll();
              if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
                $.setPageScroll = function(scroll2) {
                  document.documentElement.scrollLeft = scroll2.x;
                  document.documentElement.scrollTop = scroll2.y;
                };
                return;
              }
              $.setPageScroll = function(scroll2) {
              };
            }
            return $.setPageScroll(scroll);
          },
          /**
           * Determines the size of the browsers window.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getWindowSize: function() {
            var docElement = document.documentElement || {}, body = document.body || {};
            if (typeof window.innerWidth == "number") {
              $.getWindowSize = function() {
                return new $.Point(
                  window.innerWidth,
                  window.innerHeight
                );
              };
            } else if (docElement.clientWidth || docElement.clientHeight) {
              $.getWindowSize = function() {
                return new $.Point(
                  document.documentElement.clientWidth,
                  document.documentElement.clientHeight
                );
              };
            } else if (body.clientWidth || body.clientHeight) {
              $.getWindowSize = function() {
                return new $.Point(
                  document.body.clientWidth,
                  document.body.clientHeight
                );
              };
            } else {
              throw new Error("Unknown window size, no known technique.");
            }
            return $.getWindowSize();
          },
          /**
           * Wraps the given element in a nest of divs so that the element can
           * be easily centered using CSS tables
           * @function
           * @param {Element|String} element
           * @returns {Element} outermost wrapper element
           */
          makeCenteredNode: function(element) {
            element = $.getElement(element);
            var wrappers = [
              $.makeNeutralElement("div"),
              $.makeNeutralElement("div"),
              $.makeNeutralElement("div")
            ];
            $.extend(wrappers[0].style, {
              display: "table",
              height: "100%",
              width: "100%"
            });
            $.extend(wrappers[1].style, {
              display: "table-row"
            });
            $.extend(wrappers[2].style, {
              display: "table-cell",
              verticalAlign: "middle",
              textAlign: "center"
            });
            wrappers[0].appendChild(wrappers[1]);
            wrappers[1].appendChild(wrappers[2]);
            wrappers[2].appendChild(element);
            return wrappers[0];
          },
          /**
           * Creates an easily positionable element of the given type that therefor
           * serves as an excellent container element.
           * @function
           * @param {String} tagName
           * @returns {Element}
           */
          makeNeutralElement: function(tagName) {
            var element = document.createElement(tagName), style = element.style;
            style.background = "transparent none";
            style.border = "none";
            style.margin = "0px";
            style.padding = "0px";
            style.position = "static";
            return element;
          },
          /**
           * Returns the current milliseconds, using Date.now() if available
           * @function
           */
          now: function() {
            if (Date.now) {
              $.now = Date.now;
            } else {
              $.now = function() {
                return (/* @__PURE__ */ new Date()).getTime();
              };
            }
            return $.now();
          },
          /**
           * Ensures an image is loaded correctly to support alpha transparency.
           * Generally only IE has issues doing this correctly for formats like
           * png.
           * @function
           * @param {String} src
           * @returns {Element}
           */
          makeTransparentImage: function(src) {
            $.makeTransparentImage = function(src2) {
              var img = $.makeNeutralElement("img");
              img.src = src2;
              return img;
            };
            if ($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 7) {
              $.makeTransparentImage = function(src2) {
                var img = $.makeNeutralElement("img"), element = null;
                element = $.makeNeutralElement("span");
                element.style.display = "inline-block";
                img.onload = function() {
                  element.style.width = element.style.width || img.width + "px";
                  element.style.height = element.style.height || img.height + "px";
                  img.onload = null;
                  img = null;
                };
                img.src = src2;
                element.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + src2 + "', sizingMethod='scale')";
                return element;
              };
            }
            return $.makeTransparentImage(src);
          },
          /**
           * Sets the opacity of the specified element.
           * @function
           * @param {Element|String} element
           * @param {Number} opacity
           * @param {Boolean} [usesAlpha]
           */
          setElementOpacity: function(element, opacity, usesAlpha) {
            var ieOpacity, ieFilter;
            element = $.getElement(element);
            if (usesAlpha && !$.Browser.alpha) {
              opacity = Math.round(opacity);
            }
            if ($.Browser.opacity) {
              element.style.opacity = opacity < 1 ? opacity : "";
            } else {
              if (opacity < 1) {
                ieOpacity = Math.round(100 * opacity);
                ieFilter = "alpha(opacity=" + ieOpacity + ")";
                element.style.filter = ieFilter;
              } else {
                element.style.filter = "";
              }
            }
          },
          /**
           * Sets the specified element's touch-action style attribute to 'none'.
           * @function
           * @param {Element|String} element
           */
          setElementTouchActionNone: function(element) {
            element = $.getElement(element);
            if (typeof element.style.touchAction !== "undefined") {
              element.style.touchAction = "none";
            } else if (typeof element.style.msTouchAction !== "undefined") {
              element.style.msTouchAction = "none";
            }
          },
          /**
           * Add the specified CSS class to the element if not present.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          addClass: function(element, className) {
            element = $.getElement(element);
            if (!element.className) {
              element.className = className;
            } else if ((" " + element.className + " ").indexOf(" " + className + " ") === -1) {
              element.className += " " + className;
            }
          },
          /**
           * Find the first index at which an element is found in an array or -1
           * if not present.
           *
           * Code taken and adapted from
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
           *
           * @function
           * @param {Array} array The array from which to find the element
           * @param {Object} searchElement The element to find
           * @param {Number} [fromIndex=0] Index to start research.
           * @returns {Number} The index of the element in the array.
           */
          indexOf: function(array, searchElement, fromIndex) {
            if (Array.prototype.indexOf) {
              this.indexOf = function(array2, searchElement2, fromIndex2) {
                return array2.indexOf(searchElement2, fromIndex2);
              };
            } else {
              this.indexOf = function(array2, searchElement2, fromIndex2) {
                var i, pivot = fromIndex2 ? fromIndex2 : 0, length;
                if (!array2) {
                  throw new TypeError();
                }
                length = array2.length;
                if (length === 0 || pivot >= length) {
                  return -1;
                }
                if (pivot < 0) {
                  pivot = length - Math.abs(pivot);
                }
                for (i = pivot; i < length; i++) {
                  if (array2[i] === searchElement2) {
                    return i;
                  }
                }
                return -1;
              };
            }
            return this.indexOf(array, searchElement, fromIndex);
          },
          /**
           * Remove the specified CSS class from the element.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          removeClass: function(element, className) {
            var oldClasses, newClasses = [], i;
            element = $.getElement(element);
            oldClasses = element.className.split(/\s+/);
            for (i = 0; i < oldClasses.length; i++) {
              if (oldClasses[i] && oldClasses[i] !== className) {
                newClasses.push(oldClasses[i]);
              }
            }
            element.className = newClasses.join(" ");
          },
          /**
           * Adds an event listener for the given element, eventName and handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean} [useCapture]
           */
          addEvent: function() {
            if (window.addEventListener) {
              return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.addEventListener(eventName, handler, useCapture);
              };
            } else if (window.attachEvent) {
              return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.attachEvent("on" + eventName, handler);
              };
            } else {
              throw new Error("No known event model.");
            }
          }(),
          /**
           * Remove a given event listener for the given element, event type and
           * handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean} [useCapture]
           */
          removeEvent: function() {
            if (window.removeEventListener) {
              return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.removeEventListener(eventName, handler, useCapture);
              };
            } else if (window.detachEvent) {
              return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.detachEvent("on" + eventName, handler);
              };
            } else {
              throw new Error("No known event model.");
            }
          }(),
          /**
           * Cancels the default browser behavior had the event propagated all
           * the way up the DOM to the window object.
           * @function
           * @param {Event} [event]
           */
          cancelEvent: function(event) {
            event = $.getEvent(event);
            if (event.preventDefault) {
              $.cancelEvent = function(event2) {
                event2.preventDefault();
              };
            } else {
              $.cancelEvent = function(event2) {
                event2 = $.getEvent(event2);
                event2.cancel = true;
                event2.returnValue = false;
              };
            }
            $.cancelEvent(event);
          },
          /**
           * Stops the propagation of the event up the DOM.
           * @function
           * @param {Event} [event]
           */
          stopEvent: function(event) {
            event = $.getEvent(event);
            if (event.stopPropagation) {
              $.stopEvent = function(event2) {
                event2.stopPropagation();
              };
            } else {
              $.stopEvent = function(event2) {
                event2 = $.getEvent(event2);
                event2.cancelBubble = true;
              };
            }
            $.stopEvent(event);
          },
          /**
           * Similar to OpenSeadragon.delegate, but it does not immediately call
           * the method on the object, returning a function which can be called
           * repeatedly to delegate the method. It also allows additional arguments
           * to be passed during construction which will be added during each
           * invocation, and each invocation can add additional arguments as well.
           *
           * @function
           * @param {Object} object
           * @param {Function} method
           * @param [args] any additional arguments are passed as arguments to the
           *  created callback
           * @returns {Function}
           */
          createCallback: function(object, method) {
            var initialArgs = [], i;
            for (i = 2; i < arguments.length; i++) {
              initialArgs.push(arguments[i]);
            }
            return function() {
              var args = initialArgs.concat([]), i2;
              for (i2 = 0; i2 < arguments.length; i2++) {
                args.push(arguments[i2]);
              }
              return method.apply(object, args);
            };
          },
          /**
           * Retrieves the value of a url parameter from the window.location string.
           * @function
           * @param {String} key
           * @returns {String} The value of the url parameter or null if no param matches.
           */
          getUrlParameter: function(key) {
            var value = URLPARAMS[key];
            return value ? value : null;
          },
          /**
           * Retrieves the protocol used by the url. The url can either be absolute
           * or relative.
           * @function
           * @private
           * @param {String} url The url to retrieve the protocol from.
           * @return {String} The protocol (http:, https:, file:, ftp: ...)
           */
          getUrlProtocol: function(url) {
            var match = url.match(/^([a-z]+:)\/\//i);
            if (match === null) {
              return window.location.protocol;
            }
            return match[1].toLowerCase();
          },
          /**
           * Create an XHR object
           * @private
           * @param {type} [local] If set to true, the XHR will be file: protocol
           * compatible if possible (but may raise a warning in the browser).
           * @returns {XMLHttpRequest}
           */
          createAjaxRequest: function(local) {
            var supportActiveX;
            try {
              supportActiveX = !!new ActiveXObject("Microsoft.XMLHTTP");
            } catch (e) {
              supportActiveX = false;
            }
            if (supportActiveX) {
              if (window.XMLHttpRequest) {
                $.createAjaxRequest = function(local2) {
                  if (local2) {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                  }
                  return new XMLHttpRequest();
                };
              } else {
                $.createAjaxRequest = function() {
                  return new ActiveXObject("Microsoft.XMLHTTP");
                };
              }
            } else if (window.XMLHttpRequest) {
              $.createAjaxRequest = function() {
                return new XMLHttpRequest();
              };
            } else {
              throw new Error("Browser doesn't support XMLHttpRequest.");
            }
            return $.createAjaxRequest(local);
          },
          /**
           * Makes an AJAX request.
           * @param {Object} options
           * @param {String} options.url - the url to request
           * @param {Function} options.success - a function to call on a successful response
           * @param {Function} options.error - a function to call on when an error occurs
           * @param {Object} options.headers - headers to add to the AJAX request
           * @param {String} options.responseType - the response type of the the AJAX request
           * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
           * @throws {Error}
           * @returns {XMLHttpRequest}
           */
          makeAjaxRequest: function(url, onSuccess, onError) {
            var withCredentials;
            var headers;
            var responseType;
            if ($.isPlainObject(url)) {
              onSuccess = url.success;
              onError = url.error;
              withCredentials = url.withCredentials;
              headers = url.headers;
              responseType = url.responseType || null;
              url = url.url;
            }
            var protocol = $.getUrlProtocol(url);
            var request = $.createAjaxRequest(protocol === "file:");
            if (!$.isFunction(onSuccess)) {
              throw new Error("makeAjaxRequest requires a success callback");
            }
            request.onreadystatechange = function() {
              if (request.readyState == 4) {
                request.onreadystatechange = function() {
                };
                if (request.status >= 200 && request.status < 300 || request.status === 0 && protocol !== "http:" && protocol !== "https:") {
                  onSuccess(request);
                } else {
                  $.console.log("AJAX request returned %d: %s", request.status, url);
                  if ($.isFunction(onError)) {
                    onError(request);
                  }
                }
              }
            };
            try {
              request.open("GET", url, true);
              if (responseType) {
                request.responseType = responseType;
              }
              if (headers) {
                for (var headerName in headers) {
                  if (Object.prototype.hasOwnProperty.call(headers, headerName) && headers[headerName]) {
                    request.setRequestHeader(headerName, headers[headerName]);
                  }
                }
              }
              if (withCredentials) {
                request.withCredentials = true;
              }
              request.send(null);
            } catch (e) {
              var msg = e.message;
              var oldIE = $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 10;
              if (oldIE && typeof e.number != "undefined" && e.number == -2147024891) {
                msg += "\nSee http://msdn.microsoft.com/en-us/library/ms537505(v=vs.85).aspx#xdomain";
              }
              $.console.log("%s while making AJAX request: %s", e.name, msg);
              request.onreadystatechange = function() {
              };
              if (window.XDomainRequest) {
                var xdr = new window.XDomainRequest();
                if (xdr) {
                  xdr.onload = function(e2) {
                    if ($.isFunction(onSuccess)) {
                      onSuccess({
                        // Faking an xhr object
                        responseText: xdr.responseText,
                        status: 200,
                        // XDomainRequest doesn't support status codes, so we just fake one! :/
                        statusText: "OK"
                      });
                    }
                  };
                  xdr.onerror = function(e2) {
                    if ($.isFunction(onError)) {
                      onError({
                        // Faking an xhr object
                        responseText: xdr.responseText,
                        status: 444,
                        // 444 No Response
                        statusText: "An error happened. Due to an XDomainRequest deficiency we can not extract any information about this error. Upgrade your browser."
                      });
                    }
                  };
                  try {
                    xdr.open("GET", url);
                    xdr.send();
                  } catch (e2) {
                    if ($.isFunction(onError)) {
                      onError(request, e);
                    }
                  }
                }
              } else {
                if ($.isFunction(onError)) {
                  onError(request, e);
                }
              }
            }
            return request;
          },
          /**
           * Taken from jQuery 1.6.1
           * @function
           * @param {Object} options
           * @param {String} options.url
           * @param {Function} options.callback
           * @param {String} [options.param='callback'] The name of the url parameter
           *      to request the jsonp provider with.
           * @param {String} [options.callbackName=] The name of the callback to
           *      request the jsonp provider with.
           */
          jsonp: function(options) {
            var script, url = options.url, head = document.head || document.getElementsByTagName("head")[0] || document.documentElement, jsonpCallback = options.callbackName || "openseadragon" + $.now(), previous = window[jsonpCallback], replace = "$1" + jsonpCallback + "$2", callbackParam = options.param || "callback", callback = options.callback;
            url = url.replace(/(\=)\?(&|$)|\?\?/i, replace);
            url += (/\?/.test(url) ? "&" : "?") + callbackParam + "=" + jsonpCallback;
            window[jsonpCallback] = function(response) {
              if (!previous) {
                try {
                  delete window[jsonpCallback];
                } catch (e) {
                }
              } else {
                window[jsonpCallback] = previous;
              }
              if (callback && $.isFunction(callback)) {
                callback(response);
              }
            };
            script = document.createElement("script");
            if (void 0 !== options.async || false !== options.async) {
              script.async = "async";
            }
            if (options.scriptCharset) {
              script.charset = options.scriptCharset;
            }
            script.src = url;
            script.onload = script.onreadystatechange = function(_, isAbort) {
              if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                script.onload = script.onreadystatechange = null;
                if (head && script.parentNode) {
                  head.removeChild(script);
                }
                script = void 0;
              }
            };
            head.insertBefore(script, head.firstChild);
          },
          /**
           * Fully deprecated. Will throw an error.
           * @function
           * @deprecated use {@link OpenSeadragon.Viewer#open}
           */
          createFromDZI: function() {
            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
          },
          /**
           * Parses an XML string into a DOM Document.
           * @function
           * @param {String} string
           * @returns {Document}
           */
          parseXml: function(string2) {
            if (window.DOMParser) {
              $.parseXml = function(string3) {
                var xmlDoc = null, parser;
                parser = new DOMParser();
                xmlDoc = parser.parseFromString(string3, "text/xml");
                return xmlDoc;
              };
            } else if (window.ActiveXObject) {
              $.parseXml = function(string3) {
                var xmlDoc = null;
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = false;
                xmlDoc.loadXML(string3);
                return xmlDoc;
              };
            } else {
              throw new Error("Browser doesn't support XML DOM.");
            }
            return $.parseXml(string2);
          },
          /**
           * Parses a JSON string into a Javascript object.
           * @function
           * @param {String} string
           * @returns {Object}
           */
          parseJSON: function(string) {
            if (window.JSON && window.JSON.parse) {
              $.parseJSON = window.JSON.parse;
            } else {
              $.parseJSON = function(string) {
                return eval("(" + string + ")");
              };
            }
            return $.parseJSON(string);
          },
          /**
           * Reports whether the image format is supported for tiling in this
           * version.
           * @function
           * @param {String} [extension]
           * @returns {Boolean}
           */
          imageFormatSupported: function(extension) {
            extension = extension ? extension : "";
            return !!FILEFORMATS[extension.toLowerCase()];
          }
        }
      );
      var nullfunction = function(msg) {
      };
      $.console = window.console || {
        log: nullfunction,
        debug: nullfunction,
        info: nullfunction,
        warn: nullfunction,
        error: nullfunction,
        assert: nullfunction
      };
      $.Browser = {
        vendor: $.BROWSERS.UNKNOWN,
        version: 0,
        alpha: true
      };
      var FILEFORMATS = {
        "bmp": false,
        "jpeg": true,
        "jpg": true,
        "png": true,
        "tif": false,
        "wdp": false
      }, URLPARAMS = {};
      (function() {
        var ver = navigator.appVersion, ua = navigator.userAgent, regex;
        switch (navigator.appName) {
          case "Microsoft Internet Explorer":
            if (!!window.attachEvent && !!window.ActiveXObject) {
              $.Browser.vendor = $.BROWSERS.IE;
              $.Browser.version = parseFloat(
                ua.substring(
                  ua.indexOf("MSIE") + 5,
                  ua.indexOf(";", ua.indexOf("MSIE"))
                )
              );
            }
            break;
          case "Netscape":
            if (window.addEventListener) {
              if (ua.indexOf("Firefox") >= 0) {
                $.Browser.vendor = $.BROWSERS.FIREFOX;
                $.Browser.version = parseFloat(
                  ua.substring(ua.indexOf("Firefox") + 8)
                );
              } else if (ua.indexOf("Safari") >= 0) {
                $.Browser.vendor = ua.indexOf("Chrome") >= 0 ? $.BROWSERS.CHROME : $.BROWSERS.SAFARI;
                $.Browser.version = parseFloat(
                  ua.substring(
                    ua.substring(0, ua.indexOf("Safari")).lastIndexOf("/") + 1,
                    ua.indexOf("Safari")
                  )
                );
              } else {
                regex = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
                if (regex.exec(ua) !== null) {
                  $.Browser.vendor = $.BROWSERS.IE;
                  $.Browser.version = parseFloat(RegExp.$1);
                }
              }
            }
            break;
          case "Opera":
            $.Browser.vendor = $.BROWSERS.OPERA;
            $.Browser.version = parseFloat(ver);
            break;
        }
        var query = window.location.search.substring(1), parts = query.split("&"), part, sep, i;
        for (i = 0; i < parts.length; i++) {
          part = parts[i];
          sep = part.indexOf("=");
          if (sep > 0) {
            var key = part.substring(0, sep), value = part.substring(sep + 1);
            try {
              URLPARAMS[key] = decodeURIComponent(value);
            } catch (e) {
              $.console.error("Ignoring malformed URL parameter: %s=%s", key, value);
            }
          }
        }
        $.Browser.alpha = !($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 9 || $.Browser.vendor == $.BROWSERS.CHROME && $.Browser.version < 2);
        $.Browser.opacity = !($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 9);
      })();
      (function(w) {
        var requestAnimationFrame = w.requestAnimationFrame || w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame;
        var cancelAnimationFrame = w.cancelAnimationFrame || w.mozCancelAnimationFrame || w.webkitCancelAnimationFrame || w.msCancelAnimationFrame;
        if (requestAnimationFrame && cancelAnimationFrame) {
          $.requestAnimationFrame = function() {
            return requestAnimationFrame.apply(w, arguments);
          };
          $.cancelAnimationFrame = function() {
            return cancelAnimationFrame.apply(w, arguments);
          };
        } else {
          var aAnimQueue = [], processing = [], iRequestId = 0, iIntervalId;
          $.requestAnimationFrame = function(callback) {
            aAnimQueue.push([++iRequestId, callback]);
            if (!iIntervalId) {
              iIntervalId = setInterval(function() {
                if (aAnimQueue.length) {
                  var time = $.now();
                  var temp = processing;
                  processing = aAnimQueue;
                  aAnimQueue = temp;
                  while (processing.length) {
                    processing.shift()[1](time);
                  }
                } else {
                  clearInterval(iIntervalId);
                  iIntervalId = void 0;
                }
              }, 1e3 / 50);
            }
            return iRequestId;
          };
          $.cancelAnimationFrame = function(requestId) {
            var i, j;
            for (i = 0, j = aAnimQueue.length; i < j; i += 1) {
              if (aAnimQueue[i][0] === requestId) {
                aAnimQueue.splice(i, 1);
                return;
              }
            }
            for (i = 0, j = processing.length; i < j; i += 1) {
              if (processing[i][0] === requestId) {
                processing.splice(i, 1);
                return;
              }
            }
          };
        }
      })(window);
      function getOffsetParent(element, isFixed) {
        if (isFixed && element != document.body) {
          return document.body;
        } else {
          return element.offsetParent;
        }
      }
    })(OpenSeadragon);
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.OpenSeadragon = factory();
      }
    })(exports, function() {
      return OpenSeadragon;
    });
    (function($2) {
      var fullScreenApi = {
        supportsFullScreen: false,
        isFullScreen: function() {
          return false;
        },
        getFullScreenElement: function() {
          return null;
        },
        requestFullScreen: function() {
        },
        exitFullScreen: function() {
        },
        cancelFullScreen: function() {
        },
        fullScreenEventName: "",
        fullScreenErrorEventName: ""
      };
      if (document.exitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.fullscreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.requestFullscreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.exitFullscreen();
        };
        fullScreenApi.fullScreenEventName = "fullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "fullscreenerror";
      } else if (document.msExitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.msFullscreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.msRequestFullscreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.msExitFullscreen();
        };
        fullScreenApi.fullScreenEventName = "MSFullscreenChange";
        fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";
      } else if (document.webkitExitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.webkitFullscreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.webkitRequestFullscreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.webkitExitFullscreen();
        };
        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
      } else if (document.webkitCancelFullScreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.webkitCurrentFullScreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.webkitRequestFullScreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.webkitCancelFullScreen();
        };
        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
      } else if (document.mozCancelFullScreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.mozFullScreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.mozRequestFullScreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.mozCancelFullScreen();
        };
        fullScreenApi.fullScreenEventName = "mozfullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";
      }
      fullScreenApi.isFullScreen = function() {
        return fullScreenApi.getFullScreenElement() !== null;
      };
      fullScreenApi.cancelFullScreen = function() {
        $2.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
        fullScreenApi.exitFullScreen();
      };
      $2.extend($2, fullScreenApi);
    })(OpenSeadragon);
    (function($2) {
      $2.EventSource = function() {
        this.events = {};
      };
      $2.EventSource.prototype = {
        /**
         * Add an event handler to be triggered only once (or a given number of times)
         * for a given event.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {OpenSeadragon.EventHandler} handler - Function to call when event
         * is triggered.
         * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
         * to the handler.
         * @param {Number} [times=1] - The number of times to handle the event
         * before removing it.
         */
        addOnceHandler: function(eventName, handler, userData, times) {
          var self = this;
          times = times || 1;
          var count = 0;
          var onceHandler = function(event) {
            count++;
            if (count === times) {
              self.removeHandler(eventName, onceHandler);
            }
            handler(event);
          };
          this.addHandler(eventName, onceHandler, userData);
        },
        /**
         * Add an event handler for a given event.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.
         * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
         */
        addHandler: function(eventName, handler, userData) {
          var events = this.events[eventName];
          if (!events) {
            this.events[eventName] = events = [];
          }
          if (handler && $2.isFunction(handler)) {
            events[events.length] = { handler, userData: userData || null };
          }
        },
        /**
         * Remove a specific event handler for a given event.
         * @function
         * @param {String} eventName - Name of event for which the handler is to be removed.
         * @param {OpenSeadragon.EventHandler} handler - Function to be removed.
         */
        removeHandler: function(eventName, handler) {
          var events = this.events[eventName], handlers = [], i;
          if (!events) {
            return;
          }
          if ($2.isArray(events)) {
            for (i = 0; i < events.length; i++) {
              if (events[i].handler !== handler) {
                handlers.push(events[i]);
              }
            }
            this.events[eventName] = handlers;
          }
        },
        /**
         * Remove all event handlers for a given event type. If no type is given all
         * event handlers for every event type are removed.
         * @function
         * @param {String} eventName - Name of event for which all handlers are to be removed.
         */
        removeAllHandlers: function(eventName) {
          if (eventName) {
            this.events[eventName] = [];
          } else {
            for (var eventType in this.events) {
              this.events[eventType] = [];
            }
          }
        },
        /**
         * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
         * @function
         * @param {String} eventName - Name of event to get handlers for.
         */
        getHandler: function(eventName) {
          var events = this.events[eventName];
          if (!events || !events.length) {
            return null;
          }
          events = events.length === 1 ? [events[0]] : Array.apply(null, events);
          return function(source, args) {
            var i, length = events.length;
            for (i = 0; i < length; i++) {
              if (events[i]) {
                args.eventSource = source;
                args.userData = events[i].userData;
                events[i].handler(args);
              }
            }
          };
        },
        /**
         * Trigger an event, optionally passing additional information.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {Object} eventArgs - Event-specific data.
         */
        raiseEvent: function(eventName, eventArgs) {
          var handler = this.getHandler(eventName);
          if (handler) {
            if (!eventArgs) {
              eventArgs = {};
            }
            handler(this, eventArgs);
          }
        }
      };
    })(OpenSeadragon);
    (function($2) {
      var MOUSETRACKERS = [];
      var THIS = {};
      $2.MouseTracker = function(options) {
        MOUSETRACKERS.push(this);
        var args = arguments;
        if (!$2.isPlainObject(options)) {
          options = {
            element: args[0],
            clickTimeThreshold: args[1],
            clickDistThreshold: args[2]
          };
        }
        this.hash = Math.random();
        this.element = $2.getElement(options.element);
        this.clickTimeThreshold = options.clickTimeThreshold || $2.DEFAULT_SETTINGS.clickTimeThreshold;
        this.clickDistThreshold = options.clickDistThreshold || $2.DEFAULT_SETTINGS.clickDistThreshold;
        this.dblClickTimeThreshold = options.dblClickTimeThreshold || $2.DEFAULT_SETTINGS.dblClickTimeThreshold;
        this.dblClickDistThreshold = options.dblClickDistThreshold || $2.DEFAULT_SETTINGS.dblClickDistThreshold;
        this.userData = options.userData || null;
        this.stopDelay = options.stopDelay || 50;
        this.enterHandler = options.enterHandler || null;
        this.exitHandler = options.exitHandler || null;
        this.pressHandler = options.pressHandler || null;
        this.nonPrimaryPressHandler = options.nonPrimaryPressHandler || null;
        this.releaseHandler = options.releaseHandler || null;
        this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;
        this.moveHandler = options.moveHandler || null;
        this.scrollHandler = options.scrollHandler || null;
        this.clickHandler = options.clickHandler || null;
        this.dblClickHandler = options.dblClickHandler || null;
        this.dragHandler = options.dragHandler || null;
        this.dragEndHandler = options.dragEndHandler || null;
        this.pinchHandler = options.pinchHandler || null;
        this.stopHandler = options.stopHandler || null;
        this.keyDownHandler = options.keyDownHandler || null;
        this.keyUpHandler = options.keyUpHandler || null;
        this.keyHandler = options.keyHandler || null;
        this.focusHandler = options.focusHandler || null;
        this.blurHandler = options.blurHandler || null;
        var _this = this;
        THIS[this.hash] = {
          click: function(event) {
            onClick(_this, event);
          },
          dblclick: function(event) {
            onDblClick(_this, event);
          },
          keydown: function(event) {
            onKeyDown(_this, event);
          },
          keyup: function(event) {
            onKeyUp(_this, event);
          },
          keypress: function(event) {
            onKeyPress(_this, event);
          },
          focus: function(event) {
            onFocus(_this, event);
          },
          blur: function(event) {
            onBlur(_this, event);
          },
          wheel: function(event) {
            onWheel(_this, event);
          },
          mousewheel: function(event) {
            onMouseWheel(_this, event);
          },
          DOMMouseScroll: function(event) {
            onMouseWheel(_this, event);
          },
          MozMousePixelScroll: function(event) {
            onMouseWheel(_this, event);
          },
          mouseenter: function(event) {
            onMouseEnter(_this, event);
          },
          // Used on IE8 only
          mouseleave: function(event) {
            onMouseLeave(_this, event);
          },
          // Used on IE8 only
          mouseover: function(event) {
            onMouseOver(_this, event);
          },
          mouseout: function(event) {
            onMouseOut(_this, event);
          },
          mousedown: function(event) {
            onMouseDown(_this, event);
          },
          mouseup: function(event) {
            onMouseUp(_this, event);
          },
          mouseupcaptured: function(event) {
            onMouseUpCaptured(_this, event);
          },
          mousemove: function(event) {
            onMouseMove(_this, event);
          },
          mousemovecaptured: function(event) {
            onMouseMoveCaptured(_this, event);
          },
          touchstart: function(event) {
            onTouchStart(_this, event);
          },
          touchend: function(event) {
            onTouchEnd(_this, event);
          },
          touchendcaptured: function(event) {
            onTouchEndCaptured(_this, event);
          },
          touchmove: function(event) {
            onTouchMove(_this, event);
          },
          touchmovecaptured: function(event) {
            onTouchMoveCaptured(_this, event);
          },
          touchcancel: function(event) {
            onTouchCancel(_this, event);
          },
          gesturestart: function(event) {
            onGestureStart(_this, event);
          },
          gesturechange: function(event) {
            onGestureChange(_this, event);
          },
          pointerover: function(event) {
            onPointerOver(_this, event);
          },
          MSPointerOver: function(event) {
            onPointerOver(_this, event);
          },
          pointerout: function(event) {
            onPointerOut(_this, event);
          },
          MSPointerOut: function(event) {
            onPointerOut(_this, event);
          },
          pointerdown: function(event) {
            onPointerDown(_this, event);
          },
          MSPointerDown: function(event) {
            onPointerDown(_this, event);
          },
          pointerup: function(event) {
            onPointerUp(_this, event);
          },
          MSPointerUp: function(event) {
            onPointerUp(_this, event);
          },
          pointermove: function(event) {
            onPointerMove(_this, event);
          },
          MSPointerMove: function(event) {
            onPointerMove(_this, event);
          },
          pointercancel: function(event) {
            onPointerCancel(_this, event);
          },
          MSPointerCancel: function(event) {
            onPointerCancel(_this, event);
          },
          pointerupcaptured: function(event) {
            onPointerUpCaptured(_this, event);
          },
          pointermovecaptured: function(event) {
            onPointerMoveCaptured(_this, event);
          },
          tracking: false,
          // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
          // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
          // Active pointers are any pointer being tracked for this element which are in the hit-test area
          //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
          activePointersLists: [],
          // Tracking for double-click gesture
          lastClickPos: null,
          dblClickTimeOut: null,
          // Tracking for pinch gesture
          pinchGPoints: [],
          lastPinchDist: 0,
          currentPinchDist: 0,
          lastPinchCenter: null,
          currentPinchCenter: null
        };
        if (!options.startDisabled) {
          this.setTracking(true);
        }
      };
      $2.MouseTracker.prototype = {
        /**
         * Clean up any events or objects created by the tracker.
         * @function
         */
        destroy: function() {
          var i;
          stopTracking(this);
          this.element = null;
          for (i = 0; i < MOUSETRACKERS.length; i++) {
            if (MOUSETRACKERS[i] === this) {
              MOUSETRACKERS.splice(i, 1);
              break;
            }
          }
          THIS[this.hash] = null;
          delete THIS[this.hash];
        },
        /**
         * Are we currently tracking events on this element.
         * @deprecated Just use this.tracking
         * @function
         * @returns {Boolean} Are we currently tracking events on this element.
         */
        isTracking: function() {
          return THIS[this.hash].tracking;
        },
        /**
         * Enable or disable whether or not we are tracking events on this element.
         * @function
         * @param {Boolean} track True to start tracking, false to stop tracking.
         * @returns {OpenSeadragon.MouseTracker} Chainable.
         */
        setTracking: function(track) {
          if (track) {
            startTracking(this);
          } else {
            stopTracking(this);
          }
          return this;
        },
        /**
         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for all but the given pointer device type.
         * @function
         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
         * @returns {Array.<OpenSeadragon.MouseTracker.GesturePointList>}
         */
        getActivePointersListsExceptType: function(type) {
          var delegate = THIS[this.hash];
          var listArray = [];
          for (var i = 0; i < delegate.activePointersLists.length; ++i) {
            if (delegate.activePointersLists[i].type !== type) {
              listArray.push(delegate.activePointersLists[i]);
            }
          }
          return listArray;
        },
        /**
         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
         * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
         * @function
         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
         * @returns {OpenSeadragon.MouseTracker.GesturePointList}
         */
        getActivePointersListByType: function(type) {
          var delegate = THIS[this.hash], i, len = delegate.activePointersLists.length, list;
          for (i = 0; i < len; i++) {
            if (delegate.activePointersLists[i].type === type) {
              return delegate.activePointersLists[i];
            }
          }
          list = new $2.MouseTracker.GesturePointList(type);
          delegate.activePointersLists.push(list);
          return list;
        },
        /**
         * Returns the total number of pointers currently active on the tracked element.
         * @function
         * @returns {Number}
         */
        getActivePointerCount: function() {
          var delegate = THIS[this.hash], i, len = delegate.activePointersLists.length, count = 0;
          for (i = 0; i < len; i++) {
            count += delegate.activePointersLists[i].getLength();
          }
          return count;
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        enterHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        exitHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        pressHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.button
         *      Button which caused the event.
         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        nonPrimaryPressHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.insideElementReleased
         *      True if the cursor inside the tracked element when the button was released.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        releaseHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.button
         *      Button which caused the event.
         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        nonPrimaryReleaseHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        moveHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.scroll
         *      The scroll delta for the event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        scrollHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Boolean} event.quick
         *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        clickHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dblClickHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {OpenSeadragon.Point} event.delta
         *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
         * @param {Number} event.speed
         *     Current computed speed, in pixels per second.
         * @param {Number} event.direction
         *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dragHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.speed
         *     Speed at the end of a drag gesture, in pixels per second.
         * @param {Number} event.direction
         *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dragEndHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints
         *      Gesture points associated with the gesture. Velocity data can be found here.
         * @param {OpenSeadragon.Point} event.lastCenter
         *      The previous center point of the two pinch contact points relative to the tracked element.
         * @param {OpenSeadragon.Point} event.center
         *      The center point of the two pinch contact points relative to the tracked element.
         * @param {Number} event.lastDistance
         *      The previous distance between the two pinch contact points in CSS pixels.
         * @param {Number} event.distance
         *      The distance between the two pinch contact points in CSS pixels.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        pinchHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        stopHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyDownHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyUpHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        focusHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefaultAction
         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        blurHandler: function() {
        }
      };
      $2.MouseTracker.resetAllMouseTrackers = function() {
        for (var i = 0; i < MOUSETRACKERS.length; i++) {
          if (MOUSETRACKERS[i].isTracking()) {
            MOUSETRACKERS[i].setTracking(false);
            MOUSETRACKERS[i].setTracking(true);
          }
        }
      };
      $2.MouseTracker.gesturePointVelocityTracker = /* @__PURE__ */ function() {
        var trackerPoints = [], intervalId = 0, lastTime = 0;
        var _generateGuid = function(tracker, gPoint) {
          return tracker.hash.toString() + gPoint.type + gPoint.id.toString();
        };
        var _doTracking = function() {
          var i, len = trackerPoints.length, trackPoint, gPoint, now = $2.now(), elapsedTime, distance, speed;
          elapsedTime = now - lastTime;
          lastTime = now;
          for (i = 0; i < len; i++) {
            trackPoint = trackerPoints[i];
            gPoint = trackPoint.gPoint;
            gPoint.direction = Math.atan2(gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x);
            distance = trackPoint.lastPos.distanceTo(gPoint.currentPos);
            trackPoint.lastPos = gPoint.currentPos;
            speed = 1e3 * distance / (elapsedTime + 1);
            gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;
          }
        };
        var addPoint = function(tracker, gPoint) {
          var guid = _generateGuid(tracker, gPoint);
          trackerPoints.push(
            {
              guid,
              gPoint,
              lastPos: gPoint.currentPos
            }
          );
          if (trackerPoints.length === 1) {
            lastTime = $2.now();
            intervalId = window.setInterval(_doTracking, 50);
          }
        };
        var removePoint = function(tracker, gPoint) {
          var guid = _generateGuid(tracker, gPoint), i, len = trackerPoints.length;
          for (i = 0; i < len; i++) {
            if (trackerPoints[i].guid === guid) {
              trackerPoints.splice(i, 1);
              len--;
              if (len === 0) {
                window.clearInterval(intervalId);
              }
              break;
            }
          }
        };
        return {
          addPoint,
          removePoint
        };
      }();
      $2.MouseTracker.captureElement = document;
      $2.MouseTracker.wheelEventName = $2.Browser.vendor == $2.BROWSERS.IE && $2.Browser.version > 8 || "onwheel" in document.createElement("div") ? "wheel" : (
        // Modern browsers support 'wheel'
        document.onmousewheel !== void 0 ? "mousewheel" : (
          // Webkit and IE support at least 'mousewheel'
          "DOMMouseScroll"
        )
      );
      $2.MouseTracker.supportsMouseCapture = function() {
        var divElement = document.createElement("div");
        return $2.isFunction(divElement.setCapture) && $2.isFunction(divElement.releaseCapture);
      }();
      $2.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", $2.MouseTracker.wheelEventName];
      if ($2.MouseTracker.wheelEventName == "DOMMouseScroll") {
        $2.MouseTracker.subscribeEvents.push("MozMousePixelScroll");
      }
      if (window.PointerEvent && (window.navigator.pointerEnabled || $2.Browser.vendor !== $2.BROWSERS.IE)) {
        $2.MouseTracker.havePointerEvents = true;
        $2.MouseTracker.subscribeEvents.push("pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel");
        $2.MouseTracker.unprefixedPointerEvents = true;
        if (navigator.maxTouchPoints) {
          $2.MouseTracker.maxTouchPoints = navigator.maxTouchPoints;
        } else {
          $2.MouseTracker.maxTouchPoints = 0;
        }
        $2.MouseTracker.haveMouseEnter = false;
      } else if (window.MSPointerEvent && window.navigator.msPointerEnabled) {
        $2.MouseTracker.havePointerEvents = true;
        $2.MouseTracker.subscribeEvents.push("MSPointerOver", "MSPointerOut", "MSPointerDown", "MSPointerUp", "MSPointerMove", "MSPointerCancel");
        $2.MouseTracker.unprefixedPointerEvents = false;
        if (navigator.msMaxTouchPoints) {
          $2.MouseTracker.maxTouchPoints = navigator.msMaxTouchPoints;
        } else {
          $2.MouseTracker.maxTouchPoints = 0;
        }
        $2.MouseTracker.haveMouseEnter = false;
      } else {
        $2.MouseTracker.havePointerEvents = false;
        if ($2.Browser.vendor === $2.BROWSERS.IE && $2.Browser.version < 9) {
          $2.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave");
          $2.MouseTracker.haveMouseEnter = true;
        } else {
          $2.MouseTracker.subscribeEvents.push("mouseover", "mouseout");
          $2.MouseTracker.haveMouseEnter = false;
        }
        $2.MouseTracker.subscribeEvents.push("mousedown", "mouseup", "mousemove");
        if ("ontouchstart" in window) {
          $2.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel");
        }
        if ("ongesturestart" in window) {
          $2.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange");
        }
        $2.MouseTracker.mousePointerId = "legacy-mouse";
        $2.MouseTracker.maxTouchPoints = 10;
      }
      $2.MouseTracker.GesturePointList = function(type) {
        this._gPoints = [];
        this.type = type;
        this.buttons = 0;
        this.contacts = 0;
        this.clicks = 0;
        this.captureCount = 0;
      };
      $2.MouseTracker.GesturePointList.prototype = {
        /**
         * @function
         * @returns {Number} Number of gesture points in the list.
         */
        getLength: function() {
          return this._gPoints.length;
        },
        /**
         * @function
         * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).
         */
        asArray: function() {
          return this._gPoints;
        },
        /**
         * @function
         * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
         * @returns {Number} Number of gesture points in the list.
         */
        add: function(gp) {
          return this._gPoints.push(gp);
        },
        /**
         * @function
         * @param {Number} id - The id of the gesture point to remove from the list.
         * @returns {Number} Number of gesture points in the list.
         */
        removeById: function(id) {
          var i, len = this._gPoints.length;
          for (i = 0; i < len; i++) {
            if (this._gPoints[i].id === id) {
              this._gPoints.splice(i, 1);
              break;
            }
          }
          return this._gPoints.length;
        },
        /**
         * @function
         * @param {Number} index - The index of the gesture point to retrieve from the list.
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
         */
        getByIndex: function(index) {
          if (index < this._gPoints.length) {
            return this._gPoints[index];
          }
          return null;
        },
        /**
         * @function
         * @param {Number} id - The id of the gesture point to retrieve from the list.
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
         */
        getById: function(id) {
          var i, len = this._gPoints.length;
          for (i = 0; i < len; i++) {
            if (this._gPoints[i].id === id) {
              return this._gPoints[i];
            }
          }
          return null;
        },
        /**
         * @function
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
         */
        getPrimary: function(id) {
          var i, len = this._gPoints.length;
          for (i = 0; i < len; i++) {
            if (this._gPoints[i].isPrimary) {
              return this._gPoints[i];
            }
          }
          return null;
        },
        /**
         * Increment this pointer's contact count.
         * It will evaluate whether this pointer type is allowed to have multiple contacts.
         * @function
         */
        addContact: function() {
          ++this.contacts;
          if (this.contacts > 1 && (this.type === "mouse" || this.type === "pen")) {
            this.contacts = 1;
          }
        },
        /**
         * Decrement this pointer's contact count.
         * It will make sure the count does not go below 0.
         * @function
         */
        removeContact: function() {
          --this.contacts;
          if (this.contacts < 0) {
            this.contacts = 0;
          }
        }
      };
      function clearTrackedPointers(tracker) {
        var delegate = THIS[tracker.hash], i, pointerListCount = delegate.activePointersLists.length;
        for (i = 0; i < pointerListCount; i++) {
          if (delegate.activePointersLists[i].captureCount > 0) {
            $2.removeEvent(
              $2.MouseTracker.captureElement,
              "mousemove",
              delegate.mousemovecaptured,
              true
            );
            $2.removeEvent(
              $2.MouseTracker.captureElement,
              "mouseup",
              delegate.mouseupcaptured,
              true
            );
            $2.removeEvent(
              $2.MouseTracker.captureElement,
              $2.MouseTracker.unprefixedPointerEvents ? "pointermove" : "MSPointerMove",
              delegate.pointermovecaptured,
              true
            );
            $2.removeEvent(
              $2.MouseTracker.captureElement,
              $2.MouseTracker.unprefixedPointerEvents ? "pointerup" : "MSPointerUp",
              delegate.pointerupcaptured,
              true
            );
            $2.removeEvent(
              $2.MouseTracker.captureElement,
              "touchmove",
              delegate.touchmovecaptured,
              true
            );
            $2.removeEvent(
              $2.MouseTracker.captureElement,
              "touchend",
              delegate.touchendcaptured,
              true
            );
            delegate.activePointersLists[i].captureCount = 0;
          }
        }
        for (i = 0; i < pointerListCount; i++) {
          delegate.activePointersLists.pop();
        }
      }
      function startTracking(tracker) {
        var delegate = THIS[tracker.hash], event, i;
        if (!delegate.tracking) {
          for (i = 0; i < $2.MouseTracker.subscribeEvents.length; i++) {
            event = $2.MouseTracker.subscribeEvents[i];
            $2.addEvent(
              tracker.element,
              event,
              delegate[event],
              false
            );
          }
          clearTrackedPointers(tracker);
          delegate.tracking = true;
        }
      }
      function stopTracking(tracker) {
        var delegate = THIS[tracker.hash], event, i;
        if (delegate.tracking) {
          for (i = 0; i < $2.MouseTracker.subscribeEvents.length; i++) {
            event = $2.MouseTracker.subscribeEvents[i];
            $2.removeEvent(
              tracker.element,
              event,
              delegate[event],
              false
            );
          }
          clearTrackedPointers(tracker);
          delegate.tracking = false;
        }
      }
      function getCaptureEventParams(tracker, pointerType) {
        var delegate = THIS[tracker.hash];
        if (pointerType === "pointerevent") {
          return {
            upName: $2.MouseTracker.unprefixedPointerEvents ? "pointerup" : "MSPointerUp",
            upHandler: delegate.pointerupcaptured,
            moveName: $2.MouseTracker.unprefixedPointerEvents ? "pointermove" : "MSPointerMove",
            moveHandler: delegate.pointermovecaptured
          };
        } else if (pointerType === "mouse") {
          return {
            upName: "mouseup",
            upHandler: delegate.mouseupcaptured,
            moveName: "mousemove",
            moveHandler: delegate.mousemovecaptured
          };
        } else if (pointerType === "touch") {
          return {
            upName: "touchend",
            upHandler: delegate.touchendcaptured,
            moveName: "touchmove",
            moveHandler: delegate.touchmovecaptured
          };
        } else {
          throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
        }
      }
      function capturePointer(tracker, pointerType, pointerCount) {
        var pointsList = tracker.getActivePointersListByType(pointerType), eventParams;
        pointsList.captureCount += pointerCount || 1;
        if (pointsList.captureCount === 1) {
          if ($2.Browser.vendor === $2.BROWSERS.IE && $2.Browser.version < 9) {
            tracker.element.setCapture(true);
          } else {
            eventParams = getCaptureEventParams(tracker, $2.MouseTracker.havePointerEvents ? "pointerevent" : pointerType);
            if (isInIframe && canAccessEvents(window.top)) {
              $2.addEvent(
                window.top,
                eventParams.upName,
                eventParams.upHandler,
                true
              );
            }
            $2.addEvent(
              $2.MouseTracker.captureElement,
              eventParams.upName,
              eventParams.upHandler,
              true
            );
            $2.addEvent(
              $2.MouseTracker.captureElement,
              eventParams.moveName,
              eventParams.moveHandler,
              true
            );
          }
        }
      }
      function releasePointer(tracker, pointerType, pointerCount) {
        var pointsList = tracker.getActivePointersListByType(pointerType), eventParams;
        pointsList.captureCount -= pointerCount || 1;
        if (pointsList.captureCount === 0) {
          if ($2.Browser.vendor === $2.BROWSERS.IE && $2.Browser.version < 9) {
            tracker.element.releaseCapture();
          } else {
            eventParams = getCaptureEventParams(tracker, $2.MouseTracker.havePointerEvents ? "pointerevent" : pointerType);
            if (isInIframe && canAccessEvents(window.top)) {
              $2.removeEvent(
                window.top,
                eventParams.upName,
                eventParams.upHandler,
                true
              );
            }
            $2.removeEvent(
              $2.MouseTracker.captureElement,
              eventParams.moveName,
              eventParams.moveHandler,
              true
            );
            $2.removeEvent(
              $2.MouseTracker.captureElement,
              eventParams.upName,
              eventParams.upHandler,
              true
            );
          }
        }
      }
      function getPointerType(event) {
        var pointerTypeStr;
        if ($2.MouseTracker.unprefixedPointerEvents) {
          pointerTypeStr = event.pointerType;
        } else {
          switch (event.pointerType) {
            case 2:
              pointerTypeStr = "touch";
              break;
            case 3:
              pointerTypeStr = "pen";
              break;
            case 4:
              pointerTypeStr = "mouse";
              break;
            default:
              pointerTypeStr = "";
          }
        }
        return pointerTypeStr;
      }
      function getMouseAbsolute(event) {
        return $2.getMousePosition(event);
      }
      function getMouseRelative(event, element) {
        return getPointRelativeToAbsolute(getMouseAbsolute(event), element);
      }
      function getPointRelativeToAbsolute(point, element) {
        var offset = $2.getElementOffset(element);
        return point.minus(offset);
      }
      function getCenterPoint(point1, point2) {
        return new $2.Point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);
      }
      function onClick(tracker, event) {
        if (tracker.clickHandler) {
          $2.cancelEvent(event);
        }
      }
      function onDblClick(tracker, event) {
        if (tracker.dblClickHandler) {
          $2.cancelEvent(event);
        }
      }
      function onKeyDown(tracker, event) {
        var propagate;
        if (tracker.keyDownHandler) {
          event = $2.getEvent(event);
          propagate = tracker.keyDownHandler(
            {
              eventSource: tracker,
              keyCode: event.keyCode ? event.keyCode : event.charCode,
              ctrl: event.ctrlKey,
              shift: event.shiftKey,
              alt: event.altKey,
              meta: event.metaKey,
              originalEvent: event,
              preventDefaultAction: false,
              userData: tracker.userData
            }
          );
          if (!propagate) {
            $2.cancelEvent(event);
          }
        }
      }
      function onKeyUp(tracker, event) {
        var propagate;
        if (tracker.keyUpHandler) {
          event = $2.getEvent(event);
          propagate = tracker.keyUpHandler(
            {
              eventSource: tracker,
              keyCode: event.keyCode ? event.keyCode : event.charCode,
              ctrl: event.ctrlKey,
              shift: event.shiftKey,
              alt: event.altKey,
              meta: event.metaKey,
              originalEvent: event,
              preventDefaultAction: false,
              userData: tracker.userData
            }
          );
          if (!propagate) {
            $2.cancelEvent(event);
          }
        }
      }
      function onKeyPress(tracker, event) {
        var propagate;
        if (tracker.keyHandler) {
          event = $2.getEvent(event);
          propagate = tracker.keyHandler(
            {
              eventSource: tracker,
              keyCode: event.keyCode ? event.keyCode : event.charCode,
              ctrl: event.ctrlKey,
              shift: event.shiftKey,
              alt: event.altKey,
              meta: event.metaKey,
              originalEvent: event,
              preventDefaultAction: false,
              userData: tracker.userData
            }
          );
          if (!propagate) {
            $2.cancelEvent(event);
          }
        }
      }
      function onFocus(tracker, event) {
        var propagate;
        if (tracker.focusHandler) {
          event = $2.getEvent(event);
          propagate = tracker.focusHandler(
            {
              eventSource: tracker,
              originalEvent: event,
              preventDefaultAction: false,
              userData: tracker.userData
            }
          );
          if (propagate === false) {
            $2.cancelEvent(event);
          }
        }
      }
      function onBlur(tracker, event) {
        var propagate;
        if (tracker.blurHandler) {
          event = $2.getEvent(event);
          propagate = tracker.blurHandler(
            {
              eventSource: tracker,
              originalEvent: event,
              preventDefaultAction: false,
              userData: tracker.userData
            }
          );
          if (propagate === false) {
            $2.cancelEvent(event);
          }
        }
      }
      function onWheel(tracker, event) {
        handleWheelEvent(tracker, event, event);
      }
      function onMouseWheel(tracker, event) {
        event = $2.getEvent(event);
        var simulatedEvent = {
          target: event.target || event.srcElement,
          type: "wheel",
          shiftKey: event.shiftKey || false,
          clientX: event.clientX,
          clientY: event.clientY,
          pageX: event.pageX ? event.pageX : event.clientX,
          pageY: event.pageY ? event.pageY : event.clientY,
          deltaMode: event.type == "MozMousePixelScroll" ? 0 : 1,
          // 0=pixel, 1=line, 2=page
          deltaX: 0,
          deltaZ: 0
        };
        if ($2.MouseTracker.wheelEventName == "mousewheel") {
          simulatedEvent.deltaY = -event.wheelDelta / $2.DEFAULT_SETTINGS.pixelsPerWheelLine;
        } else {
          simulatedEvent.deltaY = event.detail;
        }
        handleWheelEvent(tracker, simulatedEvent, event);
      }
      function handleWheelEvent(tracker, event, originalEvent) {
        var nDelta = 0, propagate;
        nDelta = event.deltaY < 0 ? 1 : -1;
        if (tracker.scrollHandler) {
          propagate = tracker.scrollHandler(
            {
              eventSource: tracker,
              pointerType: "mouse",
              position: getMouseRelative(event, tracker.element),
              scroll: nDelta,
              shift: event.shiftKey,
              isTouchEvent: false,
              originalEvent,
              preventDefaultAction: false,
              userData: tracker.userData
            }
          );
          if (propagate === false) {
            $2.cancelEvent(originalEvent);
          }
        }
      }
      function isParentChild(parent, child) {
        if (parent === child) {
          return false;
        }
        while (child && child !== parent) {
          child = child.parentNode;
        }
        return child === parent;
      }
      function onMouseEnter(tracker, event) {
        event = $2.getEvent(event);
        handleMouseEnter(tracker, event);
      }
      function onMouseOver(tracker, event) {
        event = $2.getEvent(event);
        if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) {
          return;
        }
        handleMouseEnter(tracker, event);
      }
      function handleMouseEnter(tracker, event) {
        var gPoint = {
          id: $2.MouseTracker.mousePointerId,
          type: "mouse",
          isPrimary: true,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        updatePointersEnter(tracker, event, [gPoint]);
      }
      function onMouseLeave(tracker, event) {
        event = $2.getEvent(event);
        handleMouseExit(tracker, event);
      }
      function onMouseOut(tracker, event) {
        event = $2.getEvent(event);
        if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) {
          return;
        }
        handleMouseExit(tracker, event);
      }
      function handleMouseExit(tracker, event) {
        var gPoint = {
          id: $2.MouseTracker.mousePointerId,
          type: "mouse",
          isPrimary: true,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        updatePointersExit(tracker, event, [gPoint]);
      }
      function getStandardizedButton(button) {
        if ($2.Browser.vendor === $2.BROWSERS.IE && $2.Browser.version < 9) {
          if (button === 1) {
            return 0;
          } else if (button === 2) {
            return 2;
          } else if (button === 4) {
            return 1;
          } else {
            return -1;
          }
        } else {
          return button;
        }
      }
      function onMouseDown(tracker, event) {
        var gPoint;
        event = $2.getEvent(event);
        gPoint = {
          id: $2.MouseTracker.mousePointerId,
          type: "mouse",
          isPrimary: true,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        if (updatePointersDown(tracker, event, [gPoint], getStandardizedButton(event.button))) {
          $2.stopEvent(event);
          capturePointer(tracker, "mouse");
        }
        if (tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler) {
          $2.cancelEvent(event);
        }
      }
      function onMouseUp(tracker, event) {
        handleMouseUp(tracker, event);
      }
      function onMouseUpCaptured(tracker, event) {
        handleMouseUp(tracker, event);
        $2.stopEvent(event);
      }
      function handleMouseUp(tracker, event) {
        var gPoint;
        event = $2.getEvent(event);
        gPoint = {
          id: $2.MouseTracker.mousePointerId,
          type: "mouse",
          isPrimary: true,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        if (updatePointersUp(tracker, event, [gPoint], getStandardizedButton(event.button))) {
          releasePointer(tracker, "mouse");
        }
      }
      function onMouseMove(tracker, event) {
        handleMouseMove(tracker, event);
      }
      function onMouseMoveCaptured(tracker, event) {
        handleMouseMove(tracker, event);
        $2.stopEvent(event);
      }
      function handleMouseMove(tracker, event) {
        var gPoint;
        event = $2.getEvent(event);
        gPoint = {
          id: $2.MouseTracker.mousePointerId,
          type: "mouse",
          isPrimary: true,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        updatePointersMove(tracker, event, [gPoint]);
      }
      function abortContacts(tracker, event, pointsList) {
        var i, gPointCount = pointsList.getLength(), abortGPoints = [];
        if (pointsList.type === "touch" || pointsList.contacts > 0) {
          for (i = 0; i < gPointCount; i++) {
            abortGPoints.push(pointsList.getByIndex(i));
          }
          if (abortGPoints.length > 0) {
            updatePointersUp(tracker, event, abortGPoints, 0);
            pointsList.captureCount = 1;
            releasePointer(tracker, pointsList.type);
            updatePointersExit(tracker, event, abortGPoints);
          }
        }
      }
      function onTouchStart(tracker, event) {
        var time, i, j, touchCount = event.changedTouches.length, gPoints = [], parentGPoints, pointsList = tracker.getActivePointersListByType("touch");
        time = $2.now();
        if (pointsList.getLength() > event.touches.length - touchCount) {
          $2.console.warn("Tracked touch contact count doesn't match event.touches.length. Removing all tracked touch pointers.");
          abortContacts(tracker, event, pointsList);
        }
        for (i = 0; i < touchCount; i++) {
          gPoints.push({
            id: event.changedTouches[i].identifier,
            type: "touch",
            // isPrimary not set - let the updatePointers functions determine it
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: time
          });
        }
        updatePointersEnter(tracker, event, gPoints);
        for (i = 0; i < MOUSETRACKERS.length; i++) {
          if (MOUSETRACKERS[i] !== tracker && MOUSETRACKERS[i].isTracking() && isParentChild(MOUSETRACKERS[i].element, tracker.element)) {
            parentGPoints = [];
            for (j = 0; j < touchCount; j++) {
              parentGPoints.push({
                id: event.changedTouches[j].identifier,
                type: "touch",
                // isPrimary not set - let the updatePointers functions determine it
                currentPos: getMouseAbsolute(event.changedTouches[j]),
                currentTime: time
              });
            }
            updatePointersEnter(MOUSETRACKERS[i], event, parentGPoints);
          }
        }
        if (updatePointersDown(tracker, event, gPoints, 0)) {
          $2.stopEvent(event);
          capturePointer(tracker, "touch", touchCount);
        }
        $2.cancelEvent(event);
      }
      function onTouchEnd(tracker, event) {
        handleTouchEnd(tracker, event);
      }
      function onTouchEndCaptured(tracker, event) {
        handleTouchEnd(tracker, event);
        $2.stopEvent(event);
      }
      function handleTouchEnd(tracker, event) {
        var time, i, j, touchCount = event.changedTouches.length, gPoints = [], parentGPoints;
        time = $2.now();
        for (i = 0; i < touchCount; i++) {
          gPoints.push({
            id: event.changedTouches[i].identifier,
            type: "touch",
            // isPrimary not set - let the updatePointers functions determine it
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: time
          });
        }
        if (updatePointersUp(tracker, event, gPoints, 0)) {
          releasePointer(tracker, "touch", touchCount);
        }
        updatePointersExit(tracker, event, gPoints);
        for (i = 0; i < MOUSETRACKERS.length; i++) {
          if (MOUSETRACKERS[i] !== tracker && MOUSETRACKERS[i].isTracking() && isParentChild(MOUSETRACKERS[i].element, tracker.element)) {
            parentGPoints = [];
            for (j = 0; j < touchCount; j++) {
              parentGPoints.push({
                id: event.changedTouches[j].identifier,
                type: "touch",
                // isPrimary not set - let the updatePointers functions determine it
                currentPos: getMouseAbsolute(event.changedTouches[j]),
                currentTime: time
              });
            }
            updatePointersExit(MOUSETRACKERS[i], event, parentGPoints);
          }
        }
        $2.cancelEvent(event);
      }
      function onTouchMove(tracker, event) {
        handleTouchMove(tracker, event);
      }
      function onTouchMoveCaptured(tracker, event) {
        handleTouchMove(tracker, event);
        $2.stopEvent(event);
      }
      function handleTouchMove(tracker, event) {
        var i, touchCount = event.changedTouches.length, gPoints = [];
        for (i = 0; i < touchCount; i++) {
          gPoints.push({
            id: event.changedTouches[i].identifier,
            type: "touch",
            // isPrimary not set - let the updatePointers functions determine it
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: $2.now()
          });
        }
        updatePointersMove(tracker, event, gPoints);
        $2.cancelEvent(event);
      }
      function onTouchCancel(tracker, event) {
        var pointsList = tracker.getActivePointersListByType("touch");
        abortContacts(tracker, event, pointsList);
      }
      function onGestureStart(tracker, event) {
        event.stopPropagation();
        event.preventDefault();
        return false;
      }
      function onGestureChange(tracker, event) {
        event.stopPropagation();
        event.preventDefault();
        return false;
      }
      function onPointerOver(tracker, event) {
        var gPoint;
        if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) {
          return;
        }
        gPoint = {
          id: event.pointerId,
          type: getPointerType(event),
          isPrimary: event.isPrimary,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        updatePointersEnter(tracker, event, [gPoint]);
      }
      function onPointerOut(tracker, event) {
        var gPoint;
        if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) {
          return;
        }
        gPoint = {
          id: event.pointerId,
          type: getPointerType(event),
          isPrimary: event.isPrimary,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        updatePointersExit(tracker, event, [gPoint]);
      }
      function onPointerDown(tracker, event) {
        var gPoint;
        gPoint = {
          id: event.pointerId,
          type: getPointerType(event),
          isPrimary: event.isPrimary,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        if (updatePointersDown(tracker, event, [gPoint], event.button)) {
          $2.stopEvent(event);
          capturePointer(tracker, gPoint.type);
        }
        if (tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
          $2.cancelEvent(event);
        }
      }
      function onPointerUp(tracker, event) {
        handlePointerUp(tracker, event);
      }
      function onPointerUpCaptured(tracker, event) {
        var pointsList = tracker.getActivePointersListByType(getPointerType(event));
        if (pointsList.getById(event.pointerId)) {
          handlePointerUp(tracker, event);
        }
        $2.stopEvent(event);
      }
      function handlePointerUp(tracker, event) {
        var gPoint;
        gPoint = {
          id: event.pointerId,
          type: getPointerType(event),
          isPrimary: event.isPrimary,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        if (updatePointersUp(tracker, event, [gPoint], event.button)) {
          releasePointer(tracker, gPoint.type);
        }
      }
      function onPointerMove(tracker, event) {
        handlePointerMove(tracker, event);
      }
      function onPointerMoveCaptured(tracker, event) {
        var pointsList = tracker.getActivePointersListByType(getPointerType(event));
        if (pointsList.getById(event.pointerId)) {
          handlePointerMove(tracker, event);
        }
        $2.stopEvent(event);
      }
      function handlePointerMove(tracker, event) {
        var gPoint;
        gPoint = {
          id: event.pointerId,
          type: getPointerType(event),
          isPrimary: event.isPrimary,
          currentPos: getMouseAbsolute(event),
          currentTime: $2.now()
        };
        updatePointersMove(tracker, event, [gPoint]);
      }
      function onPointerCancel(tracker, event) {
        var gPoint;
        gPoint = {
          id: event.pointerId,
          type: getPointerType(event)
        };
        updatePointersCancel(tracker, event, [gPoint]);
      }
      function startTrackingPointer(pointsList, gPoint) {
        if (!Object.prototype.hasOwnProperty.call(gPoint, "isPrimary")) {
          if (pointsList.getLength() === 0) {
            gPoint.isPrimary = true;
          } else {
            gPoint.isPrimary = false;
          }
        }
        gPoint.speed = 0;
        gPoint.direction = 0;
        gPoint.contactPos = gPoint.currentPos;
        gPoint.contactTime = gPoint.currentTime;
        gPoint.lastPos = gPoint.currentPos;
        gPoint.lastTime = gPoint.currentTime;
        return pointsList.add(gPoint);
      }
      function stopTrackingPointer(pointsList, gPoint) {
        var listLength, primaryPoint;
        if (pointsList.getById(gPoint.id)) {
          listLength = pointsList.removeById(gPoint.id);
          if (!Object.prototype.hasOwnProperty.call(gPoint, "isPrimary")) {
            primaryPoint = pointsList.getPrimary();
            if (!primaryPoint) {
              primaryPoint = pointsList.getByIndex(0);
              if (primaryPoint) {
                primaryPoint.isPrimary = true;
              }
            }
          }
        } else {
          listLength = pointsList.getLength();
        }
        return listLength;
      }
      function updatePointersEnter(tracker, event, gPoints) {
        var pointsList = tracker.getActivePointersListByType(gPoints[0].type), i, gPointCount = gPoints.length, curGPoint, updateGPoint, propagate;
        for (i = 0; i < gPointCount; i++) {
          curGPoint = gPoints[i];
          updateGPoint = pointsList.getById(curGPoint.id);
          if (updateGPoint) {
            updateGPoint.insideElement = true;
            updateGPoint.lastPos = updateGPoint.currentPos;
            updateGPoint.lastTime = updateGPoint.currentTime;
            updateGPoint.currentPos = curGPoint.currentPos;
            updateGPoint.currentTime = curGPoint.currentTime;
            curGPoint = updateGPoint;
          } else {
            curGPoint.captured = false;
            curGPoint.insideElementPressed = false;
            curGPoint.insideElement = true;
            startTrackingPointer(pointsList, curGPoint);
          }
          if (tracker.enterHandler) {
            propagate = tracker.enterHandler(
              {
                eventSource: tracker,
                pointerType: curGPoint.type,
                position: getPointRelativeToAbsolute(curGPoint.currentPos, tracker.element),
                buttons: pointsList.buttons,
                pointers: tracker.getActivePointerCount(),
                insideElementPressed: curGPoint.insideElementPressed,
                buttonDownAny: pointsList.buttons !== 0,
                isTouchEvent: curGPoint.type === "touch",
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $2.cancelEvent(event);
            }
          }
        }
      }
      function updatePointersExit(tracker, event, gPoints) {
        var pointsList = tracker.getActivePointersListByType(gPoints[0].type), i, gPointCount = gPoints.length, curGPoint, updateGPoint, propagate;
        for (i = 0; i < gPointCount; i++) {
          curGPoint = gPoints[i];
          updateGPoint = pointsList.getById(curGPoint.id);
          if (updateGPoint) {
            if (updateGPoint.captured) {
              updateGPoint.insideElement = false;
              updateGPoint.lastPos = updateGPoint.currentPos;
              updateGPoint.lastTime = updateGPoint.currentTime;
              updateGPoint.currentPos = curGPoint.currentPos;
              updateGPoint.currentTime = curGPoint.currentTime;
            } else {
              stopTrackingPointer(pointsList, updateGPoint);
            }
            curGPoint = updateGPoint;
          }
          if (tracker.exitHandler) {
            propagate = tracker.exitHandler(
              {
                eventSource: tracker,
                pointerType: curGPoint.type,
                position: curGPoint.currentPos && getPointRelativeToAbsolute(curGPoint.currentPos, tracker.element),
                buttons: pointsList.buttons,
                pointers: tracker.getActivePointerCount(),
                insideElementPressed: updateGPoint ? updateGPoint.insideElementPressed : false,
                buttonDownAny: pointsList.buttons !== 0,
                isTouchEvent: curGPoint.type === "touch",
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $2.cancelEvent(event);
            }
          }
        }
      }
      function updatePointersDown(tracker, event, gPoints, buttonChanged) {
        var delegate = THIS[tracker.hash], propagate, pointsList = tracker.getActivePointersListByType(gPoints[0].type), i, gPointCount = gPoints.length, curGPoint, updateGPoint;
        if (typeof event.buttons !== "undefined") {
          pointsList.buttons = event.buttons;
        } else {
          if ($2.Browser.vendor === $2.BROWSERS.IE && $2.Browser.version < 9) {
            if (buttonChanged === 0) {
              pointsList.buttons += 1;
            } else if (buttonChanged === 1) {
              pointsList.buttons += 4;
            } else if (buttonChanged === 2) {
              pointsList.buttons += 2;
            } else if (buttonChanged === 3) {
              pointsList.buttons += 8;
            } else if (buttonChanged === 4) {
              pointsList.buttons += 16;
            } else if (buttonChanged === 5) {
              pointsList.buttons += 32;
            }
          } else {
            if (buttonChanged === 0) {
              pointsList.buttons |= 1;
            } else if (buttonChanged === 1) {
              pointsList.buttons |= 4;
            } else if (buttonChanged === 2) {
              pointsList.buttons |= 2;
            } else if (buttonChanged === 3) {
              pointsList.buttons |= 8;
            } else if (buttonChanged === 4) {
              pointsList.buttons |= 16;
            } else if (buttonChanged === 5) {
              pointsList.buttons |= 32;
            }
          }
        }
        var otherPointsLists = tracker.getActivePointersListsExceptType(gPoints[0].type);
        for (i = 0; i < otherPointsLists.length; i++) {
          abortContacts(tracker, event, otherPointsLists[i]);
        }
        if (buttonChanged !== 0) {
          if (tracker.nonPrimaryPressHandler) {
            propagate = tracker.nonPrimaryPressHandler(
              {
                eventSource: tracker,
                pointerType: gPoints[0].type,
                position: getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                button: buttonChanged,
                buttons: pointsList.buttons,
                isTouchEvent: gPoints[0].type === "touch",
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $2.cancelEvent(event);
            }
          }
          return false;
        }
        for (i = 0; i < gPointCount; i++) {
          curGPoint = gPoints[i];
          updateGPoint = pointsList.getById(curGPoint.id);
          if (updateGPoint) {
            updateGPoint.captured = true;
            updateGPoint.insideElementPressed = true;
            updateGPoint.insideElement = true;
            updateGPoint.contactPos = curGPoint.currentPos;
            updateGPoint.contactTime = curGPoint.currentTime;
            updateGPoint.lastPos = updateGPoint.currentPos;
            updateGPoint.lastTime = updateGPoint.currentTime;
            updateGPoint.currentPos = curGPoint.currentPos;
            updateGPoint.currentTime = curGPoint.currentTime;
            curGPoint = updateGPoint;
          } else {
            curGPoint.captured = true;
            curGPoint.insideElementPressed = true;
            curGPoint.insideElement = true;
            startTrackingPointer(pointsList, curGPoint);
          }
          pointsList.addContact();
          if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
            $2.MouseTracker.gesturePointVelocityTracker.addPoint(tracker, curGPoint);
          }
          if (pointsList.contacts === 1) {
            if (tracker.pressHandler) {
              propagate = tracker.pressHandler(
                {
                  eventSource: tracker,
                  pointerType: curGPoint.type,
                  position: getPointRelativeToAbsolute(curGPoint.contactPos, tracker.element),
                  buttons: pointsList.buttons,
                  isTouchEvent: curGPoint.type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $2.cancelEvent(event);
              }
            }
          } else if (pointsList.contacts === 2) {
            if (tracker.pinchHandler && curGPoint.type === "touch") {
              delegate.pinchGPoints = pointsList.asArray();
              delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
              delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
            }
          }
        }
        return true;
      }
      function updatePointersUp(tracker, event, gPoints, buttonChanged) {
        var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoints[0].type), propagate, releasePoint, releaseTime, i, gPointCount = gPoints.length, curGPoint, updateGPoint, releaseCapture = false, wasCaptured = false, quick;
        if (typeof event.buttons !== "undefined") {
          pointsList.buttons = event.buttons;
        } else {
          if ($2.Browser.vendor === $2.BROWSERS.IE && $2.Browser.version < 9) {
            if (buttonChanged === 0) {
              pointsList.buttons -= 1;
            } else if (buttonChanged === 1) {
              pointsList.buttons -= 4;
            } else if (buttonChanged === 2) {
              pointsList.buttons -= 2;
            } else if (buttonChanged === 3) {
              pointsList.buttons -= 8;
            } else if (buttonChanged === 4) {
              pointsList.buttons -= 16;
            } else if (buttonChanged === 5) {
              pointsList.buttons -= 32;
            }
          } else {
            if (buttonChanged === 0) {
              pointsList.buttons ^= ~1;
            } else if (buttonChanged === 1) {
              pointsList.buttons ^= ~4;
            } else if (buttonChanged === 2) {
              pointsList.buttons ^= ~2;
            } else if (buttonChanged === 3) {
              pointsList.buttons ^= ~8;
            } else if (buttonChanged === 4) {
              pointsList.buttons ^= ~16;
            } else if (buttonChanged === 5) {
              pointsList.buttons ^= ~32;
            }
          }
        }
        if (buttonChanged !== 0) {
          if (tracker.nonPrimaryReleaseHandler) {
            propagate = tracker.nonPrimaryReleaseHandler(
              {
                eventSource: tracker,
                pointerType: gPoints[0].type,
                position: getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                button: buttonChanged,
                buttons: pointsList.buttons,
                isTouchEvent: gPoints[0].type === "touch",
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $2.cancelEvent(event);
            }
          }
          var otherPointsList = tracker.getActivePointersListByType("mouse");
          abortContacts(tracker, event, otherPointsList);
          return false;
        }
        if (typeof gPoints[0].currentPos === "undefined") {
          abortContacts(tracker, event, pointsList);
          return false;
        }
        for (i = 0; i < gPointCount; i++) {
          curGPoint = gPoints[i];
          updateGPoint = pointsList.getById(curGPoint.id);
          if (updateGPoint) {
            if (updateGPoint.captured) {
              updateGPoint.captured = false;
              releaseCapture = true;
              wasCaptured = true;
            }
            updateGPoint.lastPos = updateGPoint.currentPos;
            updateGPoint.lastTime = updateGPoint.currentTime;
            updateGPoint.currentPos = curGPoint.currentPos;
            updateGPoint.currentTime = curGPoint.currentTime;
            if (!updateGPoint.insideElement) {
              stopTrackingPointer(pointsList, updateGPoint);
            }
            releasePoint = updateGPoint.currentPos;
            releaseTime = updateGPoint.currentTime;
            if (wasCaptured) {
              pointsList.removeContact();
              if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
                $2.MouseTracker.gesturePointVelocityTracker.removePoint(tracker, updateGPoint);
              }
              if (pointsList.contacts === 0) {
                if (tracker.releaseHandler) {
                  propagate = tracker.releaseHandler(
                    {
                      eventSource: tracker,
                      pointerType: updateGPoint.type,
                      position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                      buttons: pointsList.buttons,
                      insideElementPressed: updateGPoint.insideElementPressed,
                      insideElementReleased: updateGPoint.insideElement,
                      isTouchEvent: updateGPoint.type === "touch",
                      originalEvent: event,
                      preventDefaultAction: false,
                      userData: tracker.userData
                    }
                  );
                  if (propagate === false) {
                    $2.cancelEvent(event);
                  }
                }
                if (tracker.dragEndHandler && !updateGPoint.currentPos.equals(updateGPoint.contactPos)) {
                  propagate = tracker.dragEndHandler(
                    {
                      eventSource: tracker,
                      pointerType: updateGPoint.type,
                      position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                      speed: updateGPoint.speed,
                      direction: updateGPoint.direction,
                      shift: event.shiftKey,
                      isTouchEvent: updateGPoint.type === "touch",
                      originalEvent: event,
                      preventDefaultAction: false,
                      userData: tracker.userData
                    }
                  );
                  if (propagate === false) {
                    $2.cancelEvent(event);
                  }
                }
                if ((tracker.clickHandler || tracker.dblClickHandler) && updateGPoint.insideElement) {
                  quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold && updateGPoint.contactPos.distanceTo(releasePoint) <= tracker.clickDistThreshold;
                  if (tracker.clickHandler) {
                    propagate = tracker.clickHandler(
                      {
                        eventSource: tracker,
                        pointerType: updateGPoint.type,
                        position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                        quick,
                        shift: event.shiftKey,
                        isTouchEvent: updateGPoint.type === "touch",
                        originalEvent: event,
                        preventDefaultAction: false,
                        userData: tracker.userData
                      }
                    );
                    if (propagate === false) {
                      $2.cancelEvent(event);
                    }
                  }
                  if (tracker.dblClickHandler && quick) {
                    pointsList.clicks++;
                    if (pointsList.clicks === 1) {
                      delegate.lastClickPos = releasePoint;
                      delegate.dblClickTimeOut = setTimeout(function() {
                        pointsList.clicks = 0;
                      }, tracker.dblClickTimeThreshold);
                    } else if (pointsList.clicks === 2) {
                      clearTimeout(delegate.dblClickTimeOut);
                      pointsList.clicks = 0;
                      if (delegate.lastClickPos.distanceTo(releasePoint) <= tracker.dblClickDistThreshold) {
                        propagate = tracker.dblClickHandler(
                          {
                            eventSource: tracker,
                            pointerType: updateGPoint.type,
                            position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                            shift: event.shiftKey,
                            isTouchEvent: updateGPoint.type === "touch",
                            originalEvent: event,
                            preventDefaultAction: false,
                            userData: tracker.userData
                          }
                        );
                        if (propagate === false) {
                          $2.cancelEvent(event);
                        }
                      }
                      delegate.lastClickPos = null;
                    }
                  }
                }
              } else if (pointsList.contacts === 2) {
                if (tracker.pinchHandler && updateGPoint.type === "touch") {
                  delegate.pinchGPoints = pointsList.asArray();
                  delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
                  delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
                }
              }
            } else {
              if (tracker.releaseHandler) {
                propagate = tracker.releaseHandler(
                  {
                    eventSource: tracker,
                    pointerType: updateGPoint.type,
                    position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                    buttons: pointsList.buttons,
                    insideElementPressed: updateGPoint.insideElementPressed,
                    insideElementReleased: updateGPoint.insideElement,
                    isTouchEvent: updateGPoint.type === "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                  }
                );
                if (propagate === false) {
                  $2.cancelEvent(event);
                }
              }
            }
          }
        }
        return releaseCapture;
      }
      function updatePointersMove(tracker, event, gPoints) {
        var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoints[0].type), i, gPointCount = gPoints.length, curGPoint, updateGPoint, gPointArray, delta, propagate;
        if (typeof event.buttons !== "undefined") {
          pointsList.buttons = event.buttons;
        }
        for (i = 0; i < gPointCount; i++) {
          curGPoint = gPoints[i];
          updateGPoint = pointsList.getById(curGPoint.id);
          if (updateGPoint) {
            if (Object.prototype.hasOwnProperty.call(curGPoint, "isPrimary")) {
              updateGPoint.isPrimary = curGPoint.isPrimary;
            }
            updateGPoint.lastPos = updateGPoint.currentPos;
            updateGPoint.lastTime = updateGPoint.currentTime;
            updateGPoint.currentPos = curGPoint.currentPos;
            updateGPoint.currentTime = curGPoint.currentTime;
          } else {
            curGPoint.captured = false;
            curGPoint.insideElementPressed = false;
            curGPoint.insideElement = true;
            startTrackingPointer(pointsList, curGPoint);
          }
        }
        if (tracker.stopHandler && gPoints[0].type === "mouse") {
          clearTimeout(tracker.stopTimeOut);
          tracker.stopTimeOut = setTimeout(function() {
            handlePointerStop(tracker, event, gPoints[0].type);
          }, tracker.stopDelay);
        }
        if (pointsList.contacts === 0) {
          if (tracker.moveHandler) {
            propagate = tracker.moveHandler(
              {
                eventSource: tracker,
                pointerType: gPoints[0].type,
                position: getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                buttons: pointsList.buttons,
                isTouchEvent: gPoints[0].type === "touch",
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $2.cancelEvent(event);
            }
          }
        } else if (pointsList.contacts === 1) {
          if (tracker.moveHandler) {
            updateGPoint = pointsList.asArray()[0];
            propagate = tracker.moveHandler(
              {
                eventSource: tracker,
                pointerType: updateGPoint.type,
                position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                buttons: pointsList.buttons,
                isTouchEvent: updateGPoint.type === "touch",
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $2.cancelEvent(event);
            }
          }
          if (tracker.dragHandler) {
            updateGPoint = pointsList.asArray()[0];
            delta = updateGPoint.currentPos.minus(updateGPoint.lastPos);
            propagate = tracker.dragHandler(
              {
                eventSource: tracker,
                pointerType: updateGPoint.type,
                position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                buttons: pointsList.buttons,
                delta,
                speed: updateGPoint.speed,
                direction: updateGPoint.direction,
                shift: event.shiftKey,
                isTouchEvent: updateGPoint.type === "touch",
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $2.cancelEvent(event);
            }
          }
        } else if (pointsList.contacts === 2) {
          if (tracker.moveHandler) {
            gPointArray = pointsList.asArray();
            propagate = tracker.moveHandler(
              {
                eventSource: tracker,
                pointerType: gPointArray[0].type,
                position: getPointRelativeToAbsolute(getCenterPoint(gPointArray[0].currentPos, gPointArray[1].currentPos), tracker.element),
                buttons: pointsList.buttons,
                isTouchEvent: gPointArray[0].type === "touch",
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $2.cancelEvent(event);
            }
          }
          if (tracker.pinchHandler && gPoints[0].type === "touch") {
            delta = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
            if (delta != delegate.currentPinchDist) {
              delegate.lastPinchDist = delegate.currentPinchDist;
              delegate.currentPinchDist = delta;
              delegate.lastPinchCenter = delegate.currentPinchCenter;
              delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
              propagate = tracker.pinchHandler(
                {
                  eventSource: tracker,
                  pointerType: "touch",
                  gesturePoints: delegate.pinchGPoints,
                  lastCenter: getPointRelativeToAbsolute(delegate.lastPinchCenter, tracker.element),
                  center: getPointRelativeToAbsolute(delegate.currentPinchCenter, tracker.element),
                  lastDistance: delegate.lastPinchDist,
                  distance: delegate.currentPinchDist,
                  shift: event.shiftKey,
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $2.cancelEvent(event);
              }
            }
          }
        }
      }
      function updatePointersCancel(tracker, event, gPoints) {
        updatePointersUp(tracker, event, gPoints, 0);
        updatePointersExit(tracker, event, gPoints);
      }
      function handlePointerStop(tracker, originalMoveEvent, pointerType) {
        if (tracker.stopHandler) {
          tracker.stopHandler({
            eventSource: tracker,
            pointerType,
            position: getMouseRelative(originalMoveEvent, tracker.element),
            buttons: tracker.getActivePointersListByType(pointerType).buttons,
            isTouchEvent: pointerType === "touch",
            originalEvent: originalMoveEvent,
            preventDefaultAction: false,
            userData: tracker.userData
          });
        }
      }
      var isInIframe = function() {
        try {
          return window.self !== window.top;
        } catch (e) {
          return true;
        }
      }();
      function canAccessEvents(target) {
        try {
          return target.addEventListener && target.removeEventListener;
        } catch (e) {
          return false;
        }
      }
    })(OpenSeadragon);
    (function($2) {
      $2.ControlAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_RIGHT: 2,
        BOTTOM_RIGHT: 3,
        BOTTOM_LEFT: 4,
        ABSOLUTE: 5
      };
      $2.Control = function(element, options, container) {
        var parent = element.parentNode;
        if (typeof options === "number") {
          $2.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; please use an options object instead.  Support for this deprecated variant is scheduled for removal in December 2013");
          options = { anchor: options };
        }
        options.attachToViewer = typeof options.attachToViewer === "undefined" ? true : options.attachToViewer;
        this.autoFade = typeof options.autoFade === "undefined" ? true : options.autoFade;
        this.element = element;
        this.anchor = options.anchor;
        this.container = container;
        if (this.anchor == $2.ControlAnchor.ABSOLUTE) {
          this.wrapper = $2.makeNeutralElement("div");
          this.wrapper.style.position = "absolute";
          this.wrapper.style.top = typeof options.top == "number" ? options.top + "px" : options.top;
          this.wrapper.style.left = typeof options.left == "number" ? options.left + "px" : options.left;
          this.wrapper.style.height = typeof options.height == "number" ? options.height + "px" : options.height;
          this.wrapper.style.width = typeof options.width == "number" ? options.width + "px" : options.width;
          this.wrapper.style.margin = "0px";
          this.wrapper.style.padding = "0px";
          this.element.style.position = "relative";
          this.element.style.top = "0px";
          this.element.style.left = "0px";
          this.element.style.height = "100%";
          this.element.style.width = "100%";
        } else {
          this.wrapper = $2.makeNeutralElement("div");
          this.wrapper.style.display = "inline-block";
          if (this.anchor == $2.ControlAnchor.NONE) {
            this.wrapper.style.width = this.wrapper.style.height = "100%";
          }
        }
        this.wrapper.appendChild(this.element);
        if (options.attachToViewer) {
          if (this.anchor == $2.ControlAnchor.TOP_RIGHT || this.anchor == $2.ControlAnchor.BOTTOM_RIGHT) {
            this.container.insertBefore(
              this.wrapper,
              this.container.firstChild
            );
          } else {
            this.container.appendChild(this.wrapper);
          }
        } else {
          parent.appendChild(this.wrapper);
        }
      };
      $2.Control.prototype = {
        /**
         * Removes the control from the container.
         * @function
         */
        destroy: function() {
          this.wrapper.removeChild(this.element);
          this.container.removeChild(this.wrapper);
        },
        /**
         * Determines if the control is currently visible.
         * @function
         * @return {Boolean} true if currently visible, false otherwise.
         */
        isVisible: function() {
          return this.wrapper.style.display != "none";
        },
        /**
         * Toggles the visibility of the control.
         * @function
         * @param {Boolean} visible - true to make visible, false to hide.
         */
        setVisible: function(visible) {
          this.wrapper.style.display = visible ? this.anchor == $2.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
        },
        /**
         * Sets the opacity level for the control.
         * @function
         * @param {Number} opactiy - a value between 1 and 0 inclusively.
         */
        setOpacity: function(opacity) {
          if (this.element[$2.SIGNAL] && $2.Browser.vendor == $2.BROWSERS.IE) {
            $2.setElementOpacity(this.element, opacity, true);
          } else {
            $2.setElementOpacity(this.wrapper, opacity, true);
          }
        }
      };
    })(OpenSeadragon);
    (function($2) {
      $2.ControlDock = function(options) {
        var layouts = ["topleft", "topright", "bottomright", "bottomleft"], layout, i;
        $2.extend(true, this, {
          id: "controldock-" + $2.now() + "-" + Math.floor(Math.random() * 1e6),
          container: $2.makeNeutralElement("div"),
          controls: []
        }, options);
        this.container.onsubmit = function() {
          return false;
        };
        if (this.element) {
          this.element = $2.getElement(this.element);
          this.element.appendChild(this.container);
          this.element.style.position = "relative";
          this.container.style.width = "100%";
          this.container.style.height = "100%";
        }
        for (i = 0; i < layouts.length; i++) {
          layout = layouts[i];
          this.controls[layout] = $2.makeNeutralElement("div");
          this.controls[layout].style.position = "absolute";
          if (layout.match("left")) {
            this.controls[layout].style.left = "0px";
          }
          if (layout.match("right")) {
            this.controls[layout].style.right = "0px";
          }
          if (layout.match("top")) {
            this.controls[layout].style.top = "0px";
          }
          if (layout.match("bottom")) {
            this.controls[layout].style.bottom = "0px";
          }
        }
        this.container.appendChild(this.controls.topleft);
        this.container.appendChild(this.controls.topright);
        this.container.appendChild(this.controls.bottomright);
        this.container.appendChild(this.controls.bottomleft);
      };
      $2.ControlDock.prototype = {
        /**
         * @function
         */
        addControl: function(element, controlOptions) {
          element = $2.getElement(element);
          var div = null;
          if (getControlIndex(this, element) >= 0) {
            return;
          }
          switch (controlOptions.anchor) {
            case $2.ControlAnchor.TOP_RIGHT:
              div = this.controls.topright;
              element.style.position = "relative";
              element.style.paddingRight = "0px";
              element.style.paddingTop = "0px";
              break;
            case $2.ControlAnchor.BOTTOM_RIGHT:
              div = this.controls.bottomright;
              element.style.position = "relative";
              element.style.paddingRight = "0px";
              element.style.paddingBottom = "0px";
              break;
            case $2.ControlAnchor.BOTTOM_LEFT:
              div = this.controls.bottomleft;
              element.style.position = "relative";
              element.style.paddingLeft = "0px";
              element.style.paddingBottom = "0px";
              break;
            case $2.ControlAnchor.TOP_LEFT:
              div = this.controls.topleft;
              element.style.position = "relative";
              element.style.paddingLeft = "0px";
              element.style.paddingTop = "0px";
              break;
            case $2.ControlAnchor.ABSOLUTE:
              div = this.container;
              element.style.margin = "0px";
              element.style.padding = "0px";
              break;
            default:
            case $2.ControlAnchor.NONE:
              div = this.container;
              element.style.margin = "0px";
              element.style.padding = "0px";
              break;
          }
          this.controls.push(
            new $2.Control(element, controlOptions, div)
          );
          element.style.display = "inline-block";
        },
        /**
         * @function
         * @return {OpenSeadragon.ControlDock} Chainable.
         */
        removeControl: function(element) {
          element = $2.getElement(element);
          var i = getControlIndex(this, element);
          if (i >= 0) {
            this.controls[i].destroy();
            this.controls.splice(i, 1);
          }
          return this;
        },
        /**
         * @function
         * @return {OpenSeadragon.ControlDock} Chainable.
         */
        clearControls: function() {
          while (this.controls.length > 0) {
            this.controls.pop().destroy();
          }
          return this;
        },
        /**
         * @function
         * @return {Boolean}
         */
        areControlsEnabled: function() {
          var i;
          for (i = this.controls.length - 1; i >= 0; i--) {
            if (this.controls[i].isVisible()) {
              return true;
            }
          }
          return false;
        },
        /**
         * @function
         * @return {OpenSeadragon.ControlDock} Chainable.
         */
        setControlsEnabled: function(enabled) {
          var i;
          for (i = this.controls.length - 1; i >= 0; i--) {
            this.controls[i].setVisible(enabled);
          }
          return this;
        }
      };
      function getControlIndex(dock, element) {
        var controls = dock.controls, i;
        for (i = controls.length - 1; i >= 0; i--) {
          if (controls[i].element == element) {
            return i;
          }
        }
        return -1;
      }
    })(OpenSeadragon);
    (function($2) {
      $2.Placement = $2.freezeObject({
        CENTER: 0,
        TOP_LEFT: 1,
        TOP: 2,
        TOP_RIGHT: 3,
        RIGHT: 4,
        BOTTOM_RIGHT: 5,
        BOTTOM: 6,
        BOTTOM_LEFT: 7,
        LEFT: 8,
        properties: {
          0: {
            isLeft: false,
            isHorizontallyCentered: true,
            isRight: false,
            isTop: false,
            isVerticallyCentered: true,
            isBottom: false
          },
          1: {
            isLeft: true,
            isHorizontallyCentered: false,
            isRight: false,
            isTop: true,
            isVerticallyCentered: false,
            isBottom: false
          },
          2: {
            isLeft: false,
            isHorizontallyCentered: true,
            isRight: false,
            isTop: true,
            isVerticallyCentered: false,
            isBottom: false
          },
          3: {
            isLeft: false,
            isHorizontallyCentered: false,
            isRight: true,
            isTop: true,
            isVerticallyCentered: false,
            isBottom: false
          },
          4: {
            isLeft: false,
            isHorizontallyCentered: false,
            isRight: true,
            isTop: false,
            isVerticallyCentered: true,
            isBottom: false
          },
          5: {
            isLeft: false,
            isHorizontallyCentered: false,
            isRight: true,
            isTop: false,
            isVerticallyCentered: false,
            isBottom: true
          },
          6: {
            isLeft: false,
            isHorizontallyCentered: true,
            isRight: false,
            isTop: false,
            isVerticallyCentered: false,
            isBottom: true
          },
          7: {
            isLeft: true,
            isHorizontallyCentered: false,
            isRight: false,
            isTop: false,
            isVerticallyCentered: false,
            isBottom: true
          },
          8: {
            isLeft: true,
            isHorizontallyCentered: false,
            isRight: false,
            isTop: false,
            isVerticallyCentered: true,
            isBottom: false
          }
        }
      });
    })(OpenSeadragon);
    (function($2) {
      var THIS = {};
      var nextHash = 1;
      $2.Viewer = function(options) {
        var args = arguments, _this = this, i;
        if (!$2.isPlainObject(options)) {
          options = {
            id: args[0],
            xmlPath: args.length > 1 ? args[1] : void 0,
            prefixUrl: args.length > 2 ? args[2] : void 0,
            controls: args.length > 3 ? args[3] : void 0,
            overlays: args.length > 4 ? args[4] : void 0
          };
        }
        if (options.config) {
          $2.extend(true, options, options.config);
          delete options.config;
        }
        $2.extend(true, this, {
          //internal state and dom identifiers
          id: options.id,
          hash: options.hash || nextHash++,
          /**
           * Index for page to be shown first next time open() is called (only used in sequenceMode).
           * @member {Number} initialPage
           * @memberof OpenSeadragon.Viewer#
           */
          initialPage: 0,
          //dom nodes
          /**
           * The parent element of this Viewer instance, passed in when the Viewer was created.
           * @member {Element} element
           * @memberof OpenSeadragon.Viewer#
           */
          element: null,
          /**
           * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#element}.
           * @member {Element} container
           * @memberof OpenSeadragon.Viewer#
           */
          container: null,
          /**
           * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#container},
           * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>
           * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
           * @member {Element} canvas
           * @memberof OpenSeadragon.Viewer#
           */
          canvas: null,
          // Overlays list. An overlay allows to add html on top of the viewer.
          overlays: [],
          // Container inside the canvas where overlays are drawn.
          overlaysContainer: null,
          //private state properties
          previousBody: [],
          //This was originally initialized in the constructor and so could never
          //have anything in it.  now it can because we allow it to be specified
          //in the options and is only empty by default if not specified. Also
          //this array was returned from get_controls which I find confusing
          //since this object has a controls property which is treated in other
          //functions like clearControls.  I'm removing the accessors.
          customControls: [],
          //These are originally not part options but declared as members
          //in initialize.  It's still considered idiomatic to put them here
          //source is here for backwards compatibility. It is not an official
          //part of the API and should not be relied upon.
          source: null,
          /**
           * Handles rendering of tiles in the viewer. Created for each TileSource opened.
           * @member {OpenSeadragon.Drawer} drawer
           * @memberof OpenSeadragon.Viewer#
           */
          drawer: null,
          /**
           * Keeps track of all of the tiled images in the scene.
           * @member {OpenSeadragon.World} world
           * @memberof OpenSeadragon.Viewer#
           */
          world: null,
          /**
           * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
           * @member {OpenSeadragon.Viewport} viewport
           * @memberof OpenSeadragon.Viewer#
           */
          viewport: null,
          /**
           * @member {OpenSeadragon.Navigator} navigator
           * @memberof OpenSeadragon.Viewer#
           */
          navigator: null,
          //A collection viewport is a separate viewport used to provide
          //simultaneous rendering of sets of tiles
          collectionViewport: null,
          collectionDrawer: null,
          //UI image resources
          //TODO: rename navImages to uiImages
          navImages: null,
          //interface button controls
          buttons: null,
          //TODO: this is defunct so safely remove it
          profiler: null
        }, $2.DEFAULT_SETTINGS, options);
        if (typeof this.hash === "undefined") {
          throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
        }
        if (typeof THIS[this.hash] !== "undefined") {
          $2.console.warn("Hash " + this.hash + " has already been used.");
        }
        THIS[this.hash] = {
          "fsBoundsDelta": new $2.Point(1, 1),
          "prevContainerSize": null,
          "animating": false,
          "forceRedraw": false,
          "mouseInside": false,
          "group": null,
          // whether we should be continuously zooming
          "zooming": false,
          // how much we should be continuously zooming by
          "zoomFactor": null,
          "lastZoomTime": null,
          "fullPage": false,
          "onfullscreenchange": null
        };
        this._sequenceIndex = 0;
        this._firstOpen = true;
        this._updateRequestId = null;
        this._loadQueue = [];
        this.currentOverlays = [];
        this._lastScrollTime = $2.now();
        $2.EventSource.call(this);
        this.addHandler("open-failed", function(event) {
          var msg = $2.getString("Errors.OpenFailed", event.eventSource, event.message);
          _this._showMessage(msg);
        });
        $2.ControlDock.call(this, options);
        if (this.xmlPath) {
          this.tileSources = [this.xmlPath];
        }
        this.element = this.element || document.getElementById(this.id);
        this.canvas = $2.makeNeutralElement("div");
        this.canvas.className = "openseadragon-canvas";
        (function(style) {
          style.width = "100%";
          style.height = "100%";
          style.overflow = "hidden";
          style.position = "absolute";
          style.top = "0px";
          style.left = "0px";
        })(this.canvas.style);
        $2.setElementTouchActionNone(this.canvas);
        if (options.tabIndex !== "") {
          this.canvas.tabIndex = options.tabIndex === void 0 ? 0 : options.tabIndex;
        }
        this.container.className = "openseadragon-container";
        (function(style) {
          style.width = "100%";
          style.height = "100%";
          style.position = "relative";
          style.overflow = "hidden";
          style.left = "0px";
          style.top = "0px";
          style.textAlign = "left";
        })(this.container.style);
        this.container.insertBefore(this.canvas, this.container.firstChild);
        this.element.appendChild(this.container);
        this.bodyWidth = document.body.style.width;
        this.bodyHeight = document.body.style.height;
        this.bodyOverflow = document.body.style.overflow;
        this.docOverflow = document.documentElement.style.overflow;
        this.innerTracker = new $2.MouseTracker({
          element: this.canvas,
          startDisabled: !this.mouseNavEnabled,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          keyDownHandler: $2.delegate(this, onCanvasKeyDown),
          keyHandler: $2.delegate(this, onCanvasKeyPress),
          clickHandler: $2.delegate(this, onCanvasClick),
          dblClickHandler: $2.delegate(this, onCanvasDblClick),
          dragHandler: $2.delegate(this, onCanvasDrag),
          dragEndHandler: $2.delegate(this, onCanvasDragEnd),
          enterHandler: $2.delegate(this, onCanvasEnter),
          exitHandler: $2.delegate(this, onCanvasExit),
          pressHandler: $2.delegate(this, onCanvasPress),
          releaseHandler: $2.delegate(this, onCanvasRelease),
          nonPrimaryPressHandler: $2.delegate(this, onCanvasNonPrimaryPress),
          nonPrimaryReleaseHandler: $2.delegate(this, onCanvasNonPrimaryRelease),
          scrollHandler: $2.delegate(this, onCanvasScroll),
          pinchHandler: $2.delegate(this, onCanvasPinch)
        });
        this.outerTracker = new $2.MouseTracker({
          element: this.container,
          startDisabled: !this.mouseNavEnabled,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          enterHandler: $2.delegate(this, onContainerEnter),
          exitHandler: $2.delegate(this, onContainerExit)
        });
        if (this.toolbar) {
          this.toolbar = new $2.ControlDock({ element: this.toolbar });
        }
        this.bindStandardControls();
        THIS[this.hash].prevContainerSize = _getSafeElemSize(this.container);
        this.world = new $2.World({
          viewer: this
        });
        this.world.addHandler("add-item", function(event) {
          _this.source = _this.world.getItemAt(0).source;
          THIS[_this.hash].forceRedraw = true;
          if (!_this._updateRequestId) {
            _this._updateRequestId = scheduleUpdate(_this, updateMulti);
          }
        });
        this.world.addHandler("remove-item", function(event) {
          if (_this.world.getItemCount()) {
            _this.source = _this.world.getItemAt(0).source;
          } else {
            _this.source = null;
          }
          THIS[_this.hash].forceRedraw = true;
        });
        this.world.addHandler("metrics-change", function(event) {
          if (_this.viewport) {
            _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());
          }
        });
        this.world.addHandler("item-index-change", function(event) {
          _this.source = _this.world.getItemAt(0).source;
        });
        this.viewport = new $2.Viewport({
          containerSize: THIS[this.hash].prevContainerSize,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime,
          minZoomImageRatio: this.minZoomImageRatio,
          maxZoomPixelRatio: this.maxZoomPixelRatio,
          visibilityRatio: this.visibilityRatio,
          wrapHorizontal: this.wrapHorizontal,
          wrapVertical: this.wrapVertical,
          defaultZoomLevel: this.defaultZoomLevel,
          minZoomLevel: this.minZoomLevel,
          maxZoomLevel: this.maxZoomLevel,
          viewer: this,
          degrees: this.degrees,
          flipped: this.flipped,
          navigatorRotate: this.navigatorRotate,
          homeFillsViewer: this.homeFillsViewer,
          margins: this.viewportMargins
        });
        this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());
        this.imageLoader = new $2.ImageLoader({
          jobLimit: this.imageLoaderLimit,
          timeout: options.timeout
        });
        this.tileCache = new $2.TileCache({
          maxImageCacheCount: this.maxImageCacheCount
        });
        this.drawer = new $2.Drawer({
          viewer: this,
          viewport: this.viewport,
          element: this.canvas,
          debugGridColor: this.debugGridColor
        });
        this.overlaysContainer = $2.makeNeutralElement("div");
        this.canvas.appendChild(this.overlaysContainer);
        if (!this.drawer.canRotate()) {
          if (this.rotateLeft) {
            i = this.buttons.buttons.indexOf(this.rotateLeft);
            this.buttons.buttons.splice(i, 1);
            this.buttons.element.removeChild(this.rotateLeft.element);
          }
          if (this.rotateRight) {
            i = this.buttons.buttons.indexOf(this.rotateRight);
            this.buttons.buttons.splice(i, 1);
            this.buttons.element.removeChild(this.rotateRight.element);
          }
        }
        if (this.showNavigator) {
          this.navigator = new $2.Navigator({
            id: this.navigatorId,
            position: this.navigatorPosition,
            sizeRatio: this.navigatorSizeRatio,
            maintainSizeRatio: this.navigatorMaintainSizeRatio,
            top: this.navigatorTop,
            left: this.navigatorLeft,
            width: this.navigatorWidth,
            height: this.navigatorHeight,
            autoResize: this.navigatorAutoResize,
            autoFade: this.navigatorAutoFade,
            prefixUrl: this.prefixUrl,
            viewer: this,
            navigatorRotate: this.navigatorRotate,
            background: this.navigatorBackground,
            opacity: this.navigatorOpacity,
            borderColor: this.navigatorBorderColor,
            displayRegionColor: this.navigatorDisplayRegionColor,
            crossOriginPolicy: this.crossOriginPolicy
          });
        }
        if (this.sequenceMode) {
          this.bindSequenceControls();
        }
        if (this.tileSources) {
          this.open(this.tileSources);
        }
        for (i = 0; i < this.customControls.length; i++) {
          this.addControl(
            this.customControls[i].id,
            { anchor: this.customControls[i].anchor }
          );
        }
        $2.requestAnimationFrame(function() {
          beginControlsAutoHide(_this);
        });
        if (this.imageSmoothingEnabled !== void 0 && !this.imageSmoothingEnabled) {
          this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled);
        }
      };
      $2.extend(
        $2.Viewer.prototype,
        $2.EventSource.prototype,
        $2.ControlDock.prototype,
        /** @lends OpenSeadragon.Viewer.prototype */
        {
          /**
           * @function
           * @return {Boolean}
           */
          isOpen: function() {
            return !!this.world.getItemCount();
          },
          // deprecated
          openDzi: function(dzi) {
            $2.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead.");
            return this.open(dzi);
          },
          // deprecated
          openTileSource: function(tileSource) {
            $2.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead.");
            return this.open(tileSource);
          },
          /**
           * Open tiled images into the viewer, closing any others.
           * To get the TiledImage instance created by open, add an event listener for
           * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
           * to the instance, i.e., viewer.world.getItemAt(0).
           * @function
           * @param {Array|String|Object|Function} tileSources - This can be a TiledImage
           * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
           * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
           * except for the index property; images are added in sequence.
           * A TileSource specifier is anything you could pass as the tileSource property
           * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
           * @param {Number} initialPage - If sequenceMode is true, display this page initially
           * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:open
           * @fires OpenSeadragon.Viewer.event:open-failed
           */
          open: function(tileSources, initialPage) {
            var _this = this;
            this.close();
            if (!tileSources) {
              return;
            }
            if (this.sequenceMode && $2.isArray(tileSources)) {
              if (this.referenceStrip) {
                this.referenceStrip.destroy();
                this.referenceStrip = null;
              }
              if (typeof initialPage != "undefined" && !isNaN(initialPage)) {
                this.initialPage = initialPage;
              }
              this.tileSources = tileSources;
              this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
              if (this.tileSources.length) {
                this.open(this.tileSources[this._sequenceIndex]);
                if (this.showReferenceStrip) {
                  this.addReferenceStrip();
                }
              }
              this._updateSequenceButtons(this._sequenceIndex);
              return;
            }
            if (!$2.isArray(tileSources)) {
              tileSources = [tileSources];
            }
            if (!tileSources.length) {
              return;
            }
            this._opening = true;
            var expected = tileSources.length;
            var successes = 0;
            var failures = 0;
            var failEvent;
            var checkCompletion = function() {
              if (successes + failures === expected) {
                if (successes) {
                  if (_this._firstOpen || !_this.preserveViewport) {
                    _this.viewport.goHome(true);
                    _this.viewport.update();
                  }
                  _this._firstOpen = false;
                  var source = tileSources[0];
                  if (source.tileSource) {
                    source = source.tileSource;
                  }
                  if (_this.overlays && !_this.preserveOverlays) {
                    for (var i2 = 0; i2 < _this.overlays.length; i2++) {
                      _this.currentOverlays[i2] = getOverlayObject(_this, _this.overlays[i2]);
                    }
                  }
                  _this._drawOverlays();
                  _this._opening = false;
                  _this.raiseEvent("open", { source });
                } else {
                  _this._opening = false;
                  _this.raiseEvent("open-failed", failEvent);
                }
              }
            };
            var doOne = function(options) {
              if (!$2.isPlainObject(options) || !options.tileSource) {
                options = {
                  tileSource: options
                };
              }
              if (options.index !== void 0) {
                $2.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead");
                delete options.index;
              }
              if (options.collectionImmediately === void 0) {
                options.collectionImmediately = true;
              }
              var originalSuccess = options.success;
              options.success = function(event) {
                successes++;
                if (options.tileSource.overlays) {
                  for (var i2 = 0; i2 < options.tileSource.overlays.length; i2++) {
                    _this.addOverlay(options.tileSource.overlays[i2]);
                  }
                }
                if (originalSuccess) {
                  originalSuccess(event);
                }
                checkCompletion();
              };
              var originalError = options.error;
              options.error = function(event) {
                failures++;
                if (!failEvent) {
                  failEvent = event;
                }
                if (originalError) {
                  originalError(event);
                }
                checkCompletion();
              };
              _this.addTiledImage(options);
            };
            for (var i = 0; i < tileSources.length; i++) {
              doOne(tileSources[i]);
            }
            return this;
          },
          /**
           * @function
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:close
           */
          close: function() {
            if (!THIS[this.hash]) {
              return this;
            }
            this._opening = false;
            if (this.navigator) {
              this.navigator.close();
            }
            if (!this.preserveOverlays) {
              this.clearOverlays();
              this.overlaysContainer.innerHTML = "";
            }
            THIS[this.hash].animating = false;
            this.world.removeAll();
            this.imageLoader.clear();
            this.raiseEvent("close");
            return this;
          },
          /**
           * Function to destroy the viewer and clean up everything created by OpenSeadragon.
           *
           * Example:
           * var viewer = OpenSeadragon({
           *   [...]
           * });
           *
           * //when you are done with the viewer:
           * viewer.destroy();
           * viewer = null; //important
           *
           * @function
           */
          destroy: function() {
            if (!THIS[this.hash]) {
              return;
            }
            this.close();
            this.clearOverlays();
            this.overlaysContainer.innerHTML = "";
            if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
            }
            if (this._updateRequestId !== null) {
              $2.cancelAnimationFrame(this._updateRequestId);
              this._updateRequestId = null;
            }
            if (this.drawer) {
              this.drawer.destroy();
            }
            this.removeAllHandlers();
            if (this.element) {
              while (this.element.firstChild) {
                this.element.removeChild(this.element.firstChild);
              }
            }
            if (this.innerTracker) {
              this.innerTracker.destroy();
            }
            if (this.outerTracker) {
              this.outerTracker.destroy();
            }
            THIS[this.hash] = null;
            delete THIS[this.hash];
            this.canvas = null;
            this.container = null;
            this.element = null;
          },
          /**
           * @function
           * @return {Boolean}
           */
          isMouseNavEnabled: function() {
            return this.innerTracker.isTracking();
          },
          /**
           * @function
           * @param {Boolean} enabled - true to enable, false to disable
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:mouse-enabled
           */
          setMouseNavEnabled: function(enabled) {
            this.innerTracker.setTracking(enabled);
            this.outerTracker.setTracking(enabled);
            this.raiseEvent("mouse-enabled", { enabled });
            return this;
          },
          /**
           * @function
           * @return {Boolean}
           */
          areControlsEnabled: function() {
            var enabled = this.controls.length, i;
            for (i = 0; i < this.controls.length; i++) {
              enabled = enabled && this.controls[i].isVisible();
            }
            return enabled;
          },
          /**
           * Shows or hides the controls (e.g. the default navigation buttons).
           *
           * @function
           * @param {Boolean} true to show, false to hide.
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:controls-enabled
           */
          setControlsEnabled: function(enabled) {
            if (enabled) {
              abortControlsAutoHide(this);
            } else {
              beginControlsAutoHide(this);
            }
            this.raiseEvent("controls-enabled", { enabled });
            return this;
          },
          /**
           * Turns debugging mode on or off for this viewer.
           *
           * @function
           * @param {Boolean} true to turn debug on, false to turn debug off.
           */
          setDebugMode: function(debugMode) {
            for (var i = 0; i < this.world.getItemCount(); i++) {
              this.world.getItemAt(i).debugMode = debugMode;
            }
            this.debugMode = debugMode;
            this.forceRedraw();
          },
          /**
           * @function
           * @return {Boolean}
           */
          isFullPage: function() {
            return THIS[this.hash].fullPage;
          },
          /**
           * Toggle full page mode.
           * @function
           * @param {Boolean} fullPage
           *      If true, enter full page mode.  If false, exit full page mode.
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:pre-full-page
           * @fires OpenSeadragon.Viewer.event:full-page
           */
          setFullPage: function(fullPage) {
            var body = document.body, bodyStyle = body.style, docStyle = document.documentElement.style, _this = this, nodes, i;
            if (fullPage == this.isFullPage()) {
              return this;
            }
            var fullPageEventArgs = {
              fullPage,
              preventDefaultAction: false
            };
            this.raiseEvent("pre-full-page", fullPageEventArgs);
            if (fullPageEventArgs.preventDefaultAction) {
              return this;
            }
            if (fullPage) {
              this.elementSize = $2.getElementSize(this.element);
              this.pageScroll = $2.getPageScroll();
              this.elementMargin = this.element.style.margin;
              this.element.style.margin = "0";
              this.elementPadding = this.element.style.padding;
              this.element.style.padding = "0";
              this.bodyMargin = bodyStyle.margin;
              this.docMargin = docStyle.margin;
              bodyStyle.margin = "0";
              docStyle.margin = "0";
              this.bodyPadding = bodyStyle.padding;
              this.docPadding = docStyle.padding;
              bodyStyle.padding = "0";
              docStyle.padding = "0";
              this.bodyWidth = bodyStyle.width;
              this.docWidth = docStyle.width;
              bodyStyle.width = "100%";
              docStyle.width = "100%";
              this.bodyHeight = bodyStyle.height;
              this.docHeight = docStyle.height;
              bodyStyle.height = "100%";
              docStyle.height = "100%";
              this.previousBody = [];
              THIS[this.hash].prevElementParent = this.element.parentNode;
              THIS[this.hash].prevNextSibling = this.element.nextSibling;
              THIS[this.hash].prevElementWidth = this.element.style.width;
              THIS[this.hash].prevElementHeight = this.element.style.height;
              nodes = body.childNodes.length;
              for (i = 0; i < nodes; i++) {
                this.previousBody.push(body.childNodes[0]);
                body.removeChild(body.childNodes[0]);
              }
              if (this.toolbar && this.toolbar.element) {
                this.toolbar.parentNode = this.toolbar.element.parentNode;
                this.toolbar.nextSibling = this.toolbar.element.nextSibling;
                body.appendChild(this.toolbar.element);
                $2.addClass(this.toolbar.element, "fullpage");
              }
              $2.addClass(this.element, "fullpage");
              body.appendChild(this.element);
              this.element.style.height = $2.getWindowSize().y + "px";
              this.element.style.width = $2.getWindowSize().x + "px";
              if (this.toolbar && this.toolbar.element) {
                this.element.style.height = $2.getElementSize(this.element).y - $2.getElementSize(this.toolbar.element).y + "px";
              }
              THIS[this.hash].fullPage = true;
              $2.delegate(this, onContainerEnter)({});
            } else {
              this.element.style.margin = this.elementMargin;
              this.element.style.padding = this.elementPadding;
              bodyStyle.margin = this.bodyMargin;
              docStyle.margin = this.docMargin;
              bodyStyle.padding = this.bodyPadding;
              docStyle.padding = this.docPadding;
              bodyStyle.width = this.bodyWidth;
              docStyle.width = this.docWidth;
              bodyStyle.height = this.bodyHeight;
              docStyle.height = this.docHeight;
              body.removeChild(this.element);
              nodes = this.previousBody.length;
              for (i = 0; i < nodes; i++) {
                body.appendChild(this.previousBody.shift());
              }
              $2.removeClass(this.element, "fullpage");
              THIS[this.hash].prevElementParent.insertBefore(
                this.element,
                THIS[this.hash].prevNextSibling
              );
              if (this.toolbar && this.toolbar.element) {
                body.removeChild(this.toolbar.element);
                $2.removeClass(this.toolbar.element, "fullpage");
                this.toolbar.parentNode.insertBefore(
                  this.toolbar.element,
                  this.toolbar.nextSibling
                );
                delete this.toolbar.parentNode;
                delete this.toolbar.nextSibling;
              }
              this.element.style.width = THIS[this.hash].prevElementWidth;
              this.element.style.height = THIS[this.hash].prevElementHeight;
              var restoreScrollCounter = 0;
              var restoreScroll = function() {
                $2.setPageScroll(_this.pageScroll);
                var pageScroll = $2.getPageScroll();
                restoreScrollCounter++;
                if (restoreScrollCounter < 10 && (pageScroll.x !== _this.pageScroll.x || pageScroll.y !== _this.pageScroll.y)) {
                  $2.requestAnimationFrame(restoreScroll);
                }
              };
              $2.requestAnimationFrame(restoreScroll);
              THIS[this.hash].fullPage = false;
              $2.delegate(this, onContainerExit)({});
            }
            if (this.navigator && this.viewport) {
              this.navigator.update(this.viewport);
            }
            this.raiseEvent("full-page", { fullPage });
            return this;
          },
          /**
           * Toggle full screen mode if supported. Toggle full page mode otherwise.
           * @function
           * @param {Boolean} fullScreen
           *      If true, enter full screen mode.  If false, exit full screen mode.
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:pre-full-screen
           * @fires OpenSeadragon.Viewer.event:full-screen
           */
          setFullScreen: function(fullScreen) {
            var _this = this;
            if (!$2.supportsFullScreen) {
              return this.setFullPage(fullScreen);
            }
            if ($2.isFullScreen() === fullScreen) {
              return this;
            }
            var fullScreeEventArgs = {
              fullScreen,
              preventDefaultAction: false
            };
            this.raiseEvent("pre-full-screen", fullScreeEventArgs);
            if (fullScreeEventArgs.preventDefaultAction) {
              return this;
            }
            if (fullScreen) {
              this.setFullPage(true);
              if (!this.isFullPage()) {
                return this;
              }
              this.fullPageStyleWidth = this.element.style.width;
              this.fullPageStyleHeight = this.element.style.height;
              this.element.style.width = "100%";
              this.element.style.height = "100%";
              var onFullScreenChange = function() {
                var isFullScreen = $2.isFullScreen();
                if (!isFullScreen) {
                  $2.removeEvent(document, $2.fullScreenEventName, onFullScreenChange);
                  $2.removeEvent(document, $2.fullScreenErrorEventName, onFullScreenChange);
                  _this.setFullPage(false);
                  if (_this.isFullPage()) {
                    _this.element.style.width = _this.fullPageStyleWidth;
                    _this.element.style.height = _this.fullPageStyleHeight;
                  }
                }
                if (_this.navigator && _this.viewport) {
                  setTimeout(function() {
                    _this.navigator.update(_this.viewport);
                  });
                }
                _this.raiseEvent("full-screen", { fullScreen: isFullScreen });
              };
              $2.addEvent(document, $2.fullScreenEventName, onFullScreenChange);
              $2.addEvent(document, $2.fullScreenErrorEventName, onFullScreenChange);
              $2.requestFullScreen(document.body);
            } else {
              $2.exitFullScreen();
            }
            return this;
          },
          /**
           * @function
           * @return {Boolean}
           */
          isVisible: function() {
            return this.container.style.visibility != "hidden";
          },
          /**
           * @function
           * @param {Boolean} visible
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:visible
           */
          setVisible: function(visible) {
            this.container.style.visibility = visible ? "" : "hidden";
            this.raiseEvent("visible", { visible });
            return this;
          },
          /**
           * Add a tiled image to the viewer.
           * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
           *  supports except arrays of images.
           * Note that you can specify options.width or options.height, but not both.
           * The other dimension will be calculated according to the item's aspect ratio.
           * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
           * automatically arranged with the others.
           * @function
           * @param {Object} options
           * @param {String|Object|Function} options.tileSource - The TileSource specifier.
           * A String implies a url used to determine the tileSource implementation
           *      based on the file extension of url. JSONP is implied by *.js,
           *      otherwise the url is retrieved as text and the resulting text is
           *      introspected to determine if its json, xml, or text and parsed.
           * An Object implies an inline configuration which has a single
           *      property sufficient for being able to determine tileSource
           *      implementation. If the object has a property which is a function
           *      named 'getTileUrl', it is treated as a custom TileSource.
           * @param {Number} [options.index] The index of the item. Added on top of
           * all other items if not specified.
           * @param {Boolean} [options.replace=false] If true, the item at options.index will be
           * removed and the new item is added in its place. options.tileSource will be
           * interpreted and fetched if necessary before the old item is removed to avoid leaving
           * a gap in the world.
           * @param {Number} [options.x=0] The X position for the image in viewport coordinates.
           * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.
           * @param {Number} [options.width=1] The width for the image in viewport coordinates.
           * @param {Number} [options.height] The height for the image in viewport coordinates.
           * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
           * to fit the image into. If specified, x, y, width and height get ignored.
           * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
           * How to anchor the image in the bounds if options.fitBounds is set.
           * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
           * (portions of the image outside of this area will not be visible). Only works on
           * browsers that support the HTML5 canvas.
           * @param {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
           * @param {Boolean} [options.preload=false]  Default switch for loading hidden images (true loads, false blocks)
           * @param {Number} [options.degrees=0] Initial rotation of the tiled image around
           * its top left corner in degrees.
           * @param {String} [options.compositeOperation] How the image is composited onto other images.
           * @param {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
           * overriding viewer.crossOriginPolicy.
           * @param {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
           * @param {Boolean} [options.loadTilesWithAjax]
           *      Whether to load tile data using AJAX requests.
           *      Defaults to the setting in {@link OpenSeadragon.Options}.
           * @param {Object} [options.ajaxHeaders]
           *      A set of headers to include when making tile AJAX requests.
           *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
           *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
           * requests.
           * @param {Function} [options.success] A function that gets called when the image is
           * successfully added. It's passed the event object which contains a single property:
           * "item", which is the resulting instance of TiledImage.
           * @param {Function} [options.error] A function that gets called if the image is
           * unable to be added. It's passed the error event object, which contains "message"
           * and "source" properties.
           * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,
           * specifies whether to snap to the new arrangement immediately or to animate to it.
           * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.Viewer.event:add-item-failed
           */
          addTiledImage: function(options) {
            $2.console.assert(options, "[Viewer.addTiledImage] options is required");
            $2.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
            $2.console.assert(
              !options.replace || options.index > -1 && options.index < this.world.getItemCount(),
              "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world"
            );
            var _this = this;
            if (options.replace) {
              options.replaceItem = _this.world.getItemAt(options.index);
            }
            this._hideMessage();
            if (options.placeholderFillStyle === void 0) {
              options.placeholderFillStyle = this.placeholderFillStyle;
            }
            if (options.opacity === void 0) {
              options.opacity = this.opacity;
            }
            if (options.preload === void 0) {
              options.preload = this.preload;
            }
            if (options.compositeOperation === void 0) {
              options.compositeOperation = this.compositeOperation;
            }
            if (options.crossOriginPolicy === void 0) {
              options.crossOriginPolicy = options.tileSource.crossOriginPolicy !== void 0 ? options.tileSource.crossOriginPolicy : this.crossOriginPolicy;
            }
            if (options.ajaxWithCredentials === void 0) {
              options.ajaxWithCredentials = this.ajaxWithCredentials;
            }
            if (options.loadTilesWithAjax === void 0) {
              options.loadTilesWithAjax = this.loadTilesWithAjax;
            }
            if (options.ajaxHeaders === void 0 || options.ajaxHeaders === null) {
              options.ajaxHeaders = this.ajaxHeaders;
            } else if ($2.isPlainObject(options.ajaxHeaders) && $2.isPlainObject(this.ajaxHeaders)) {
              options.ajaxHeaders = $2.extend({}, this.ajaxHeaders, options.ajaxHeaders);
            }
            var myQueueItem = {
              options
            };
            function raiseAddItemFailed(event) {
              for (var i = 0; i < _this._loadQueue.length; i++) {
                if (_this._loadQueue[i] === myQueueItem) {
                  _this._loadQueue.splice(i, 1);
                  break;
                }
              }
              if (_this._loadQueue.length === 0) {
                refreshWorld(myQueueItem);
              }
              _this.raiseEvent("add-item-failed", event);
              if (options.error) {
                options.error(event);
              }
            }
            function refreshWorld(theItem) {
              if (_this.collectionMode) {
                _this.world.arrange({
                  immediately: theItem.options.collectionImmediately,
                  rows: _this.collectionRows,
                  columns: _this.collectionColumns,
                  layout: _this.collectionLayout,
                  tileSize: _this.collectionTileSize,
                  tileMargin: _this.collectionTileMargin
                });
                _this.world.setAutoRefigureSizes(true);
              }
            }
            if ($2.isArray(options.tileSource)) {
              setTimeout(function() {
                raiseAddItemFailed({
                  message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                  source: options.tileSource,
                  options
                });
              });
              return;
            }
            this._loadQueue.push(myQueueItem);
            function processReadyItems() {
              var queueItem, tiledImage, optionsClone;
              while (_this._loadQueue.length) {
                queueItem = _this._loadQueue[0];
                if (!queueItem.tileSource) {
                  break;
                }
                _this._loadQueue.splice(0, 1);
                if (queueItem.options.replace) {
                  var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);
                  if (newIndex != -1) {
                    queueItem.options.index = newIndex;
                  }
                  _this.world.removeItem(queueItem.options.replaceItem);
                }
                tiledImage = new $2.TiledImage({
                  viewer: _this,
                  source: queueItem.tileSource,
                  viewport: _this.viewport,
                  drawer: _this.drawer,
                  tileCache: _this.tileCache,
                  imageLoader: _this.imageLoader,
                  x: queueItem.options.x,
                  y: queueItem.options.y,
                  width: queueItem.options.width,
                  height: queueItem.options.height,
                  fitBounds: queueItem.options.fitBounds,
                  fitBoundsPlacement: queueItem.options.fitBoundsPlacement,
                  clip: queueItem.options.clip,
                  placeholderFillStyle: queueItem.options.placeholderFillStyle,
                  opacity: queueItem.options.opacity,
                  preload: queueItem.options.preload,
                  degrees: queueItem.options.degrees,
                  compositeOperation: queueItem.options.compositeOperation,
                  springStiffness: _this.springStiffness,
                  animationTime: _this.animationTime,
                  minZoomImageRatio: _this.minZoomImageRatio,
                  wrapHorizontal: _this.wrapHorizontal,
                  wrapVertical: _this.wrapVertical,
                  immediateRender: _this.immediateRender,
                  blendTime: _this.blendTime,
                  alwaysBlend: _this.alwaysBlend,
                  minPixelRatio: _this.minPixelRatio,
                  smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,
                  iOSDevice: _this.iOSDevice,
                  crossOriginPolicy: queueItem.options.crossOriginPolicy,
                  ajaxWithCredentials: queueItem.options.ajaxWithCredentials,
                  loadTilesWithAjax: queueItem.options.loadTilesWithAjax,
                  ajaxHeaders: queueItem.options.ajaxHeaders,
                  debugMode: _this.debugMode
                });
                if (_this.collectionMode) {
                  _this.world.setAutoRefigureSizes(false);
                }
                _this.world.addItem(tiledImage, {
                  index: queueItem.options.index
                });
                if (_this._loadQueue.length === 0) {
                  refreshWorld(queueItem);
                }
                if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {
                  _this.viewport.goHome(true);
                }
                if (_this.navigator) {
                  optionsClone = $2.extend({}, queueItem.options, {
                    replace: false,
                    // navigator already removed the layer, nothing to replace
                    originalTiledImage: tiledImage,
                    tileSource: queueItem.tileSource
                  });
                  _this.navigator.addTiledImage(optionsClone);
                }
                if (queueItem.options.success) {
                  queueItem.options.success({
                    item: tiledImage
                  });
                }
              }
            }
            getTileSourceImplementation(this, options.tileSource, options, function(tileSource) {
              myQueueItem.tileSource = tileSource;
              processReadyItems();
            }, function(event) {
              event.options = options;
              raiseAddItemFailed(event);
              processReadyItems();
            });
          },
          /**
           * Add a simple image to the viewer.
           * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
           * except for options.tileSource which is replaced by options.url.
           * @function
           * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
           * for all the options
           * @param {String} options.url - The URL of the image to add.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.Viewer.event:add-item-failed
           */
          addSimpleImage: function(options) {
            $2.console.assert(options, "[Viewer.addSimpleImage] options is required");
            $2.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");
            var opts = $2.extend({}, options, {
              tileSource: {
                type: "image",
                url: options.url
              }
            });
            delete opts.url;
            this.addTiledImage(opts);
          },
          // deprecated
          addLayer: function(options) {
            var _this = this;
            $2.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
            var optionsClone = $2.extend({}, options, {
              success: function(event) {
                _this.raiseEvent("add-layer", {
                  options,
                  drawer: event.item
                });
              },
              error: function(event) {
                _this.raiseEvent("add-layer-failed", event);
              }
            });
            this.addTiledImage(optionsClone);
            return this;
          },
          // deprecated
          getLayerAtLevel: function(level) {
            $2.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead.");
            return this.world.getItemAt(level);
          },
          // deprecated
          getLevelOfLayer: function(drawer) {
            $2.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead.");
            return this.world.getIndexOfItem(drawer);
          },
          // deprecated
          getLayersCount: function() {
            $2.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead.");
            return this.world.getItemCount();
          },
          // deprecated
          setLayerLevel: function(drawer, level) {
            $2.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead.");
            return this.world.setItemIndex(drawer, level);
          },
          // deprecated
          removeLayer: function(drawer) {
            $2.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead.");
            return this.world.removeItem(drawer);
          },
          /**
           * Force the viewer to redraw its contents.
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          forceRedraw: function() {
            THIS[this.hash].forceRedraw = true;
            return this;
          },
          /**
           * @function
           * @return {OpenSeadragon.Viewer} Chainable.
           */
          bindSequenceControls: function() {
            var onFocusHandler = $2.delegate(this, onFocus), onBlurHandler = $2.delegate(this, onBlur), onNextHandler = $2.delegate(this, onNext), onPreviousHandler = $2.delegate(this, onPrevious), navImages = this.navImages, useGroup = true;
            if (this.showSequenceControl) {
              if (this.previousButton || this.nextButton) {
                useGroup = false;
              }
              this.previousButton = new $2.Button({
                element: this.previousButton ? $2.getElement(this.previousButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.PreviousPage"),
                srcRest: resolveUrl(this.prefixUrl, navImages.previous.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.previous.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.previous.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.previous.DOWN),
                onRelease: onPreviousHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              });
              this.nextButton = new $2.Button({
                element: this.nextButton ? $2.getElement(this.nextButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.NextPage"),
                srcRest: resolveUrl(this.prefixUrl, navImages.next.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.next.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.next.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.next.DOWN),
                onRelease: onNextHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              });
              if (!this.navPrevNextWrap) {
                this.previousButton.disable();
              }
              if (!this.tileSources || !this.tileSources.length) {
                this.nextButton.disable();
              }
              if (useGroup) {
                this.paging = new $2.ButtonGroup({
                  buttons: [
                    this.previousButton,
                    this.nextButton
                  ],
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold
                });
                this.pagingControl = this.paging.element;
                if (this.toolbar) {
                  this.toolbar.addControl(
                    this.pagingControl,
                    { anchor: $2.ControlAnchor.BOTTOM_RIGHT }
                  );
                } else {
                  this.addControl(
                    this.pagingControl,
                    { anchor: this.sequenceControlAnchor || $2.ControlAnchor.TOP_LEFT }
                  );
                }
              }
            }
            return this;
          },
          /**
           * @function
           * @return {OpenSeadragon.Viewer} Chainable.
           */
          bindStandardControls: function() {
            var beginZoomingInHandler = $2.delegate(this, beginZoomingIn), endZoomingHandler = $2.delegate(this, endZooming), doSingleZoomInHandler = $2.delegate(this, doSingleZoomIn), beginZoomingOutHandler = $2.delegate(this, beginZoomingOut), doSingleZoomOutHandler = $2.delegate(this, doSingleZoomOut), onHomeHandler = $2.delegate(this, onHome), onFullScreenHandler = $2.delegate(this, onFullScreen), onRotateLeftHandler = $2.delegate(this, onRotateLeft), onRotateRightHandler = $2.delegate(this, onRotateRight), onFlipHandler = $2.delegate(this, onFlip), onFocusHandler = $2.delegate(this, onFocus), onBlurHandler = $2.delegate(this, onBlur), navImages = this.navImages, buttons = [], useGroup = true;
            if (this.showNavigationControl) {
              if (this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) {
                useGroup = false;
              }
              if (this.showZoomControl) {
                buttons.push(this.zoomInButton = new $2.Button({
                  element: this.zoomInButton ? $2.getElement(this.zoomInButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $2.getString("Tooltips.ZoomIn"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.zoomIn.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.zoomIn.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.zoomIn.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.zoomIn.DOWN),
                  onPress: beginZoomingInHandler,
                  onRelease: endZoomingHandler,
                  onClick: doSingleZoomInHandler,
                  onEnter: beginZoomingInHandler,
                  onExit: endZoomingHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
                buttons.push(this.zoomOutButton = new $2.Button({
                  element: this.zoomOutButton ? $2.getElement(this.zoomOutButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $2.getString("Tooltips.ZoomOut"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.zoomOut.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.zoomOut.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.zoomOut.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.zoomOut.DOWN),
                  onPress: beginZoomingOutHandler,
                  onRelease: endZoomingHandler,
                  onClick: doSingleZoomOutHandler,
                  onEnter: beginZoomingOutHandler,
                  onExit: endZoomingHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showHomeControl) {
                buttons.push(this.homeButton = new $2.Button({
                  element: this.homeButton ? $2.getElement(this.homeButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $2.getString("Tooltips.Home"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.home.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.home.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.home.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.home.DOWN),
                  onRelease: onHomeHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showFullPageControl) {
                buttons.push(this.fullPageButton = new $2.Button({
                  element: this.fullPageButton ? $2.getElement(this.fullPageButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $2.getString("Tooltips.FullPage"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.fullpage.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.fullpage.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.fullpage.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.fullpage.DOWN),
                  onRelease: onFullScreenHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showRotationControl) {
                buttons.push(this.rotateLeftButton = new $2.Button({
                  element: this.rotateLeftButton ? $2.getElement(this.rotateLeftButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $2.getString("Tooltips.RotateLeft"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.rotateleft.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.rotateleft.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.rotateleft.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.rotateleft.DOWN),
                  onRelease: onRotateLeftHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
                buttons.push(this.rotateRightButton = new $2.Button({
                  element: this.rotateRightButton ? $2.getElement(this.rotateRightButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $2.getString("Tooltips.RotateRight"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.rotateright.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.rotateright.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.rotateright.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.rotateright.DOWN),
                  onRelease: onRotateRightHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showFlipControl) {
                buttons.push(this.flipButton = new $2.Button({
                  element: this.flipButton ? $2.getElement(this.flipButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $2.getString("Tooltips.Flip"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.flip.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.flip.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.flip.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.flip.DOWN),
                  onRelease: onFlipHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (useGroup) {
                this.buttons = new $2.ButtonGroup({
                  buttons,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold
                });
                this.navControl = this.buttons.element;
                this.addHandler("open", $2.delegate(this, lightUp));
                if (this.toolbar) {
                  this.toolbar.addControl(
                    this.navControl,
                    { anchor: this.navigationControlAnchor || $2.ControlAnchor.TOP_LEFT }
                  );
                } else {
                  this.addControl(
                    this.navControl,
                    { anchor: this.navigationControlAnchor || $2.ControlAnchor.TOP_LEFT }
                  );
                }
              }
            }
            return this;
          },
          /**
           * Gets the active page of a sequence
           * @function
           * @return {Number}
           */
          currentPage: function() {
            return this._sequenceIndex;
          },
          /**
           * @function
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:page
           */
          goToPage: function(page) {
            if (this.tileSources && page >= 0 && page < this.tileSources.length) {
              this._sequenceIndex = page;
              this._updateSequenceButtons(page);
              this.open(this.tileSources[page]);
              if (this.referenceStrip) {
                this.referenceStrip.setFocus(page);
              }
              this.raiseEvent("page", { page });
            }
            return this;
          },
          /**
            * Adds an html element as an overlay to the current viewport.  Useful for
            * highlighting words or areas of interest on an image or other zoomable
            * interface. The overlays added via this method are removed when the viewport
            * is closed which include when changing page.
            * @method
            * @param {Element|String|Object} element - A reference to an element or an id for
            *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
            *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
            *      all available options.
            * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
            *      rectangle which will be overlaid. This is a viewport relative location.
            * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
            *      viewport which the location coordinates will be treated as relative
            *      to.
            * @param {function} [onDraw] - If supplied the callback is called when the overlay
            *      needs to be drawn. It it the responsibility of the callback to do any drawing/positioning.
            *      It is passed position, size and element.
            * @return {OpenSeadragon.Viewer} Chainable.
            * @fires OpenSeadragon.Viewer.event:add-overlay
            */
          addOverlay: function(element, location, placement, onDraw) {
            var options;
            if ($2.isPlainObject(element)) {
              options = element;
            } else {
              options = {
                element,
                location,
                placement,
                onDraw
              };
            }
            element = $2.getElement(options.element);
            if (getOverlayIndex(this.currentOverlays, element) >= 0) {
              return this;
            }
            var overlay = getOverlayObject(this, options);
            this.currentOverlays.push(overlay);
            overlay.drawHTML(this.overlaysContainer, this.viewport);
            this.raiseEvent("add-overlay", {
              element,
              location: options.location,
              placement: options.placement
            });
            return this;
          },
          /**
           * Updates the overlay represented by the reference to the element or
           * element id moving it to the new location, relative to the new placement.
           * @method
           * @param {Element|String} element - A reference to an element or an id for
           *      the element which is overlaid.
           * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
           *      rectangle which will be overlaid. This is a viewport relative location.
           * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
           *      viewport which the location coordinates will be treated as relative
           *      to.
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:update-overlay
           */
          updateOverlay: function(element, location, placement) {
            var i;
            element = $2.getElement(element);
            i = getOverlayIndex(this.currentOverlays, element);
            if (i >= 0) {
              this.currentOverlays[i].update(location, placement);
              THIS[this.hash].forceRedraw = true;
              this.raiseEvent("update-overlay", {
                element,
                location,
                placement
              });
            }
            return this;
          },
          /**
           * Removes an overlay identified by the reference element or element id
           * and schedules an update.
           * @method
           * @param {Element|String} element - A reference to the element or an
           *      element id which represent the ovelay content to be removed.
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:remove-overlay
           */
          removeOverlay: function(element) {
            var i;
            element = $2.getElement(element);
            i = getOverlayIndex(this.currentOverlays, element);
            if (i >= 0) {
              this.currentOverlays[i].destroy();
              this.currentOverlays.splice(i, 1);
              THIS[this.hash].forceRedraw = true;
              this.raiseEvent("remove-overlay", {
                element
              });
            }
            return this;
          },
          /**
           * Removes all currently configured Overlays from this Viewer and schedules
           * an update.
           * @method
           * @return {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:clear-overlay
           */
          clearOverlays: function() {
            while (this.currentOverlays.length > 0) {
              this.currentOverlays.pop().destroy();
            }
            THIS[this.hash].forceRedraw = true;
            this.raiseEvent("clear-overlay", {});
            return this;
          },
          /**
          * Finds an overlay identified by the reference element or element id
          * and returns it as an object, return null if not found.
          * @method
          * @param {Element|String} element - A reference to the element or an
          *      element id which represents the overlay content.
          * @return {OpenSeadragon.Overlay} the matching overlay or null if none found.
          */
          getOverlayById: function(element) {
            var i;
            element = $2.getElement(element);
            i = getOverlayIndex(this.currentOverlays, element);
            if (i >= 0) {
              return this.currentOverlays[i];
            } else {
              return null;
            }
          },
          /**
           * Updates the sequence buttons.
           * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
           * @private
           * @param {Number} Sequence Value
           */
          _updateSequenceButtons: function(page) {
            if (this.nextButton) {
              if (!this.tileSources || this.tileSources.length - 1 === page) {
                if (!this.navPrevNextWrap) {
                  this.nextButton.disable();
                }
              } else {
                this.nextButton.enable();
              }
            }
            if (this.previousButton) {
              if (page > 0) {
                this.previousButton.enable();
              } else {
                if (!this.navPrevNextWrap) {
                  this.previousButton.disable();
                }
              }
            }
          },
          /**
           * Display a message in the viewport
           * @function OpenSeadragon.Viewer.prototype._showMessage
           * @private
           * @param {String} text message
           */
          _showMessage: function(message) {
            this._hideMessage();
            var div = $2.makeNeutralElement("div");
            div.appendChild(document.createTextNode(message));
            this.messageDiv = $2.makeCenteredNode(div);
            $2.addClass(this.messageDiv, "openseadragon-message");
            this.container.appendChild(this.messageDiv);
          },
          /**
           * Hide any currently displayed viewport message
           * @function OpenSeadragon.Viewer.prototype._hideMessage
           * @private
           */
          _hideMessage: function() {
            var div = this.messageDiv;
            if (div) {
              div.parentNode.removeChild(div);
              delete this.messageDiv;
            }
          },
          /**
           * Gets this viewer's gesture settings for the given pointer device type.
           * @method
           * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
           * @return {OpenSeadragon.GestureSettings}
           */
          gestureSettingsByDeviceType: function(type) {
            switch (type) {
              case "mouse":
                return this.gestureSettingsMouse;
              case "touch":
                return this.gestureSettingsTouch;
              case "pen":
                return this.gestureSettingsPen;
              default:
                return this.gestureSettingsUnknown;
            }
          },
          // private
          _drawOverlays: function() {
            var i, length = this.currentOverlays.length;
            for (i = 0; i < length; i++) {
              this.currentOverlays[i].drawHTML(this.overlaysContainer, this.viewport);
            }
          },
          /**
           * Cancel the "in flight" images.
           */
          _cancelPendingImages: function() {
            this._loadQueue = [];
          },
          /**
           * Removes the reference strip and disables displaying it.
           * @function
           */
          removeReferenceStrip: function() {
            this.showReferenceStrip = false;
            if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
            }
          },
          /**
           * Enables and displays the reference strip based on the currently set tileSources.
           * Works only when the Viewer has sequenceMode set to true.
           * @function
           */
          addReferenceStrip: function() {
            this.showReferenceStrip = true;
            if (this.sequenceMode) {
              if (this.referenceStrip) {
                return;
              }
              if (this.tileSources.length && this.tileSources.length > 1) {
                this.referenceStrip = new $2.ReferenceStrip({
                  id: this.referenceStripElement,
                  position: this.referenceStripPosition,
                  sizeRatio: this.referenceStripSizeRatio,
                  scroll: this.referenceStripScroll,
                  height: this.referenceStripHeight,
                  width: this.referenceStripWidth,
                  tileSources: this.tileSources,
                  prefixUrl: this.prefixUrl,
                  useCanvas: this.useCanvas,
                  viewer: this
                });
                this.referenceStrip.setFocus(this._sequenceIndex);
              }
            } else {
              $2.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
            }
          }
        }
      );
      function _getSafeElemSize(oElement) {
        oElement = $2.getElement(oElement);
        return new $2.Point(
          oElement.clientWidth === 0 ? 1 : oElement.clientWidth,
          oElement.clientHeight === 0 ? 1 : oElement.clientHeight
        );
      }
      function getTileSourceImplementation(viewer, tileSource, imgOptions, successCallback, failCallback) {
        var _this = viewer;
        if ($2.type(tileSource) == "string") {
          if (tileSource.match(/^\s*<.*>\s*$/)) {
            tileSource = $2.parseXml(tileSource);
          } else if (tileSource.match(/^\s*[\{\[].*[\}\]]\s*$/)) {
            try {
              var tileSourceJ = $2.parseJSON(tileSource);
              tileSource = tileSourceJ;
            } catch (e) {
            }
          }
        }
        function waitUntilReady(tileSource2, originalTileSource) {
          if (tileSource2.ready) {
            successCallback(tileSource2);
          } else {
            tileSource2.addHandler("ready", function() {
              successCallback(tileSource2);
            });
            tileSource2.addHandler("open-failed", function(event) {
              failCallback({
                message: event.message,
                source: originalTileSource
              });
            });
          }
        }
        setTimeout(function() {
          if ($2.type(tileSource) == "string") {
            tileSource = new $2.TileSource({
              url: tileSource,
              crossOriginPolicy: imgOptions.crossOriginPolicy !== void 0 ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy,
              ajaxWithCredentials: viewer.ajaxWithCredentials,
              ajaxHeaders: viewer.ajaxHeaders,
              useCanvas: viewer.useCanvas,
              success: function(event) {
                successCallback(event.tileSource);
              }
            });
            tileSource.addHandler("open-failed", function(event) {
              failCallback(event);
            });
          } else if ($2.isPlainObject(tileSource) || tileSource.nodeType) {
            if (tileSource.crossOriginPolicy === void 0 && (imgOptions.crossOriginPolicy !== void 0 || viewer.crossOriginPolicy !== void 0)) {
              tileSource.crossOriginPolicy = imgOptions.crossOriginPolicy !== void 0 ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy;
            }
            if (tileSource.ajaxWithCredentials === void 0) {
              tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;
            }
            if (tileSource.useCanvas === void 0) {
              tileSource.useCanvas = viewer.useCanvas;
            }
            if ($2.isFunction(tileSource.getTileUrl)) {
              var customTileSource = new $2.TileSource(tileSource);
              customTileSource.getTileUrl = tileSource.getTileUrl;
              successCallback(customTileSource);
            } else {
              var $TileSource = $2.TileSource.determineType(_this, tileSource);
              if (!$TileSource) {
                failCallback({
                  message: "Unable to load TileSource",
                  source: tileSource
                });
                return;
              }
              var options = $TileSource.prototype.configure.apply(_this, [tileSource]);
              waitUntilReady(new $TileSource(options), tileSource);
            }
          } else {
            waitUntilReady(tileSource, tileSource);
          }
        });
      }
      function getOverlayObject(viewer, overlay) {
        if (overlay instanceof $2.Overlay) {
          return overlay;
        }
        var element = null;
        if (overlay.element) {
          element = $2.getElement(overlay.element);
        } else {
          var id = overlay.id ? overlay.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1e7);
          element = $2.getElement(overlay.id);
          if (!element) {
            element = document.createElement("a");
            element.href = "#/overlay/" + id;
          }
          element.id = id;
          $2.addClass(
            element,
            overlay.className ? overlay.className : "openseadragon-overlay"
          );
        }
        var location = overlay.location;
        var width = overlay.width;
        var height = overlay.height;
        if (!location) {
          var x = overlay.x;
          var y = overlay.y;
          if (overlay.px !== void 0) {
            var rect = viewer.viewport.imageToViewportRectangle(new $2.Rect(
              overlay.px,
              overlay.py,
              width || 0,
              height || 0
            ));
            x = rect.x;
            y = rect.y;
            width = width !== void 0 ? rect.width : void 0;
            height = height !== void 0 ? rect.height : void 0;
          }
          location = new $2.Point(x, y);
        }
        var placement = overlay.placement;
        if (placement && $2.type(placement) === "string") {
          placement = $2.Placement[overlay.placement.toUpperCase()];
        }
        return new $2.Overlay({
          element,
          location,
          placement,
          onDraw: overlay.onDraw,
          checkResize: overlay.checkResize,
          width,
          height,
          rotationMode: overlay.rotationMode
        });
      }
      function getOverlayIndex(overlays, element) {
        var i;
        for (i = overlays.length - 1; i >= 0; i--) {
          if (overlays[i].element === element) {
            return i;
          }
        }
        return -1;
      }
      function scheduleUpdate(viewer, updateFunc) {
        return $2.requestAnimationFrame(function() {
          updateFunc(viewer);
        });
      }
      function scheduleControlsFade(viewer) {
        $2.requestAnimationFrame(function() {
          updateControlsFade(viewer);
        });
      }
      function beginControlsAutoHide(viewer) {
        if (!viewer.autoHideControls) {
          return;
        }
        viewer.controlsShouldFade = true;
        viewer.controlsFadeBeginTime = $2.now() + viewer.controlsFadeDelay;
        window.setTimeout(function() {
          scheduleControlsFade(viewer);
        }, viewer.controlsFadeDelay);
      }
      function updateControlsFade(viewer) {
        var currentTime, deltaTime, opacity, i;
        if (viewer.controlsShouldFade) {
          currentTime = $2.now();
          deltaTime = currentTime - viewer.controlsFadeBeginTime;
          opacity = 1 - deltaTime / viewer.controlsFadeLength;
          opacity = Math.min(1, opacity);
          opacity = Math.max(0, opacity);
          for (i = viewer.controls.length - 1; i >= 0; i--) {
            if (viewer.controls[i].autoFade) {
              viewer.controls[i].setOpacity(opacity);
            }
          }
          if (opacity > 0) {
            scheduleControlsFade(viewer);
          }
        }
      }
      function abortControlsAutoHide(viewer) {
        var i;
        viewer.controlsShouldFade = false;
        for (i = viewer.controls.length - 1; i >= 0; i--) {
          viewer.controls[i].setOpacity(1);
        }
      }
      function onFocus() {
        abortControlsAutoHide(this);
      }
      function onBlur() {
        beginControlsAutoHide(this);
      }
      function onCanvasKeyDown(event) {
        var canvasKeyDownEventArgs = {
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction,
          preventVerticalPan: event.preventVerticalPan,
          preventHorizontalPan: event.preventHorizontalPan
        };
        this.raiseEvent("canvas-key", canvasKeyDownEventArgs);
        if (!canvasKeyDownEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
          switch (event.keyCode) {
            case 38:
              if (!canvasKeyDownEventArgs.preventVerticalPan) {
                if (event.shift) {
                  this.viewport.zoomBy(1.1);
                } else {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(0, -this.pixelsPerArrowPress)));
                }
                this.viewport.applyConstraints();
              }
              return false;
            case 40:
              if (!canvasKeyDownEventArgs.preventVerticalPan) {
                if (event.shift) {
                  this.viewport.zoomBy(0.9);
                } else {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(0, this.pixelsPerArrowPress)));
                }
                this.viewport.applyConstraints();
              }
              return false;
            case 37:
              if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(-this.pixelsPerArrowPress, 0)));
                this.viewport.applyConstraints();
              }
              return false;
            case 39:
              if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(this.pixelsPerArrowPress, 0)));
                this.viewport.applyConstraints();
              }
              return false;
            default:
              return true;
          }
        } else {
          return true;
        }
      }
      function onCanvasKeyPress(event) {
        var canvasKeyPressEventArgs = {
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction,
          preventVerticalPan: event.preventVerticalPan,
          preventHorizontalPan: event.preventHorizontalPan
        };
        this.raiseEvent("canvas-key", canvasKeyPressEventArgs);
        if (!canvasKeyPressEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
          switch (event.keyCode) {
            case 43:
            case 61:
              this.viewport.zoomBy(1.1);
              this.viewport.applyConstraints();
              return false;
            case 45:
              this.viewport.zoomBy(0.9);
              this.viewport.applyConstraints();
              return false;
            case 48:
              this.viewport.goHome();
              this.viewport.applyConstraints();
              return false;
            case 119:
            case 87:
              if (!canvasKeyPressEventArgs.preventVerticalPan) {
                if (event.shift) {
                  this.viewport.zoomBy(1.1);
                } else {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(0, -40)));
                }
                this.viewport.applyConstraints();
              }
              return false;
            case 115:
            case 83:
              if (!canvasKeyPressEventArgs.preventVerticalPan) {
                if (event.shift) {
                  this.viewport.zoomBy(0.9);
                } else {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(0, 40)));
                }
                this.viewport.applyConstraints();
              }
              return false;
            case 97:
              if (!canvasKeyPressEventArgs.preventHorizontalPan) {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(-40, 0)));
                this.viewport.applyConstraints();
              }
              return false;
            case 100:
              if (!canvasKeyPressEventArgs.preventHorizontalPan) {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(40, 0)));
                this.viewport.applyConstraints();
              }
              return false;
            case 114:
              if (this.viewport.flipped) {
                this.viewport.setRotation($2.positiveModulo(this.viewport.degrees - this.rotationIncrement, 360));
              } else {
                this.viewport.setRotation($2.positiveModulo(this.viewport.degrees + this.rotationIncrement, 360));
              }
              this.viewport.applyConstraints();
              return false;
            case 82:
              if (this.viewport.flipped) {
                this.viewport.setRotation($2.positiveModulo(this.viewport.degrees + this.rotationIncrement, 360));
              } else {
                this.viewport.setRotation($2.positiveModulo(this.viewport.degrees - this.rotationIncrement, 360));
              }
              this.viewport.applyConstraints();
              return false;
            case 102:
              this.viewport.toggleFlip();
              return false;
            default:
              return true;
          }
        } else {
          return true;
        }
      }
      function onCanvasClick(event) {
        var gestureSettings;
        var haveKeyboardFocus = document.activeElement == this.canvas;
        if (!haveKeyboardFocus) {
          this.canvas.focus();
        }
        if (this.viewport.flipped) {
          event.position.x = this.viewport.getContainerSize().x - event.position.x;
        }
        var canvasClickEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          quick: event.quick,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction
        };
        this.raiseEvent("canvas-click", canvasClickEventArgs);
        if (!canvasClickEventArgs.preventDefaultAction && this.viewport && event.quick) {
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.clickToZoom) {
            this.viewport.zoomBy(
              event.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
              gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
            );
            this.viewport.applyConstraints();
          }
        }
      }
      function onCanvasDblClick(event) {
        var gestureSettings;
        var canvasDblClickEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction
        };
        this.raiseEvent("canvas-double-click", canvasDblClickEventArgs);
        if (!canvasDblClickEventArgs.preventDefaultAction && this.viewport) {
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.dblClickToZoom) {
            this.viewport.zoomBy(
              event.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
              gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
            );
            this.viewport.applyConstraints();
          }
        }
      }
      function onCanvasDrag(event) {
        var gestureSettings;
        var canvasDragEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          delta: event.delta,
          speed: event.speed,
          direction: event.direction,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction
        };
        this.raiseEvent("canvas-drag", canvasDragEventArgs);
        if (!canvasDragEventArgs.preventDefaultAction && this.viewport) {
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (!this.panHorizontal) {
            event.delta.x = 0;
          }
          if (!this.panVertical) {
            event.delta.y = 0;
          }
          if (this.viewport.flipped) {
            event.delta.x = -event.delta.x;
          }
          if (this.constrainDuringPan) {
            var delta = this.viewport.deltaPointsFromPixels(event.delta.negate());
            this.viewport.centerSpringX.target.value += delta.x;
            this.viewport.centerSpringY.target.value += delta.y;
            var bounds = this.viewport.getBounds();
            var constrainedBounds = this.viewport.getConstrainedBounds();
            this.viewport.centerSpringX.target.value -= delta.x;
            this.viewport.centerSpringY.target.value -= delta.y;
            if (bounds.x != constrainedBounds.x) {
              event.delta.x = 0;
            }
            if (bounds.y != constrainedBounds.y) {
              event.delta.y = 0;
            }
          }
          this.viewport.panBy(this.viewport.deltaPointsFromPixels(event.delta.negate()), gestureSettings.flickEnabled && !this.constrainDuringPan);
        }
      }
      function onCanvasDragEnd(event) {
        if (!event.preventDefaultAction && this.viewport) {
          var gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.flickEnabled && event.speed >= gestureSettings.flickMinSpeed) {
            var amplitudeX = 0;
            if (this.panHorizontal) {
              amplitudeX = gestureSettings.flickMomentum * event.speed * Math.cos(event.direction);
            }
            var amplitudeY = 0;
            if (this.panVertical) {
              amplitudeY = gestureSettings.flickMomentum * event.speed * Math.sin(event.direction);
            }
            var center = this.viewport.pixelFromPoint(
              this.viewport.getCenter(true)
            );
            var target = this.viewport.pointFromPixel(
              new $2.Point(center.x - amplitudeX, center.y - amplitudeY)
            );
            this.viewport.panTo(target, false);
          }
          this.viewport.applyConstraints();
        }
        this.raiseEvent("canvas-drag-end", {
          tracker: event.eventSource,
          position: event.position,
          speed: event.speed,
          direction: event.direction,
          shift: event.shift,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasEnter(event) {
        this.raiseEvent("canvas-enter", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasExit(event) {
        if (window.location != window.parent.location) {
          $2.MouseTracker.resetAllMouseTrackers();
        }
        this.raiseEvent("canvas-exit", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasPress(event) {
        this.raiseEvent("canvas-press", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          insideElementPressed: event.insideElementPressed,
          insideElementReleased: event.insideElementReleased,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasRelease(event) {
        this.raiseEvent("canvas-release", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          insideElementPressed: event.insideElementPressed,
          insideElementReleased: event.insideElementReleased,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasNonPrimaryPress(event) {
        this.raiseEvent("canvas-nonprimary-press", {
          tracker: event.eventSource,
          position: event.position,
          pointerType: event.pointerType,
          button: event.button,
          buttons: event.buttons,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasNonPrimaryRelease(event) {
        this.raiseEvent("canvas-nonprimary-release", {
          tracker: event.eventSource,
          position: event.position,
          pointerType: event.pointerType,
          button: event.button,
          buttons: event.buttons,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasPinch(event) {
        var gestureSettings, centerPt, lastCenterPt, panByPt;
        if (!event.preventDefaultAction && this.viewport) {
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.pinchToZoom) {
            centerPt = this.viewport.pointFromPixel(event.center, true);
            lastCenterPt = this.viewport.pointFromPixel(event.lastCenter, true);
            panByPt = lastCenterPt.minus(centerPt);
            if (!this.panHorizontal) {
              panByPt.x = 0;
            }
            if (!this.panVertical) {
              panByPt.y = 0;
            }
            this.viewport.zoomBy(event.distance / event.lastDistance, centerPt, true);
            if (gestureSettings.zoomToRefPoint) {
              this.viewport.panBy(panByPt, true);
            }
            this.viewport.applyConstraints();
          }
          if (gestureSettings.pinchRotate) {
            var angle1 = Math.atan2(
              event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,
              event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x
            );
            var angle2 = Math.atan2(
              event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,
              event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x
            );
            this.viewport.setRotation(this.viewport.getRotation() + (angle1 - angle2) * (180 / Math.PI));
          }
        }
        this.raiseEvent("canvas-pinch", {
          tracker: event.eventSource,
          gesturePoints: event.gesturePoints,
          lastCenter: event.lastCenter,
          center: event.center,
          lastDistance: event.lastDistance,
          distance: event.distance,
          shift: event.shift,
          originalEvent: event.originalEvent
        });
        return false;
      }
      function onCanvasScroll(event) {
        var gestureSettings, factor, thisScrollTime, deltaScrollTime;
        thisScrollTime = $2.now();
        deltaScrollTime = thisScrollTime - this._lastScrollTime;
        if (deltaScrollTime > this.minScrollDeltaTime) {
          this._lastScrollTime = thisScrollTime;
          if (this.viewport.flipped) {
            event.position.x = this.viewport.getContainerSize().x - event.position.x;
          }
          if (!event.preventDefaultAction && this.viewport) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.scrollToZoom) {
              factor = Math.pow(this.zoomPerScroll, event.scroll);
              this.viewport.zoomBy(
                factor,
                gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
              );
              this.viewport.applyConstraints();
            }
          }
          this.raiseEvent("canvas-scroll", {
            tracker: event.eventSource,
            position: event.position,
            scroll: event.scroll,
            shift: event.shift,
            originalEvent: event.originalEvent
          });
          if (gestureSettings && gestureSettings.scrollToZoom) {
            return false;
          }
        } else {
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings && gestureSettings.scrollToZoom) {
            return false;
          }
        }
      }
      function onContainerEnter(event) {
        THIS[this.hash].mouseInside = true;
        abortControlsAutoHide(this);
        this.raiseEvent("container-enter", {
          tracker: event.eventSource,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
        });
      }
      function onContainerExit(event) {
        if (event.pointers < 1) {
          THIS[this.hash].mouseInside = false;
          if (!THIS[this.hash].animating) {
            beginControlsAutoHide(this);
          }
        }
        this.raiseEvent("container-exit", {
          tracker: event.eventSource,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
        });
      }
      function updateMulti(viewer) {
        updateOnce(viewer);
        if (viewer.isOpen()) {
          viewer._updateRequestId = scheduleUpdate(viewer, updateMulti);
        } else {
          viewer._updateRequestId = false;
        }
      }
      function updateOnce(viewer) {
        if (viewer._opening) {
          return;
        }
        if (viewer.autoResize) {
          var containerSize = _getSafeElemSize(viewer.container);
          var prevContainerSize = THIS[viewer.hash].prevContainerSize;
          if (!containerSize.equals(prevContainerSize)) {
            var viewport = viewer.viewport;
            if (viewer.preserveImageSizeOnResize) {
              var resizeRatio = prevContainerSize.x / containerSize.x;
              var zoom = viewport.getZoom() * resizeRatio;
              var center = viewport.getCenter();
              viewport.resize(containerSize, false);
              viewport.zoomTo(zoom, null, true);
              viewport.panTo(center, true);
            } else {
              var oldBounds = viewport.getBounds();
              viewport.resize(containerSize, true);
              viewport.fitBoundsWithConstraints(oldBounds, true);
            }
            THIS[viewer.hash].prevContainerSize = containerSize;
            THIS[viewer.hash].forceRedraw = true;
          }
        }
        var viewportChange = viewer.viewport.update();
        var animated = viewer.world.update() || viewportChange;
        if (viewportChange) {
          viewer.raiseEvent("viewport-change");
        }
        if (viewer.referenceStrip) {
          animated = viewer.referenceStrip.update(viewer.viewport) || animated;
        }
        if (!THIS[viewer.hash].animating && animated) {
          viewer.raiseEvent("animation-start");
          abortControlsAutoHide(viewer);
        }
        if (animated || THIS[viewer.hash].forceRedraw || viewer.world.needsDraw()) {
          drawWorld(viewer);
          viewer._drawOverlays();
          if (viewer.navigator) {
            viewer.navigator.update(viewer.viewport);
          }
          THIS[viewer.hash].forceRedraw = false;
          if (animated) {
            viewer.raiseEvent("animation");
          }
        }
        if (THIS[viewer.hash].animating && !animated) {
          viewer.raiseEvent("animation-finish");
          if (!THIS[viewer.hash].mouseInside) {
            beginControlsAutoHide(viewer);
          }
        }
        THIS[viewer.hash].animating = animated;
      }
      function drawWorld(viewer) {
        viewer.imageLoader.clear();
        viewer.drawer.clear();
        viewer.world.draw();
        viewer.raiseEvent("update-viewport", {});
      }
      function resolveUrl(prefix, url) {
        return prefix ? prefix + url : url;
      }
      function beginZoomingIn() {
        THIS[this.hash].lastZoomTime = $2.now();
        THIS[this.hash].zoomFactor = this.zoomPerSecond;
        THIS[this.hash].zooming = true;
        scheduleZoom(this);
      }
      function beginZoomingOut() {
        THIS[this.hash].lastZoomTime = $2.now();
        THIS[this.hash].zoomFactor = 1 / this.zoomPerSecond;
        THIS[this.hash].zooming = true;
        scheduleZoom(this);
      }
      function endZooming() {
        THIS[this.hash].zooming = false;
      }
      function scheduleZoom(viewer) {
        $2.requestAnimationFrame($2.delegate(viewer, doZoom));
      }
      function doZoom() {
        var currentTime, deltaTime, adjustedFactor;
        if (THIS[this.hash].zooming && this.viewport) {
          currentTime = $2.now();
          deltaTime = currentTime - THIS[this.hash].lastZoomTime;
          adjustedFactor = Math.pow(THIS[this.hash].zoomFactor, deltaTime / 1e3);
          this.viewport.zoomBy(adjustedFactor);
          this.viewport.applyConstraints();
          THIS[this.hash].lastZoomTime = currentTime;
          scheduleZoom(this);
        }
      }
      function doSingleZoomIn() {
        if (this.viewport) {
          THIS[this.hash].zooming = false;
          this.viewport.zoomBy(
            this.zoomPerClick / 1
          );
          this.viewport.applyConstraints();
        }
      }
      function doSingleZoomOut() {
        if (this.viewport) {
          THIS[this.hash].zooming = false;
          this.viewport.zoomBy(
            1 / this.zoomPerClick
          );
          this.viewport.applyConstraints();
        }
      }
      function lightUp() {
        this.buttons.emulateEnter();
        this.buttons.emulateExit();
      }
      function onHome() {
        if (this.viewport) {
          this.viewport.goHome();
        }
      }
      function onFullScreen() {
        if (this.isFullPage() && !$2.isFullScreen()) {
          this.setFullPage(false);
        } else {
          this.setFullScreen(!this.isFullPage());
        }
        if (this.buttons) {
          this.buttons.emulateExit();
        }
        this.fullPageButton.element.focus();
        if (this.viewport) {
          this.viewport.applyConstraints();
        }
      }
      function onRotateLeft() {
        if (this.viewport) {
          var currRotation = this.viewport.getRotation();
          if (this.viewport.flipped) {
            currRotation = $2.positiveModulo(currRotation + this.rotationIncrement, 360);
          } else {
            currRotation = $2.positiveModulo(currRotation - this.rotationIncrement, 360);
          }
          this.viewport.setRotation(currRotation);
        }
      }
      function onRotateRight() {
        if (this.viewport) {
          var currRotation = this.viewport.getRotation();
          if (this.viewport.flipped) {
            currRotation = $2.positiveModulo(currRotation - this.rotationIncrement, 360);
          } else {
            currRotation = $2.positiveModulo(currRotation + this.rotationIncrement, 360);
          }
          this.viewport.setRotation(currRotation);
        }
      }
      function onFlip() {
        this.viewport.toggleFlip();
      }
      function onPrevious() {
        var previous = this._sequenceIndex - 1;
        if (this.navPrevNextWrap && previous < 0) {
          previous += this.tileSources.length;
        }
        this.goToPage(previous);
      }
      function onNext() {
        var next = this._sequenceIndex + 1;
        if (this.navPrevNextWrap && next >= this.tileSources.length) {
          next = 0;
        }
        this.goToPage(next);
      }
    })(OpenSeadragon);
    (function($2) {
      $2.Navigator = function(options) {
        var viewer = options.viewer, _this = this, viewerSize, navigatorSize;
        if (!options.id) {
          options.id = "navigator-" + $2.now();
          this.element = $2.makeNeutralElement("div");
          options.controlOptions = {
            anchor: $2.ControlAnchor.TOP_RIGHT,
            attachToViewer: true,
            autoFade: options.autoFade
          };
          if (options.position) {
            if ("BOTTOM_RIGHT" == options.position) {
              options.controlOptions.anchor = $2.ControlAnchor.BOTTOM_RIGHT;
            } else if ("BOTTOM_LEFT" == options.position) {
              options.controlOptions.anchor = $2.ControlAnchor.BOTTOM_LEFT;
            } else if ("TOP_RIGHT" == options.position) {
              options.controlOptions.anchor = $2.ControlAnchor.TOP_RIGHT;
            } else if ("TOP_LEFT" == options.position) {
              options.controlOptions.anchor = $2.ControlAnchor.TOP_LEFT;
            } else if ("ABSOLUTE" == options.position) {
              options.controlOptions.anchor = $2.ControlAnchor.ABSOLUTE;
              options.controlOptions.top = options.top;
              options.controlOptions.left = options.left;
              options.controlOptions.height = options.height;
              options.controlOptions.width = options.width;
            }
          }
        } else {
          this.element = document.getElementById(options.id);
          options.controlOptions = {
            anchor: $2.ControlAnchor.NONE,
            attachToViewer: false,
            autoFade: false
          };
        }
        this.element.id = options.id;
        this.element.className += " navigator";
        options = $2.extend(true, {
          sizeRatio: $2.DEFAULT_SETTINGS.navigatorSizeRatio
        }, options, {
          element: this.element,
          tabIndex: -1,
          // No keyboard navigation, omit from tab order
          //These need to be overridden to prevent recursion since
          //the navigator is a viewer and a viewer has a navigator
          showNavigator: false,
          mouseNavEnabled: false,
          showNavigationControl: false,
          showSequenceControl: false,
          immediateRender: true,
          blendTime: 0,
          animationTime: 0,
          autoResize: options.autoResize,
          // prevent resizing the navigator from adding unwanted space around the image
          minZoomImageRatio: 1,
          background: options.background,
          opacity: options.opacity,
          borderColor: options.borderColor,
          displayRegionColor: options.displayRegionColor
        });
        options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;
        $2.setElementTouchActionNone(this.element);
        this.borderWidth = 2;
        this.fudge = new $2.Point(1, 1);
        this.totalBorderWidths = new $2.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge);
        if (options.controlOptions.anchor != $2.ControlAnchor.NONE) {
          (function(style, borderWidth) {
            style.margin = "0px";
            style.border = borderWidth + "px solid " + options.borderColor;
            style.padding = "0px";
            style.background = options.background;
            style.opacity = options.opacity;
            style.overflow = "hidden";
          })(this.element.style, this.borderWidth);
        }
        this.displayRegion = $2.makeNeutralElement("div");
        this.displayRegion.id = this.element.id + "-displayregion";
        this.displayRegion.className = "displayregion";
        (function(style, borderWidth) {
          style.position = "relative";
          style.top = "0px";
          style.left = "0px";
          style.fontSize = "0px";
          style.overflow = "hidden";
          style.border = borderWidth + "px solid " + options.displayRegionColor;
          style.margin = "0px";
          style.padding = "0px";
          style.background = "transparent";
          style["float"] = "left";
          style.cssFloat = "left";
          style.styleFloat = "left";
          style.zIndex = 999999999;
          style.cursor = "default";
        })(this.displayRegion.style, this.borderWidth);
        this.displayRegionContainer = $2.makeNeutralElement("div");
        this.displayRegionContainer.id = this.element.id + "-displayregioncontainer";
        this.displayRegionContainer.className = "displayregioncontainer";
        this.displayRegionContainer.style.width = "100%";
        this.displayRegionContainer.style.height = "100%";
        viewer.addControl(
          this.element,
          options.controlOptions
        );
        this._resizeWithViewer = options.controlOptions.anchor != $2.ControlAnchor.ABSOLUTE && options.controlOptions.anchor != $2.ControlAnchor.NONE;
        if (options.width && options.height) {
          this.setWidth(options.width);
          this.setHeight(options.height);
        } else if (this._resizeWithViewer) {
          viewerSize = $2.getElementSize(viewer.element);
          this.element.style.height = Math.round(viewerSize.y * options.sizeRatio) + "px";
          this.element.style.width = Math.round(viewerSize.x * options.sizeRatio) + "px";
          this.oldViewerSize = viewerSize;
          navigatorSize = $2.getElementSize(this.element);
          this.elementArea = navigatorSize.x * navigatorSize.y;
        }
        this.oldContainerSize = new $2.Point(0, 0);
        $2.Viewer.apply(this, [options]);
        this.displayRegionContainer.appendChild(this.displayRegion);
        this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
        function rotate(degrees2) {
          _setTransformRotate(_this.displayRegionContainer, degrees2);
          _setTransformRotate(_this.displayRegion, -degrees2);
          _this.viewport.setRotation(degrees2);
        }
        if (options.navigatorRotate) {
          var degrees = options.viewer.viewport ? options.viewer.viewport.getRotation() : options.viewer.degrees || 0;
          rotate(degrees);
          options.viewer.addHandler("rotate", function(args) {
            rotate(args.degrees);
          });
        }
        this.innerTracker.destroy();
        this.innerTracker = new $2.MouseTracker({
          element: this.element,
          dragHandler: $2.delegate(this, onCanvasDrag),
          clickHandler: $2.delegate(this, onCanvasClick),
          releaseHandler: $2.delegate(this, onCanvasRelease),
          scrollHandler: $2.delegate(this, onCanvasScroll)
        });
        this.addHandler("reset-size", function() {
          if (_this.viewport) {
            _this.viewport.goHome(true);
          }
        });
        viewer.world.addHandler("item-index-change", function(event) {
          window.setTimeout(function() {
            var item = _this.world.getItemAt(event.previousIndex);
            _this.world.setItemIndex(item, event.newIndex);
          }, 1);
        });
        viewer.world.addHandler("remove-item", function(event) {
          var theirItem = event.item;
          var myItem = _this._getMatchingItem(theirItem);
          if (myItem) {
            _this.world.removeItem(myItem);
          }
        });
        this.update(viewer.viewport);
      };
      $2.extend(
        $2.Navigator.prototype,
        $2.EventSource.prototype,
        $2.Viewer.prototype,
        /** @lends OpenSeadragon.Navigator.prototype */
        {
          /**
           * Used to notify the navigator when its size has changed.
           * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.
           * @function
           */
          updateSize: function() {
            if (this.viewport) {
              var containerSize = new $2.Point(
                this.container.clientWidth === 0 ? 1 : this.container.clientWidth,
                this.container.clientHeight === 0 ? 1 : this.container.clientHeight
              );
              if (!containerSize.equals(this.oldContainerSize)) {
                this.viewport.resize(containerSize, true);
                this.viewport.goHome(true);
                this.oldContainerSize = containerSize;
                this.drawer.clear();
                this.world.draw();
              }
            }
          },
          /**
           * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
           * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
           */
          setWidth: function(width) {
            this.width = width;
            this.element.style.width = typeof width == "number" ? width + "px" : width;
            this._resizeWithViewer = false;
          },
          /**
           * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
           * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
           */
          setHeight: function(height) {
            this.height = height;
            this.element.style.height = typeof height == "number" ? height + "px" : height;
            this._resizeWithViewer = false;
          },
          /**
            * Flip navigator element
            * @param {Boolean} state - Flip state to set.
            */
          setFlip: function(state) {
            this.viewport.setFlip(state);
            this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)");
            return this;
          },
          setDisplayTransform: function(rule) {
            setElementTransform(this.displayRegion, rule);
            setElementTransform(this.canvas, rule);
            setElementTransform(this.element, rule);
          },
          /**
           * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
           * @function
           * @param {OpenSeadragon.Viewport} The viewport this navigator is tracking.
           */
          update: function(viewport) {
            var viewerSize, newWidth, newHeight, bounds, topleft, bottomright;
            viewerSize = $2.getElementSize(this.viewer.element);
            if (this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals(this.oldViewerSize)) {
              this.oldViewerSize = viewerSize;
              if (this.maintainSizeRatio || !this.elementArea) {
                newWidth = viewerSize.x * this.sizeRatio;
                newHeight = viewerSize.y * this.sizeRatio;
              } else {
                newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
                newHeight = this.elementArea / newWidth;
              }
              this.element.style.width = Math.round(newWidth) + "px";
              this.element.style.height = Math.round(newHeight) + "px";
              if (!this.elementArea) {
                this.elementArea = newWidth * newHeight;
              }
              this.updateSize();
            }
            if (viewport && this.viewport) {
              bounds = viewport.getBoundsNoRotate(true);
              topleft = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);
              bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false).minus(this.totalBorderWidths);
              var style = this.displayRegion.style;
              style.display = this.world.getItemCount() ? "block" : "none";
              style.top = Math.round(topleft.y) + "px";
              style.left = Math.round(topleft.x) + "px";
              var width = Math.abs(topleft.x - bottomright.x);
              var height = Math.abs(topleft.y - bottomright.y);
              style.width = Math.round(Math.max(width, 0)) + "px";
              style.height = Math.round(Math.max(height, 0)) + "px";
            }
          },
          // overrides Viewer.addTiledImage
          addTiledImage: function(options) {
            var _this = this;
            var original = options.originalTiledImage;
            delete options.original;
            var optionsClone = $2.extend({}, options, {
              success: function(event) {
                var myItem = event.item;
                myItem._originalForNavigator = original;
                _this._matchBounds(myItem, original, true);
                function matchBounds() {
                  _this._matchBounds(myItem, original);
                }
                function matchOpacity() {
                  _this._matchOpacity(myItem, original);
                }
                function matchCompositeOperation() {
                  _this._matchCompositeOperation(myItem, original);
                }
                original.addHandler("bounds-change", matchBounds);
                original.addHandler("clip-change", matchBounds);
                original.addHandler("opacity-change", matchOpacity);
                original.addHandler("composite-operation-change", matchCompositeOperation);
              }
            });
            return $2.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);
          },
          // private
          _getMatchingItem: function(theirItem) {
            var count = this.world.getItemCount();
            var item;
            for (var i = 0; i < count; i++) {
              item = this.world.getItemAt(i);
              if (item._originalForNavigator === theirItem) {
                return item;
              }
            }
            return null;
          },
          // private
          _matchBounds: function(myItem, theirItem, immediately) {
            var bounds = theirItem.getBoundsNoRotate();
            myItem.setPosition(bounds.getTopLeft(), immediately);
            myItem.setWidth(bounds.width, immediately);
            myItem.setRotation(theirItem.getRotation(), immediately);
            myItem.setClip(theirItem.getClip());
          },
          // private
          _matchOpacity: function(myItem, theirItem) {
            myItem.setOpacity(theirItem.opacity);
          },
          // private
          _matchCompositeOperation: function(myItem, theirItem) {
            myItem.setCompositeOperation(theirItem.compositeOperation);
          }
        }
      );
      function onCanvasClick(event) {
        var canvasClickEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          quick: event.quick,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction
        };
        this.viewer.raiseEvent("navigator-click", canvasClickEventArgs);
        if (!canvasClickEventArgs.preventDefaultAction && event.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
          if (this.viewer.viewport.flipped) {
            event.position.x = this.viewport.getContainerSize().x - event.position.x;
          }
          var target = this.viewport.pointFromPixel(event.position);
          if (!this.panVertical) {
            target.y = this.viewer.viewport.getCenter(true).y;
          } else if (!this.panHorizontal) {
            target.x = this.viewer.viewport.getCenter(true).x;
          }
          this.viewer.viewport.panTo(target);
          this.viewer.viewport.applyConstraints();
        }
      }
      function onCanvasDrag(event) {
        var canvasDragEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          delta: event.delta,
          speed: event.speed,
          direction: event.direction,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction
        };
        this.viewer.raiseEvent("navigator-drag", canvasDragEventArgs);
        if (!canvasDragEventArgs.preventDefaultAction && this.viewer.viewport) {
          if (!this.panHorizontal) {
            event.delta.x = 0;
          }
          if (!this.panVertical) {
            event.delta.y = 0;
          }
          if (this.viewer.viewport.flipped) {
            event.delta.x = -event.delta.x;
          }
          this.viewer.viewport.panBy(
            this.viewport.deltaPointsFromPixels(
              event.delta
            )
          );
          if (this.viewer.constrainDuringPan) {
            this.viewer.viewport.applyConstraints();
          }
        }
      }
      function onCanvasRelease(event) {
        if (event.insideElementPressed && this.viewer.viewport) {
          this.viewer.viewport.applyConstraints();
        }
      }
      function onCanvasScroll(event) {
        this.viewer.raiseEvent("navigator-scroll", {
          tracker: event.eventSource,
          position: event.position,
          scroll: event.scroll,
          shift: event.shift,
          originalEvent: event.originalEvent
        });
        return false;
      }
      function _setTransformRotate(element, degrees) {
        setElementTransform(element, "rotate(" + degrees + "deg)");
      }
      function setElementTransform(element, rule) {
        element.style.webkitTransform = rule;
        element.style.mozTransform = rule;
        element.style.msTransform = rule;
        element.style.oTransform = rule;
        element.style.transform = rule;
      }
    })(OpenSeadragon);
    (function($2) {
      var I18N = {
        Errors: {
          Dzc: "Sorry, we don't support Deep Zoom Collections!",
          Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
          Security: "It looks like a security restriction stopped us from loading this Deep Zoom Image.",
          Status: "This space unintentionally left blank ({0} {1}).",
          OpenFailed: "Unable to open {0}: {1}"
        },
        Tooltips: {
          FullPage: "Toggle full page",
          Home: "Go home",
          ZoomIn: "Zoom in",
          ZoomOut: "Zoom out",
          NextPage: "Next page",
          PreviousPage: "Previous page",
          RotateLeft: "Rotate left",
          RotateRight: "Rotate right",
          Flip: "Flip Horizontally"
        }
      };
      $2.extend(
        $2,
        /** @lends OpenSeadragon */
        {
          /**
           * @function
           * @param {String} property
           */
          getString: function(prop) {
            var props = prop.split("."), string2 = null, args = arguments, container = I18N, i;
            for (i = 0; i < props.length - 1; i++) {
              container = container[props[i]] || {};
            }
            string2 = container[props[i]];
            if (typeof string2 != "string") {
              $2.console.log("Untranslated source string:", prop);
              string2 = "";
            }
            return string2.replace(/\{\d+\}/g, function(capture) {
              var i2 = parseInt(capture.match(/\d+/), 10) + 1;
              return i2 < args.length ? args[i2] : "";
            });
          },
          /**
           * @function
           * @param {String} property
           * @param {*} value
           */
          setString: function(prop, value) {
            var props = prop.split("."), container = I18N, i;
            for (i = 0; i < props.length - 1; i++) {
              if (!container[props[i]]) {
                container[props[i]] = {};
              }
              container = container[props[i]];
            }
            container[props[i]] = value;
          }
        }
      );
    })(OpenSeadragon);
    (function($2) {
      $2.Point = function(x, y) {
        this.x = typeof x == "number" ? x : 0;
        this.y = typeof y == "number" ? y : 0;
      };
      $2.Point.prototype = {
        /**
         * @function
         * @returns {OpenSeadragon.Point} a duplicate of this Point
         */
        clone: function() {
          return new $2.Point(this.x, this.y);
        },
        /**
         * Add another Point to this point and return a new Point.
         * @function
         * @param {OpenSeadragon.Point} point The point to add vector components.
         * @returns {OpenSeadragon.Point} A new point representing the sum of the
         *  vector components
         */
        plus: function(point) {
          return new $2.Point(
            this.x + point.x,
            this.y + point.y
          );
        },
        /**
         * Subtract another Point to this point and return a new Point.
         * @function
         * @param {OpenSeadragon.Point} point The point to subtract vector components.
         * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
         *  vector components
         */
        minus: function(point) {
          return new $2.Point(
            this.x - point.x,
            this.y - point.y
          );
        },
        /**
         * Multiply this point by a factor and return a new Point.
         * @function
         * @param {Number} factor The factor to multiply vector components.
         * @returns {OpenSeadragon.Point} A new point representing the multiplication
         *  of the vector components by the factor
         */
        times: function(factor) {
          return new $2.Point(
            this.x * factor,
            this.y * factor
          );
        },
        /**
         * Divide this point by a factor and return a new Point.
         * @function
         * @param {Number} factor The factor to divide vector components.
         * @returns {OpenSeadragon.Point} A new point representing the division of the
         *  vector components by the factor
         */
        divide: function(factor) {
          return new $2.Point(
            this.x / factor,
            this.y / factor
          );
        },
        /**
         * Compute the opposite of this point and return a new Point.
         * @function
         * @returns {OpenSeadragon.Point} A new point representing the opposite of the
         *  vector components
         */
        negate: function() {
          return new $2.Point(-this.x, -this.y);
        },
        /**
         * Compute the distance between this point and another point.
         * @function
         * @param {OpenSeadragon.Point} point The point to compute the distance with.
         * @returns {Number} The distance between the 2 points
         */
        distanceTo: function(point) {
          return Math.sqrt(
            Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2)
          );
        },
        /**
         * Compute the squared distance between this point and another point.
         * Useful for optimizing things like comparing distances.
         * @function
         * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
         * @returns {Number} The squared distance between the 2 points
         */
        squaredDistanceTo: function(point) {
          return Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2);
        },
        /**
         * Apply a function to each coordinate of this point and return a new point.
         * @function
         * @param {function} func The function to apply to each coordinate.
         * @returns {OpenSeadragon.Point} A new point with the coordinates computed
         * by the specified function
         */
        apply: function(func) {
          return new $2.Point(func(this.x), func(this.y));
        },
        /**
         * Check if this point is equal to another one.
         * @function
         * @param {OpenSeadragon.Point} point The point to compare this point with.
         * @returns {Boolean} true if they are equal, false otherwise.
         */
        equals: function(point) {
          return point instanceof $2.Point && this.x === point.x && this.y === point.y;
        },
        /**
         * Rotates the point around the specified pivot
         * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
         * @function
         * @param {Number} degress to rotate around the pivot.
         * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
         * Defaults to the origin.
         * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
         */
        rotate: function(degrees, pivot) {
          pivot = pivot || new $2.Point(0, 0);
          var cos;
          var sin;
          if (degrees % 90 === 0) {
            var d = $2.positiveModulo(degrees, 360);
            switch (d) {
              case 0:
                cos = 1;
                sin = 0;
                break;
              case 90:
                cos = 0;
                sin = 1;
                break;
              case 180:
                cos = -1;
                sin = 0;
                break;
              case 270:
                cos = 0;
                sin = -1;
                break;
            }
          } else {
            var angle = degrees * Math.PI / 180;
            cos = Math.cos(angle);
            sin = Math.sin(angle);
          }
          var x = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;
          var y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;
          return new $2.Point(x, y);
        },
        /**
         * Convert this point to a string in the format (x,y) where x and y are
         * rounded to the nearest integer.
         * @function
         * @returns {String} A string representation of this point.
         */
        toString: function() {
          return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")";
        }
      };
    })(OpenSeadragon);
    (function($2) {
      $2.TileSource = function(width, height, tileSize, tileOverlap, minLevel, maxLevel) {
        var _this = this;
        var args = arguments, options, i;
        if ($2.isPlainObject(width)) {
          options = width;
        } else {
          options = {
            width: args[0],
            height: args[1],
            tileSize: args[2],
            tileOverlap: args[3],
            minLevel: args[4],
            maxLevel: args[5]
          };
        }
        $2.EventSource.call(this);
        $2.extend(true, this, options);
        if (!this.success) {
          for (i = 0; i < arguments.length; i++) {
            if ($2.isFunction(arguments[i])) {
              this.success = arguments[i];
              break;
            }
          }
        }
        if (this.success) {
          this.addHandler("ready", function(event) {
            _this.success(event);
          });
        }
        if ("string" == $2.type(arguments[0])) {
          this.url = arguments[0];
        }
        if (this.url) {
          this.aspectRatio = 1;
          this.dimensions = new $2.Point(10, 10);
          this._tileWidth = 0;
          this._tileHeight = 0;
          this.tileOverlap = 0;
          this.minLevel = 0;
          this.maxLevel = 0;
          this.ready = false;
          this.getImageInfo(this.url);
        } else {
          this.ready = true;
          this.aspectRatio = options.width && options.height ? options.width / options.height : 1;
          this.dimensions = new $2.Point(options.width, options.height);
          if (this.tileSize) {
            this._tileWidth = this._tileHeight = this.tileSize;
            delete this.tileSize;
          } else {
            if (this.tileWidth) {
              this._tileWidth = this.tileWidth;
              delete this.tileWidth;
            } else {
              this._tileWidth = 0;
            }
            if (this.tileHeight) {
              this._tileHeight = this.tileHeight;
              delete this.tileHeight;
            } else {
              this._tileHeight = 0;
            }
          }
          this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;
          this.minLevel = options.minLevel ? options.minLevel : 0;
          this.maxLevel = void 0 !== options.maxLevel && null !== options.maxLevel ? options.maxLevel : options.width && options.height ? Math.ceil(
            Math.log(Math.max(options.width, options.height)) / Math.log(2)
          ) : 0;
          if (this.success && $2.isFunction(this.success)) {
            this.success(this);
          }
        }
      };
      $2.TileSource.prototype = {
        getTileSize: function(level) {
          $2.console.error(
            "[TileSource.getTileSize] is deprecated. Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
          );
          return this._tileWidth;
        },
        /**
         * Return the tileWidth for a given level.
         * Subclasses should override this if tileWidth can be different at different levels
         *   such as in IIIFTileSource.  Code should use this function rather than reading
         *   from ._tileWidth directly.
         * @function
         * @param {Number} level
         */
        getTileWidth: function(level) {
          if (!this._tileWidth) {
            return this.getTileSize(level);
          }
          return this._tileWidth;
        },
        /**
         * Return the tileHeight for a given level.
         * Subclasses should override this if tileHeight can be different at different levels
         *   such as in IIIFTileSource.  Code should use this function rather than reading
         *   from ._tileHeight directly.
         * @function
         * @param {Number} level
         */
        getTileHeight: function(level) {
          if (!this._tileHeight) {
            return this.getTileSize(level);
          }
          return this._tileHeight;
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(level) {
          var levelScaleCache = {}, i;
          for (i = 0; i <= this.maxLevel; i++) {
            levelScaleCache[i] = 1 / Math.pow(2, this.maxLevel - i);
          }
          this.getLevelScale = function(_level) {
            return levelScaleCache[_level];
          };
          return this.getLevelScale(level);
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(level) {
          var scale = this.getLevelScale(level), x = Math.ceil(scale * this.dimensions.x / this.getTileWidth(level)), y = Math.ceil(scale * this.dimensions.y / this.getTileHeight(level));
          return new $2.Point(x, y);
        },
        /**
         * @function
         * @param {Number} level
         */
        getPixelRatio: function(level) {
          var imageSizeScaled = this.dimensions.times(this.getLevelScale(level)), rx = 1 / imageSizeScaled.x, ry = 1 / imageSizeScaled.y;
          return new $2.Point(rx, ry);
        },
        /**
         * @function
         * @returns {Number} The highest level in this tile source that can be contained in a single tile.
         */
        getClosestLevel: function() {
          var i, tiles;
          for (i = this.minLevel + 1; i <= this.maxLevel; i++) {
            tiles = this.getNumTiles(i);
            if (tiles.x > 1 || tiles.y > 1) {
              break;
            }
          }
          return i - 1;
        },
        /**
         * @function
         * @param {Number} level
         * @param {OpenSeadragon.Point} point
         */
        getTileAtPoint: function(level, point) {
          var validPoint = point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 / this.aspectRatio;
          $2.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
          var widthScaled = this.dimensions.x * this.getLevelScale(level);
          var pixelX = point.x * widthScaled;
          var pixelY = point.y * widthScaled;
          var x = Math.floor(pixelX / this.getTileWidth(level));
          var y = Math.floor(pixelY / this.getTileHeight(level));
          if (point.x >= 1) {
            x = this.getNumTiles(level).x - 1;
          }
          var EPSILON = 1e-15;
          if (point.y >= 1 / this.aspectRatio - EPSILON) {
            y = this.getNumTiles(level).y - 1;
          }
          return new $2.Point(x, y);
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
         * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
         * portion of the tile to use as the source of the drawing operation (in pixels), depending on
         * the isSource parameter.
         */
        getTileBounds: function(level, x, y, isSource) {
          var dimensionsScaled = this.dimensions.times(this.getLevelScale(level)), tileWidth = this.getTileWidth(level), tileHeight = this.getTileHeight(level), px = x === 0 ? 0 : tileWidth * x - this.tileOverlap, py = y === 0 ? 0 : tileHeight * y - this.tileOverlap, sx = tileWidth + (x === 0 ? 1 : 2) * this.tileOverlap, sy = tileHeight + (y === 0 ? 1 : 2) * this.tileOverlap, scale = 1 / dimensionsScaled.x;
          sx = Math.min(sx, dimensionsScaled.x - px);
          sy = Math.min(sy, dimensionsScaled.y - py);
          if (isSource) {
            return new $2.Rect(0, 0, sx, sy);
          }
          return new $2.Rect(px * scale, py * scale, sx * scale, sy * scale);
        },
        /**
         * Responsible for retrieving, and caching the
         * image metadata pertinent to this TileSources implementation.
         * @function
         * @param {String} url
         * @throws {Error}
         */
        getImageInfo: function(url) {
          var _this = this, callbackName, callback, readySource, options, urlParts, filename, lastDot;
          if (url) {
            urlParts = url.split("/");
            filename = urlParts[urlParts.length - 1];
            lastDot = filename.lastIndexOf(".");
            if (lastDot > -1) {
              urlParts[urlParts.length - 1] = filename.slice(0, lastDot);
            }
          }
          callback = function(data) {
            if (typeof data === "string") {
              data = $2.parseXml(data);
            }
            var $TileSource = $2.TileSource.determineType(_this, data, url);
            if (!$TileSource) {
              _this.raiseEvent("open-failed", { message: "Unable to load TileSource", source: url });
              return;
            }
            options = $TileSource.prototype.configure.apply(_this, [data, url]);
            if (options.ajaxWithCredentials === void 0) {
              options.ajaxWithCredentials = _this.ajaxWithCredentials;
            }
            readySource = new $TileSource(options);
            _this.ready = true;
            _this.raiseEvent("ready", { tileSource: readySource });
          };
          if (url.match(/\.js$/)) {
            callbackName = url.split("/").pop().replace(".js", "");
            $2.jsonp({
              url,
              async: false,
              callbackName,
              callback
            });
          } else {
            $2.makeAjaxRequest({
              url,
              withCredentials: this.ajaxWithCredentials,
              headers: this.ajaxHeaders,
              success: function(xhr) {
                var data = processResponse(xhr);
                callback(data);
              },
              error: function(xhr, exc) {
                var msg;
                try {
                  msg = "HTTP " + xhr.status + " attempting to load TileSource";
                } catch (e) {
                  var formattedExc;
                  if (typeof exc == "undefined" || !exc.toString) {
                    formattedExc = "Unknown error";
                  } else {
                    formattedExc = exc.toString();
                  }
                  msg = formattedExc + " attempting to load TileSource";
                }
                _this.raiseEvent("open-failed", {
                  message: msg,
                  source: url
                });
              }
            });
          }
        },
        /**
         * Responsible determining if a the particular TileSource supports the
         * data format ( and allowed to apply logic against the url the data was
         * loaded from, if any ). Overriding implementations are expected to do
         * something smart with data and / or url to determine support.  Also
         * understand that iteration order of TileSources is not guarunteed so
         * please make sure your data or url is expressive enough to ensure a simple
         * and sufficient mechanisim for clear determination.
         * @function
         * @param {String|Object|Array|Document} data
         * @param {String} url - the url the data was loaded
         *      from if any.
         * @return {Boolean}
         */
        supports: function(data, url) {
          return false;
        },
        /**
         * Responsible for parsing and configuring the
         * image metadata pertinent to this TileSources implementation.
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {String|Object|Array|Document} data
         * @param {String} url - the url the data was loaded
         *      from if any.
         * @return {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         * @throws {Error}
         */
        configure: function(data, url) {
          throw new Error("Method not implemented.");
        },
        /**
         * Responsible for retrieving the url which will return an image for the
         * region specified by the given x, y, and level components.
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @throws {Error}
         */
        getTileUrl: function(level, x, y) {
          throw new Error("Method not implemented.");
        },
        /**
         * Responsible for retrieving the headers which will be attached to the image request for the
         * region specified by the given x, y, and level components.
         * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
         * The headers returned here will override headers specified at the Viewer or TiledImage level.
         * Specifying a falsy value for a header will clear its existing value set at the Viewer or
         * TiledImage level (if any).
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {Object}
         */
        getTileAjaxHeaders: function(level, x, y) {
          return {};
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        tileExists: function(level, x, y) {
          var numTiles = this.getNumTiles(level);
          return level >= this.minLevel && level <= this.maxLevel && x >= 0 && y >= 0 && x < numTiles.x && y < numTiles.y;
        }
      };
      $2.extend(true, $2.TileSource.prototype, $2.EventSource.prototype);
      function processResponse(xhr) {
        var responseText = xhr.responseText, status = xhr.status, statusText, data;
        if (!xhr) {
          throw new Error($2.getString("Errors.Security"));
        } else if (xhr.status !== 200 && xhr.status !== 0) {
          status = xhr.status;
          statusText = status == 404 ? "Not Found" : xhr.statusText;
          throw new Error($2.getString("Errors.Status", status, statusText));
        }
        if (responseText.match(/\s*<.*/)) {
          try {
            data = xhr.responseXML && xhr.responseXML.documentElement ? xhr.responseXML : $2.parseXml(responseText);
          } catch (e) {
            data = xhr.responseText;
          }
        } else if (responseText.match(/\s*[\{\[].*/)) {
          try {
            data = $2.parseJSON(responseText);
          } catch (e) {
            data = responseText;
          }
        } else {
          data = responseText;
        }
        return data;
      }
      $2.TileSource.determineType = function(tileSource, data, url) {
        var property;
        for (property in OpenSeadragon) {
          if (property.match(/.+TileSource$/) && $2.isFunction(OpenSeadragon[property]) && $2.isFunction(OpenSeadragon[property].prototype.supports) && OpenSeadragon[property].prototype.supports.call(tileSource, data, url)) {
            return OpenSeadragon[property];
          }
        }
        $2.console.error("No TileSource was able to open %s %s", url, data);
      };
    })(OpenSeadragon);
    (function($2) {
      $2.DziTileSource = function(width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel) {
        var i, rect, level, options;
        if ($2.isPlainObject(width)) {
          options = width;
        } else {
          options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4],
            fileFormat: arguments[5],
            displayRects: arguments[6],
            minLevel: arguments[7],
            maxLevel: arguments[8]
          };
        }
        this._levelRects = {};
        this.tilesUrl = options.tilesUrl;
        this.fileFormat = options.fileFormat;
        this.displayRects = options.displayRects;
        if (this.displayRects) {
          for (i = this.displayRects.length - 1; i >= 0; i--) {
            rect = this.displayRects[i];
            for (level = rect.minLevel; level <= rect.maxLevel; level++) {
              if (!this._levelRects[level]) {
                this._levelRects[level] = [];
              }
              this._levelRects[level].push(rect);
            }
          }
        }
        $2.TileSource.apply(this, [options]);
      };
      $2.extend(
        $2.DziTileSource.prototype,
        $2.TileSource.prototype,
        /** @lends OpenSeadragon.DziTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            var ns;
            if (data.Image) {
              ns = data.Image.xmlns;
            } else if (data.documentElement) {
              if ("Image" == data.documentElement.localName || "Image" == data.documentElement.tagName) {
                ns = data.documentElement.namespaceURI;
              }
            }
            ns = (ns || "").toLowerCase();
            return ns.indexOf("schemas.microsoft.com/deepzoom/2008") !== -1 || ns.indexOf("schemas.microsoft.com/deepzoom/2009") !== -1;
          },
          /**
           *
           * @function
           * @param {Object|XMLDocument} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @return {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url) {
            var options;
            if (!$2.isPlainObject(data)) {
              options = configureFromXML(this, data);
            } else {
              options = configureFromObject(this, data);
            }
            if (url && !options.tilesUrl) {
              options.tilesUrl = url.replace(
                /([^\/]+?)(\.(dzi|xml|js)?(\?[^\/]*)?)?\/?$/,
                "$1_files/"
              );
              if (url.search(/\.(dzi|xml|js)\?/) != -1) {
                options.queryParams = url.match(/\?.*/);
              } else {
                options.queryParams = "";
              }
            }
            return options;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
            return [this.tilesUrl, level, "/", x, "_", y, ".", this.fileFormat, this.queryParams].join("");
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          tileExists: function(level, x, y) {
            var rects = this._levelRects[level], rect, scale, xMin, yMin, xMax, yMax, i;
            if (this.minLevel && level < this.minLevel || this.maxLevel && level > this.maxLevel) {
              return false;
            }
            if (!rects || !rects.length) {
              return true;
            }
            for (i = rects.length - 1; i >= 0; i--) {
              rect = rects[i];
              if (level < rect.minLevel || level > rect.maxLevel) {
                continue;
              }
              scale = this.getLevelScale(level);
              xMin = rect.x * scale;
              yMin = rect.y * scale;
              xMax = xMin + rect.width * scale;
              yMax = yMin + rect.height * scale;
              xMin = Math.floor(xMin / this._tileWidth);
              yMin = Math.floor(yMin / this._tileWidth);
              xMax = Math.ceil(xMax / this._tileWidth);
              yMax = Math.ceil(yMax / this._tileWidth);
              if (xMin <= x && x < xMax && yMin <= y && y < yMax) {
                return true;
              }
            }
            return false;
          }
        }
      );
      function configureFromXML(tileSource, xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) {
          throw new Error($2.getString("Errors.Xml"));
        }
        var root = xmlDoc.documentElement, rootName = root.localName || root.tagName, ns = xmlDoc.documentElement.namespaceURI, configuration = null, displayRects = [], dispRectNodes, dispRectNode, rectNode, sizeNode, i;
        if (rootName == "Image") {
          try {
            sizeNode = root.getElementsByTagName("Size")[0];
            if (sizeNode === void 0) {
              sizeNode = root.getElementsByTagNameNS(ns, "Size")[0];
            }
            configuration = {
              Image: {
                xmlns: "http://schemas.microsoft.com/deepzoom/2008",
                Url: root.getAttribute("Url"),
                Format: root.getAttribute("Format"),
                DisplayRect: null,
                Overlap: parseInt(root.getAttribute("Overlap"), 10),
                TileSize: parseInt(root.getAttribute("TileSize"), 10),
                Size: {
                  Height: parseInt(sizeNode.getAttribute("Height"), 10),
                  Width: parseInt(sizeNode.getAttribute("Width"), 10)
                }
              }
            };
            if (!$2.imageFormatSupported(configuration.Image.Format)) {
              throw new Error(
                $2.getString("Errors.ImageFormat", configuration.Image.Format.toUpperCase())
              );
            }
            dispRectNodes = root.getElementsByTagName("DisplayRect");
            if (dispRectNodes === void 0) {
              dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect")[0];
            }
            for (i = 0; i < dispRectNodes.length; i++) {
              dispRectNode = dispRectNodes[i];
              rectNode = dispRectNode.getElementsByTagName("Rect")[0];
              if (rectNode === void 0) {
                rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect")[0];
              }
              displayRects.push({
                Rect: {
                  X: parseInt(rectNode.getAttribute("X"), 10),
                  Y: parseInt(rectNode.getAttribute("Y"), 10),
                  Width: parseInt(rectNode.getAttribute("Width"), 10),
                  Height: parseInt(rectNode.getAttribute("Height"), 10),
                  MinLevel: parseInt(dispRectNode.getAttribute("MinLevel"), 10),
                  MaxLevel: parseInt(dispRectNode.getAttribute("MaxLevel"), 10)
                }
              });
            }
            if (displayRects.length) {
              configuration.Image.DisplayRect = displayRects;
            }
            return configureFromObject(tileSource, configuration);
          } catch (e) {
            throw e instanceof Error ? e : new Error($2.getString("Errors.Dzi"));
          }
        } else if (rootName == "Collection") {
          throw new Error($2.getString("Errors.Dzc"));
        } else if (rootName == "Error") {
          var messageNode = root.getElementsByTagName("Message")[0];
          var message = messageNode.firstChild.nodeValue;
          throw new Error(message);
        }
        throw new Error($2.getString("Errors.Dzi"));
      }
      function configureFromObject(tileSource, configuration) {
        var imageData = configuration.Image, tilesUrl = imageData.Url, fileFormat = imageData.Format, sizeData = imageData.Size, dispRectData = imageData.DisplayRect || [], width = parseInt(sizeData.Width, 10), height = parseInt(sizeData.Height, 10), tileSize = parseInt(imageData.TileSize, 10), tileOverlap = parseInt(imageData.Overlap, 10), displayRects = [], rectData, i;
        for (i = 0; i < dispRectData.length; i++) {
          rectData = dispRectData[i].Rect;
          displayRects.push(new $2.DisplayRect(
            parseInt(rectData.X, 10),
            parseInt(rectData.Y, 10),
            parseInt(rectData.Width, 10),
            parseInt(rectData.Height, 10),
            parseInt(rectData.MinLevel, 10),
            parseInt(rectData.MaxLevel, 10)
          ));
        }
        return $2.extend(true, {
          width,
          /* width *required */
          height,
          /* height *required */
          tileSize,
          /* tileSize *required */
          tileOverlap,
          /* tileOverlap *required */
          minLevel: null,
          /* minLevel */
          maxLevel: null,
          /* maxLevel */
          tilesUrl,
          /* tilesUrl */
          fileFormat,
          /* fileFormat */
          displayRects
          /* displayRects */
        }, configuration);
      }
    })(OpenSeadragon);
    (function($2) {
      $2.IIIFTileSource = function(options) {
        $2.extend(true, this, options);
        if (!(this.height && this.width && this["@id"])) {
          throw new Error("IIIF required parameters not provided.");
        }
        options.tileSizePerScaleFactor = {};
        this.tileFormat = this.tileFormat || "jpg";
        this.version = options.version;
        if (this.tile_width && this.tile_height) {
          options.tileWidth = this.tile_width;
          options.tileHeight = this.tile_height;
        } else if (this.tile_width) {
          options.tileSize = this.tile_width;
        } else if (this.tile_height) {
          options.tileSize = this.tile_height;
        } else if (this.tiles) {
          if (this.tiles.length == 1) {
            options.tileWidth = this.tiles[0].width;
            options.tileHeight = this.tiles[0].height || this.tiles[0].width;
            this.scale_factors = this.tiles[0].scaleFactors;
          } else {
            this.scale_factors = [];
            for (var t = 0; t < this.tiles.length; t++) {
              for (var sf = 0; sf < this.tiles[t].scaleFactors.length; sf++) {
                var scaleFactor = this.tiles[t].scaleFactors[sf];
                this.scale_factors.push(scaleFactor);
                options.tileSizePerScaleFactor[scaleFactor] = {
                  width: this.tiles[t].width,
                  height: this.tiles[t].height || this.tiles[t].width
                };
              }
            }
          }
        } else if (canBeTiled(options)) {
          var shortDim = Math.min(this.height, this.width), tileOptions = [256, 512, 1024], smallerTiles = [];
          for (var c = 0; c < tileOptions.length; c++) {
            if (tileOptions[c] <= shortDim) {
              smallerTiles.push(tileOptions[c]);
            }
          }
          if (smallerTiles.length > 0) {
            options.tileSize = Math.max.apply(null, smallerTiles);
          } else {
            options.tileSize = shortDim;
          }
        } else if (this.sizes && this.sizes.length > 0) {
          this.emulateLegacyImagePyramid = true;
          options.levels = constructLevels(this);
          $2.extend(true, options, {
            width: options.levels[options.levels.length - 1].width,
            height: options.levels[options.levels.length - 1].height,
            tileSize: Math.max(options.height, options.width),
            tileOverlap: 0,
            minLevel: 0,
            maxLevel: options.levels.length - 1
          });
          this.levels = options.levels;
        } else {
          $2.console.error("Nothing in the info.json to construct image pyramids from");
        }
        if (!options.maxLevel && !this.emulateLegacyImagePyramid) {
          if (!this.scale_factors) {
            options.maxLevel = Number(Math.ceil(Math.log(Math.max(this.width, this.height), 2)));
          } else {
            var maxScaleFactor = Math.max.apply(null, this.scale_factors);
            options.maxLevel = Math.round(Math.log(maxScaleFactor) * Math.LOG2E);
          }
        }
        $2.TileSource.apply(this, [options]);
      };
      $2.extend(
        $2.IIIFTileSource.prototype,
        $2.TileSource.prototype,
        /** @lends OpenSeadragon.IIIFTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            if (data.protocol && data.protocol == "http://iiif.io/api/image") {
              return true;
            } else if (data["@context"] && (data["@context"] == "http://library.stanford.edu/iiif/image-api/1.1/context.json" || data["@context"] == "http://iiif.io/api/image/1/context.json")) {
              return true;
            } else if (data.profile && data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {
              return true;
            } else if (data.identifier && data.width && data.height) {
              return true;
            } else if (data.documentElement && "info" == data.documentElement.tagName && "http://library.stanford.edu/iiif/image-api/ns/" == data.documentElement.namespaceURI) {
              return true;
            } else {
              return false;
            }
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @example <caption>IIIF 1.1 Info Looks like this</caption>
           * {
           *   "@context" : "http://library.stanford.edu/iiif/image-api/1.1/context.json",
           *   "@id" : "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
           *   "width" : 6000,
           *   "height" : 4000,
           *   "scale_factors" : [ 1, 2, 4 ],
           *   "tile_width" : 1024,
           *   "tile_height" : 1024,
           *   "formats" : [ "jpg", "png" ],
           *   "qualities" : [ "native", "grey" ],
           *   "profile" : "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0"
           * }
           */
          configure: function(data, url) {
            if (!$2.isPlainObject(data)) {
              var options = configureFromXml10(data);
              options["@context"] = "http://iiif.io/api/image/1.0/context.json";
              options["@id"] = url.replace("/info.xml", "");
              options.version = 1;
              return options;
            } else {
              if (!data["@context"]) {
                data["@context"] = "http://iiif.io/api/image/1.0/context.json";
                data["@id"] = url.replace("/info.json", "");
                data.version = 1;
              } else {
                var context = data["@context"];
                if (Array.isArray(context)) {
                  for (var i = 0; i < context.length; i++) {
                    if (typeof context[i] === "string" && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(context[i]) || context[i] === "http://library.stanford.edu/iiif/image-api/1.1/context.json")) {
                      context = context[i];
                      break;
                    }
                  }
                }
                switch (context) {
                  case "http://iiif.io/api/image/1/context.json":
                  case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                    data.version = 1;
                    break;
                  case "http://iiif.io/api/image/2/context.json":
                    data.version = 2;
                    break;
                  case "http://iiif.io/api/image/3/context.json":
                    data.version = 3;
                    break;
                  default:
                    $2.console.error("Data has a @context property which contains no known IIIF context URI.");
                }
              }
              if (!data["@id"] && data["id"]) {
                data["@id"] = data["id"];
              }
              if (data.preferredFormats) {
                for (var f = 0; f < data.preferredFormats.length; f++) {
                  if (OpenSeadragon.imageFormatSupported(data.preferredFormats[f])) {
                    data.tileFormat = data.preferredFormats[f];
                    break;
                  }
                }
              }
              return data;
            }
          },
          /**
           * Return the tileWidth for the given level.
           * @function
           * @param {Number} level
           */
          getTileWidth: function(level) {
            if (this.emulateLegacyImagePyramid) {
              return $2.TileSource.prototype.getTileWidth.call(this, level);
            }
            var scaleFactor = Math.pow(2, this.maxLevel - level);
            if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
              return this.tileSizePerScaleFactor[scaleFactor].width;
            }
            return this._tileWidth;
          },
          /**
           * Return the tileHeight for the given level.
           * @function
           * @param {Number} level
           */
          getTileHeight: function(level) {
            if (this.emulateLegacyImagePyramid) {
              return $2.TileSource.prototype.getTileHeight.call(this, level);
            }
            var scaleFactor = Math.pow(2, this.maxLevel - level);
            if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
              return this.tileSizePerScaleFactor[scaleFactor].height;
            }
            return this._tileHeight;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(level) {
            if (this.emulateLegacyImagePyramid) {
              var levelScale = NaN;
              if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
                levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
              }
              return levelScale;
            }
            return $2.TileSource.prototype.getLevelScale.call(this, level);
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(level) {
            if (this.emulateLegacyImagePyramid) {
              var scale = this.getLevelScale(level);
              if (scale) {
                return new $2.Point(1, 1);
              } else {
                return new $2.Point(0, 0);
              }
            }
            return $2.TileSource.prototype.getNumTiles.call(this, level);
          },
          /**
           * @function
           * @param {Number} level
           * @param {OpenSeadragon.Point} point
           */
          getTileAtPoint: function(level, point) {
            if (this.emulateLegacyImagePyramid) {
              return new $2.Point(0, 0);
            }
            return $2.TileSource.prototype.getTileAtPoint.call(this, level, point);
          },
          /**
           * Responsible for retrieving the url which will return an image for the
           * region specified by the given x, y, and level components.
           * @function
           * @param {Number} level - z index
           * @param {Number} x
           * @param {Number} y
           * @throws {Error}
           */
          getTileUrl: function(level, x, y) {
            if (this.emulateLegacyImagePyramid) {
              var url = null;
              if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
                url = this.levels[level].url;
              }
              return url;
            }
            var IIIF_ROTATION = "0", scale = Math.pow(0.5, this.maxLevel - level), levelWidth = Math.ceil(this.width * scale), levelHeight = Math.ceil(this.height * scale), tileWidth, tileHeight, iiifTileSizeWidth, iiifTileSizeHeight, iiifRegion, iiifTileX, iiifTileY, iiifTileW, iiifTileH, iiifSize, iiifSizeW, iiifSizeH, iiifQuality, uri;
            tileWidth = this.getTileWidth(level);
            tileHeight = this.getTileHeight(level);
            iiifTileSizeWidth = Math.ceil(tileWidth / scale);
            iiifTileSizeHeight = Math.ceil(tileHeight / scale);
            if (this.version === 1) {
              iiifQuality = "native." + this.tileFormat;
            } else {
              iiifQuality = "default." + this.tileFormat;
            }
            if (levelWidth < tileWidth && levelHeight < tileHeight) {
              if (this.version === 2 && levelWidth === this.width) {
                iiifSize = "max";
              } else if (this.version === 3 && levelWidth === this.width && levelHeight === this.height) {
                iiifSize = "max";
              } else if (this.version === 3) {
                iiifSize = levelWidth + "," + levelHeight;
              } else {
                iiifSize = levelWidth + ",";
              }
              iiifRegion = "full";
            } else {
              iiifTileX = x * iiifTileSizeWidth;
              iiifTileY = y * iiifTileSizeHeight;
              iiifTileW = Math.min(iiifTileSizeWidth, this.width - iiifTileX);
              iiifTileH = Math.min(iiifTileSizeHeight, this.height - iiifTileY);
              if (x === 0 && y === 0 && iiifTileW === this.width && iiifTileH === this.height) {
                iiifRegion = "full";
              } else {
                iiifRegion = [iiifTileX, iiifTileY, iiifTileW, iiifTileH].join(",");
              }
              iiifSizeW = Math.ceil(iiifTileW * scale);
              iiifSizeH = Math.ceil(iiifTileH * scale);
              if (this.version === 2 && iiifSizeW === this.width) {
                iiifSize = "max";
              } else if (this.version === 3 && iiifSizeW === this.width && iiifSizeH === this.height) {
                iiifSize = "max";
              } else if (this.version === 3) {
                iiifSize = iiifSizeW + "," + iiifSizeH;
              } else {
                iiifSize = iiifSizeW + ",";
              }
            }
            uri = [this["@id"], iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality].join("/");
            return uri;
          },
          __testonly__: {
            canBeTiled,
            constructLevels
          }
        }
      );
      function canBeTiled(options) {
        var level0Profiles = [
          "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
          "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
          "http://iiif.io/api/image/2/level0.json",
          "level0",
          "https://iiif.io/api/image/3/level0.json"
        ];
        var profileLevel = Array.isArray(options.profile) ? options.profile[0] : options.profile;
        var isLevel0 = level0Profiles.indexOf(profileLevel) !== -1;
        var hasCanoncicalSizeFeature = false;
        if (options.version === 2 && options.profile.length > 1 && options.profile[1].supports) {
          hasCanoncicalSizeFeature = options.profile[1].supports.indexOf("sizeByW") !== -1;
        }
        if (options.version === 3 && options.extraFeatures) {
          hasCanoncicalSizeFeature = options.extraFeatures.indexOf("sizeByWh") !== -1;
        }
        return !isLevel0 || hasCanoncicalSizeFeature;
      }
      function constructLevels(options) {
        var levels = [];
        for (var i = 0; i < options.sizes.length; i++) {
          levels.push({
            url: options["@id"] + "/full/" + options.sizes[i].width + "," + (options.version === 3 ? options.sizes[i].height : "") + "/0/default." + options.tileFormat,
            width: options.sizes[i].width,
            height: options.sizes[i].height
          });
        }
        return levels.sort(function(a, b) {
          return a.width - b.width;
        });
      }
      function configureFromXml10(xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) {
          throw new Error($2.getString("Errors.Xml"));
        }
        var root = xmlDoc.documentElement, rootName = root.tagName, configuration = null;
        if (rootName == "info") {
          try {
            configuration = {};
            parseXML10(root, configuration);
            return configuration;
          } catch (e) {
            throw e instanceof Error ? e : new Error($2.getString("Errors.IIIF"));
          }
        }
        throw new Error($2.getString("Errors.IIIF"));
      }
      function parseXML10(node, configuration, property) {
        var i, value;
        if (node.nodeType == 3 && property) {
          value = node.nodeValue.trim();
          if (value.match(/^\d*$/)) {
            value = Number(value);
          }
          if (!configuration[property]) {
            configuration[property] = value;
          } else {
            if (!$2.isArray(configuration[property])) {
              configuration[property] = [configuration[property]];
            }
            configuration[property].push(value);
          }
        } else if (node.nodeType == 1) {
          for (i = 0; i < node.childNodes.length; i++) {
            parseXML10(node.childNodes[i], configuration, node.nodeName);
          }
        }
      }
    })(OpenSeadragon);
    (function($2) {
      $2.OsmTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
        var options;
        if ($2.isPlainObject(width)) {
          options = width;
        } else {
          options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4]
          };
        }
        if (!options.width || !options.height) {
          options.width = 65572864;
          options.height = 65572864;
        }
        if (!options.tileSize) {
          options.tileSize = 256;
          options.tileOverlap = 0;
        }
        if (!options.tilesUrl) {
          options.tilesUrl = "http://tile.openstreetmap.org/";
        }
        options.minLevel = 8;
        $2.TileSource.apply(this, [options]);
      };
      $2.extend(
        $2.OsmTileSource.prototype,
        $2.TileSource.prototype,
        /** @lends OpenSeadragon.OsmTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && "openstreetmaps" == data.type;
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @return {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url) {
            return data;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
            return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png";
          }
        }
      );
    })(OpenSeadragon);
    (function($2) {
      $2.TmsTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
        var options;
        if ($2.isPlainObject(width)) {
          options = width;
        } else {
          options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4]
          };
        }
        var bufferedWidth = Math.ceil(options.width / 256) * 256, bufferedHeight = Math.ceil(options.height / 256) * 256, max;
        if (bufferedWidth > bufferedHeight) {
          max = bufferedWidth / 256;
        } else {
          max = bufferedHeight / 256;
        }
        options.maxLevel = Math.ceil(Math.log(max) / Math.log(2)) - 1;
        options.tileSize = 256;
        options.width = bufferedWidth;
        options.height = bufferedHeight;
        $2.TileSource.apply(this, [options]);
      };
      $2.extend(
        $2.TmsTileSource.prototype,
        $2.TileSource.prototype,
        /** @lends OpenSeadragon.TmsTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && "tiledmapservice" == data.type;
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @return {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url) {
            return data;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
            var yTiles = this.getNumTiles(level).y - 1;
            return this.tilesUrl + level + "/" + x + "/" + (yTiles - y) + ".png";
          }
        }
      );
    })(OpenSeadragon);
    (function($2) {
      $2.ZoomifyTileSource = function(options) {
        options.tileSize = 256;
        var currentImageSize = {
          x: options.width,
          y: options.height
        };
        options.imageSizes = [{
          x: options.width,
          y: options.height
        }];
        options.gridSize = [this._getGridSize(options.width, options.height, options.tileSize)];
        while (parseInt(currentImageSize.x, 10) > options.tileSize || parseInt(currentImageSize.y, 10) > options.tileSize) {
          currentImageSize.x = Math.floor(currentImageSize.x / 2);
          currentImageSize.y = Math.floor(currentImageSize.y / 2);
          options.imageSizes.push({
            x: currentImageSize.x,
            y: currentImageSize.y
          });
          options.gridSize.push(this._getGridSize(currentImageSize.x, currentImageSize.y, options.tileSize));
        }
        options.imageSizes.reverse();
        options.gridSize.reverse();
        options.minLevel = 0;
        options.maxLevel = options.gridSize.length - 1;
        OpenSeadragon.TileSource.apply(this, [options]);
      };
      $2.extend(
        $2.ZoomifyTileSource.prototype,
        $2.TileSource.prototype,
        /** @lends OpenSeadragon.ZoomifyTileSource.prototype */
        {
          //private
          _getGridSize: function(width, height, tileSize) {
            return {
              x: Math.ceil(width / tileSize),
              y: Math.ceil(height / tileSize)
            };
          },
          //private
          _calculateAbsoluteTileNumber: function(level, x, y) {
            var num = 0;
            var size = {};
            for (var z = 0; z < level; z++) {
              size = this.gridSize[z];
              num += size.x * size.y;
            }
            size = this.gridSize[level];
            num += size.x * y + x;
            return num;
          },
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && "zoomifytileservice" == data.type;
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @return {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url) {
            return data;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
            var result = 0;
            var num = this._calculateAbsoluteTileNumber(level, x, y);
            result = Math.floor(num / 256);
            return this.tilesUrl + "TileGroup" + result + "/" + level + "-" + x + "-" + y + ".jpg";
          }
        }
      );
    })(OpenSeadragon);
    (function($2) {
      $2.LegacyTileSource = function(levels) {
        var options, width, height;
        if ($2.isArray(levels)) {
          options = {
            type: "legacy-image-pyramid",
            levels
          };
        }
        options.levels = filterFiles(options.levels);
        if (options.levels.length > 0) {
          width = options.levels[options.levels.length - 1].width;
          height = options.levels[options.levels.length - 1].height;
        } else {
          width = 0;
          height = 0;
          $2.console.error("No supported image formats found");
        }
        $2.extend(true, options, {
          width,
          height,
          tileSize: Math.max(height, width),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0
        });
        $2.TileSource.apply(this, [options]);
        this.levels = options.levels;
      };
      $2.extend(
        $2.LegacyTileSource.prototype,
        $2.TileSource.prototype,
        /** @lends OpenSeadragon.LegacyTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && "legacy-image-pyramid" == data.type || data.documentElement && "legacy-image-pyramid" == data.documentElement.getAttribute("type");
          },
          /**
           *
           * @function
           * @param {Object|XMLDocument} configuration - the raw configuration
           * @param {String} dataUrl - the url the data was retrieved from if any.
           * @return {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(configuration, dataUrl) {
            var options;
            if (!$2.isPlainObject(configuration)) {
              options = configureFromXML(this, configuration);
            } else {
              options = configureFromObject(this, configuration);
            }
            return options;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(level) {
            var levelScale = NaN;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
              levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
            }
            return levelScale;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(level) {
            var scale = this.getLevelScale(level);
            if (scale) {
              return new $2.Point(1, 1);
            } else {
              return new $2.Point(0, 0);
            }
          },
          /**
           * This method is not implemented by this class other than to throw an Error
           * announcing you have to implement it.  Because of the variety of tile
           * server technologies, and various specifications for building image
           * pyramids, this method is here to allow easy integration.
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           * @throws {Error}
           */
          getTileUrl: function(level, x, y) {
            var url = null;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
              url = this.levels[level].url;
            }
            return url;
          }
        }
      );
      function filterFiles(files) {
        var filtered = [], file, i;
        for (i = 0; i < files.length; i++) {
          file = files[i];
          if (file.height && file.width && file.url) {
            filtered.push({
              url: file.url,
              width: Number(file.width),
              height: Number(file.height)
            });
          } else {
            $2.console.error("Unsupported image format: %s", file.url ? file.url : "<no URL>");
          }
        }
        return filtered.sort(function(a, b) {
          return a.height - b.height;
        });
      }
      function configureFromXML(tileSource, xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) {
          throw new Error($2.getString("Errors.Xml"));
        }
        var root = xmlDoc.documentElement, rootName = root.tagName, conf = null, levels = [], level, i;
        if (rootName == "image") {
          try {
            conf = {
              type: root.getAttribute("type"),
              levels: []
            };
            levels = root.getElementsByTagName("level");
            for (i = 0; i < levels.length; i++) {
              level = levels[i];
              conf.levels.push({
                url: level.getAttribute("url"),
                width: parseInt(level.getAttribute("width"), 10),
                height: parseInt(level.getAttribute("height"), 10)
              });
            }
            return configureFromObject(tileSource, conf);
          } catch (e) {
            throw e instanceof Error ? e : new Error("Unknown error parsing Legacy Image Pyramid XML.");
          }
        } else if (rootName == "collection") {
          throw new Error("Legacy Image Pyramid Collections not yet supported.");
        } else if (rootName == "error") {
          throw new Error("Error: " + xmlDoc);
        }
        throw new Error("Unknown element " + rootName);
      }
      function configureFromObject(tileSource, configuration) {
        return configuration.levels;
      }
    })(OpenSeadragon);
    (function($2) {
      $2.ImageTileSource = function(options) {
        options = $2.extend({
          buildPyramid: true,
          crossOriginPolicy: false,
          ajaxWithCredentials: false,
          useCanvas: true
        }, options);
        $2.TileSource.apply(this, [options]);
      };
      $2.extend(
        $2.ImageTileSource.prototype,
        $2.TileSource.prototype,
        /** @lends OpenSeadragon.ImageTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && data.type === "image";
          },
          /**
           *
           * @function
           * @param {Object} options - the options
           * @param {String} dataUrl - the url the image was retrieved from, if any.
           * @return {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(options, dataUrl) {
            return options;
          },
          /**
           * Responsible for retrieving, and caching the
           * image metadata pertinent to this TileSources implementation.
           * @function
           * @param {String} url
           * @throws {Error}
           */
          getImageInfo: function(url) {
            var image = this._image = new Image();
            var _this = this;
            if (this.crossOriginPolicy) {
              image.crossOrigin = this.crossOriginPolicy;
            }
            if (this.ajaxWithCredentials) {
              image.useCredentials = this.ajaxWithCredentials;
            }
            $2.addEvent(image, "load", function() {
              _this.width = Object.prototype.hasOwnProperty.call(image, "naturalWidth") ? image.naturalWidth : image.width;
              _this.height = Object.prototype.hasOwnProperty.call(image, "naturalHeight") ? image.naturalHeight : image.height;
              _this.aspectRatio = _this.width / _this.height;
              _this.dimensions = new $2.Point(_this.width, _this.height);
              _this._tileWidth = _this.width;
              _this._tileHeight = _this.height;
              _this.tileOverlap = 0;
              _this.minLevel = 0;
              _this.levels = _this._buildLevels();
              _this.maxLevel = _this.levels.length - 1;
              _this.ready = true;
              _this.raiseEvent("ready", { tileSource: _this });
            });
            $2.addEvent(image, "error", function() {
              _this.raiseEvent("open-failed", {
                message: "Error loading image at " + url,
                source: url
              });
            });
            image.src = url;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(level) {
            var levelScale = NaN;
            if (level >= this.minLevel && level <= this.maxLevel) {
              levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
            }
            return levelScale;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(level) {
            var scale = this.getLevelScale(level);
            if (scale) {
              return new $2.Point(1, 1);
            } else {
              return new $2.Point(0, 0);
            }
          },
          /**
           * Retrieves a tile url
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getTileUrl: function(level, x, y) {
            var url = null;
            if (level >= this.minLevel && level <= this.maxLevel) {
              url = this.levels[level].url;
            }
            return url;
          },
          /**
           * Retrieves a tile context 2D
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getContext2D: function(level, x, y) {
            var context = null;
            if (level >= this.minLevel && level <= this.maxLevel) {
              context = this.levels[level].context2D;
            }
            return context;
          },
          // private
          //
          // Builds the different levels of the pyramid if possible
          // (i.e. if canvas API enabled and no canvas tainting issue).
          _buildLevels: function() {
            var levels = [{
              url: this._image.src,
              /* IE8 fix since it has no naturalWidth and naturalHeight */
              width: Object.prototype.hasOwnProperty.call(this._image, "naturalWidth") ? this._image.naturalWidth : this._image.width,
              height: Object.prototype.hasOwnProperty.call(this._image, "naturalHeight") ? this._image.naturalHeight : this._image.height
            }];
            if (!this.buildPyramid || !$2.supportsCanvas || !this.useCanvas) {
              delete this._image;
              return levels;
            }
            var currentWidth = Object.prototype.hasOwnProperty.call(this._image, "naturalWidth") ? this._image.naturalWidth : this._image.width;
            var currentHeight = Object.prototype.hasOwnProperty.call(this._image, "naturalHeight") ? this._image.naturalHeight : this._image.height;
            var bigCanvas = document.createElement("canvas");
            var bigContext = bigCanvas.getContext("2d");
            bigCanvas.width = currentWidth;
            bigCanvas.height = currentHeight;
            bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);
            levels[0].context2D = bigContext;
            delete this._image;
            if ($2.isCanvasTainted(bigCanvas)) {
              return levels;
            }
            while (currentWidth >= 2 && currentHeight >= 2) {
              currentWidth = Math.floor(currentWidth / 2);
              currentHeight = Math.floor(currentHeight / 2);
              var smallCanvas = document.createElement("canvas");
              var smallContext = smallCanvas.getContext("2d");
              smallCanvas.width = currentWidth;
              smallCanvas.height = currentHeight;
              smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);
              levels.splice(0, 0, {
                context2D: smallContext,
                width: currentWidth,
                height: currentHeight
              });
              bigCanvas = smallCanvas;
              bigContext = smallContext;
            }
            return levels;
          }
        }
      );
    })(OpenSeadragon);
    (function($2) {
      $2.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
        $2.console.error("TileSourceCollection is deprecated; use World instead");
      };
    })(OpenSeadragon);
    (function($2) {
      $2.ButtonState = {
        REST: 0,
        GROUP: 1,
        HOVER: 2,
        DOWN: 3
      };
      $2.Button = function(options) {
        var _this = this;
        $2.EventSource.call(this);
        $2.extend(true, this, {
          tooltip: null,
          srcRest: null,
          srcGroup: null,
          srcHover: null,
          srcDown: null,
          clickTimeThreshold: $2.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: $2.DEFAULT_SETTINGS.clickDistThreshold,
          /**
           * How long to wait before fading.
           * @member {Number} fadeDelay
           * @memberof OpenSeadragon.Button#
           */
          fadeDelay: 0,
          /**
           * How long should it take to fade the button.
           * @member {Number} fadeLength
           * @memberof OpenSeadragon.Button#
           */
          fadeLength: 2e3,
          onPress: null,
          onRelease: null,
          onClick: null,
          onEnter: null,
          onExit: null,
          onFocus: null,
          onBlur: null
        }, options);
        this.element = options.element || $2.makeNeutralElement("div");
        if (!options.element) {
          this.imgRest = $2.makeTransparentImage(this.srcRest);
          this.imgGroup = $2.makeTransparentImage(this.srcGroup);
          this.imgHover = $2.makeTransparentImage(this.srcHover);
          this.imgDown = $2.makeTransparentImage(this.srcDown);
          this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip;
          this.element.style.position = "relative";
          $2.setElementTouchActionNone(this.element);
          this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute";
          this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px";
          this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px";
          this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden";
          if ($2.Browser.vendor == $2.BROWSERS.FIREFOX && $2.Browser.version < 3) {
            this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "";
          }
          this.element.appendChild(this.imgRest);
          this.element.appendChild(this.imgGroup);
          this.element.appendChild(this.imgHover);
          this.element.appendChild(this.imgDown);
        }
        this.addHandler("press", this.onPress);
        this.addHandler("release", this.onRelease);
        this.addHandler("click", this.onClick);
        this.addHandler("enter", this.onEnter);
        this.addHandler("exit", this.onExit);
        this.addHandler("focus", this.onFocus);
        this.addHandler("blur", this.onBlur);
        this.currentState = $2.ButtonState.GROUP;
        this.fadeBeginTime = null;
        this.shouldFade = false;
        this.element.style.display = "inline-block";
        this.element.style.position = "relative";
        this.element.title = this.tooltip;
        this.tracker = new $2.MouseTracker({
          element: this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function(event) {
            if (event.insideElementPressed) {
              inTo(_this, $2.ButtonState.DOWN);
              _this.raiseEvent("enter", { originalEvent: event.originalEvent });
            } else if (!event.buttonDownAny) {
              inTo(_this, $2.ButtonState.HOVER);
            }
          },
          focusHandler: function(event) {
            this.enterHandler(event);
            _this.raiseEvent("focus", { originalEvent: event.originalEvent });
          },
          exitHandler: function(event) {
            outTo(_this, $2.ButtonState.GROUP);
            if (event.insideElementPressed) {
              _this.raiseEvent("exit", { originalEvent: event.originalEvent });
            }
          },
          blurHandler: function(event) {
            this.exitHandler(event);
            _this.raiseEvent("blur", { originalEvent: event.originalEvent });
          },
          pressHandler: function(event) {
            inTo(_this, $2.ButtonState.DOWN);
            _this.raiseEvent("press", { originalEvent: event.originalEvent });
          },
          releaseHandler: function(event) {
            if (event.insideElementPressed && event.insideElementReleased) {
              outTo(_this, $2.ButtonState.HOVER);
              _this.raiseEvent("release", { originalEvent: event.originalEvent });
            } else if (event.insideElementPressed) {
              outTo(_this, $2.ButtonState.GROUP);
            } else {
              inTo(_this, $2.ButtonState.HOVER);
            }
          },
          clickHandler: function(event) {
            if (event.quick) {
              _this.raiseEvent("click", { originalEvent: event.originalEvent });
            }
          },
          keyHandler: function(event) {
            if (13 === event.keyCode) {
              _this.raiseEvent("click", { originalEvent: event.originalEvent });
              _this.raiseEvent("release", { originalEvent: event.originalEvent });
              return false;
            }
            return true;
          }
        });
        outTo(this, $2.ButtonState.REST);
      };
      $2.extend(
        $2.Button.prototype,
        $2.EventSource.prototype,
        /** @lends OpenSeadragon.Button.prototype */
        {
          /**
           * TODO: Determine what this function is intended to do and if it's actually
           * useful as an API point.
           * @function
           */
          notifyGroupEnter: function() {
            inTo(this, $2.ButtonState.GROUP);
          },
          /**
           * TODO: Determine what this function is intended to do and if it's actually
           * useful as an API point.
           * @function
           */
          notifyGroupExit: function() {
            outTo(this, $2.ButtonState.REST);
          },
          /**
           * @function
           */
          disable: function() {
            this.notifyGroupExit();
            this.element.disabled = true;
            $2.setElementOpacity(this.element, 0.2, true);
          },
          /**
           * @function
           */
          enable: function() {
            this.element.disabled = false;
            $2.setElementOpacity(this.element, 1, true);
            this.notifyGroupEnter();
          }
        }
      );
      function scheduleFade(button) {
        $2.requestAnimationFrame(function() {
          updateFade(button);
        });
      }
      function updateFade(button) {
        var currentTime, deltaTime, opacity;
        if (button.shouldFade) {
          currentTime = $2.now();
          deltaTime = currentTime - button.fadeBeginTime;
          opacity = 1 - deltaTime / button.fadeLength;
          opacity = Math.min(1, opacity);
          opacity = Math.max(0, opacity);
          if (button.imgGroup) {
            $2.setElementOpacity(button.imgGroup, opacity, true);
          }
          if (opacity > 0) {
            scheduleFade(button);
          }
        }
      }
      function beginFading(button) {
        button.shouldFade = true;
        button.fadeBeginTime = $2.now() + button.fadeDelay;
        window.setTimeout(function() {
          scheduleFade(button);
        }, button.fadeDelay);
      }
      function stopFading(button) {
        button.shouldFade = false;
        if (button.imgGroup) {
          $2.setElementOpacity(button.imgGroup, 1, true);
        }
      }
      function inTo(button, newState) {
        if (button.element.disabled) {
          return;
        }
        if (newState >= $2.ButtonState.GROUP && button.currentState == $2.ButtonState.REST) {
          stopFading(button);
          button.currentState = $2.ButtonState.GROUP;
        }
        if (newState >= $2.ButtonState.HOVER && button.currentState == $2.ButtonState.GROUP) {
          if (button.imgHover) {
            button.imgHover.style.visibility = "";
          }
          button.currentState = $2.ButtonState.HOVER;
        }
        if (newState >= $2.ButtonState.DOWN && button.currentState == $2.ButtonState.HOVER) {
          if (button.imgDown) {
            button.imgDown.style.visibility = "";
          }
          button.currentState = $2.ButtonState.DOWN;
        }
      }
      function outTo(button, newState) {
        if (button.element.disabled) {
          return;
        }
        if (newState <= $2.ButtonState.HOVER && button.currentState == $2.ButtonState.DOWN) {
          if (button.imgDown) {
            button.imgDown.style.visibility = "hidden";
          }
          button.currentState = $2.ButtonState.HOVER;
        }
        if (newState <= $2.ButtonState.GROUP && button.currentState == $2.ButtonState.HOVER) {
          if (button.imgHover) {
            button.imgHover.style.visibility = "hidden";
          }
          button.currentState = $2.ButtonState.GROUP;
        }
        if (newState <= $2.ButtonState.REST && button.currentState == $2.ButtonState.GROUP) {
          beginFading(button);
          button.currentState = $2.ButtonState.REST;
        }
      }
    })(OpenSeadragon);
    (function($2) {
      $2.ButtonGroup = function(options) {
        $2.extend(true, this, {
          /**
           * An array containing the buttons themselves.
           * @member {Array} buttons
           * @memberof OpenSeadragon.ButtonGroup#
           */
          buttons: [],
          clickTimeThreshold: $2.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: $2.DEFAULT_SETTINGS.clickDistThreshold,
          labelText: ""
        }, options);
        var buttons = this.buttons.concat([]), _this = this, i;
        this.element = options.element || $2.makeNeutralElement("div");
        if (!options.group) {
          this.element.style.display = "inline-block";
          for (i = 0; i < buttons.length; i++) {
            this.element.appendChild(buttons[i].element);
          }
        }
        $2.setElementTouchActionNone(this.element);
        this.tracker = new $2.MouseTracker({
          element: this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function(event) {
            var i2;
            for (i2 = 0; i2 < _this.buttons.length; i2++) {
              _this.buttons[i2].notifyGroupEnter();
            }
          },
          exitHandler: function(event) {
            var i2;
            if (!event.insideElementPressed) {
              for (i2 = 0; i2 < _this.buttons.length; i2++) {
                _this.buttons[i2].notifyGroupExit();
              }
            }
          }
        });
      };
      $2.ButtonGroup.prototype = {
        /**
         * TODO: Figure out why this is used on the public API and if a more useful
         * api can be created.
         * @function
         * @private
         */
        emulateEnter: function() {
          this.tracker.enterHandler({ eventSource: this.tracker });
        },
        /**
         * TODO: Figure out why this is used on the public API and if a more useful
         * api can be created.
         * @function
         * @private
         */
        emulateExit: function() {
          this.tracker.exitHandler({ eventSource: this.tracker });
        }
      };
    })(OpenSeadragon);
    (function($2) {
      $2.Rect = function(x, y, width, height, degrees) {
        this.x = typeof x === "number" ? x : 0;
        this.y = typeof y === "number" ? y : 0;
        this.width = typeof width === "number" ? width : 0;
        this.height = typeof height === "number" ? height : 0;
        this.degrees = typeof degrees === "number" ? degrees : 0;
        this.degrees = $2.positiveModulo(this.degrees, 360);
        var newTopLeft, newWidth;
        if (this.degrees >= 270) {
          newTopLeft = this.getTopRight();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          newWidth = this.height;
          this.height = this.width;
          this.width = newWidth;
          this.degrees -= 270;
        } else if (this.degrees >= 180) {
          newTopLeft = this.getBottomRight();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          this.degrees -= 180;
        } else if (this.degrees >= 90) {
          newTopLeft = this.getBottomLeft();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          newWidth = this.height;
          this.height = this.width;
          this.width = newWidth;
          this.degrees -= 90;
        }
      };
      $2.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {
        var width = topLeft.distanceTo(topRight);
        var height = topLeft.distanceTo(bottomLeft);
        var diff = topRight.minus(topLeft);
        var radians = Math.atan(diff.y / diff.x);
        if (diff.x < 0) {
          radians += Math.PI;
        } else if (diff.y < 0) {
          radians += 2 * Math.PI;
        }
        return new $2.Rect(
          topLeft.x,
          topLeft.y,
          width,
          height,
          radians / Math.PI * 180
        );
      };
      $2.Rect.prototype = {
        /**
         * @function
         * @returns {OpenSeadragon.Rect} a duplicate of this Rect
         */
        clone: function() {
          return new $2.Rect(
            this.x,
            this.y,
            this.width,
            this.height,
            this.degrees
          );
        },
        /**
         * The aspect ratio is simply the ratio of width to height.
         * @function
         * @returns {Number} The ratio of width to height.
         */
        getAspectRatio: function() {
          return this.width / this.height;
        },
        /**
         * Provides the coordinates of the upper-left corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
         *  the rectangle.
         */
        getTopLeft: function() {
          return new $2.Point(
            this.x,
            this.y
          );
        },
        /**
         * Provides the coordinates of the bottom-right corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
         *  the rectangle.
         */
        getBottomRight: function() {
          return new $2.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Provides the coordinates of the top-right corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
         *  the rectangle.
         */
        getTopRight: function() {
          return new $2.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Provides the coordinates of the bottom-left corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
         *  the rectangle.
         */
        getBottomLeft: function() {
          return new $2.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Computes the center of the rectangle.
         * @function
         * @returns {OpenSeadragon.Point} The center of the rectangle as represented
         *  as represented by a 2-dimensional vector (x,y)
         */
        getCenter: function() {
          return new $2.Point(
            this.x + this.width / 2,
            this.y + this.height / 2
          ).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Returns the width and height component as a vector OpenSeadragon.Point
         * @function
         * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
         *  the width and height of the rectangle.
         */
        getSize: function() {
          return new $2.Point(this.width, this.height);
        },
        /**
         * Determines if two Rectangles have equivalent components.
         * @function
         * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
         * @return {Boolean} 'true' if all components are equal, otherwise 'false'.
         */
        equals: function(other) {
          return other instanceof $2.Rect && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height && this.degrees === other.degrees;
        },
        /**
        * Multiply all dimensions (except degrees) in this Rect by a factor and
        * return a new Rect.
        * @function
        * @param {Number} factor The factor to multiply vector components.
        * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
        *  of the vector components by the factor
        */
        times: function(factor) {
          return new $2.Rect(
            this.x * factor,
            this.y * factor,
            this.width * factor,
            this.height * factor,
            this.degrees
          );
        },
        /**
        * Translate/move this Rect by a vector and return new Rect.
        * @function
        * @param {OpenSeadragon.Point} delta The translation vector.
        * @returns {OpenSeadragon.Rect} A new rect with altered position
        */
        translate: function(delta) {
          return new $2.Rect(
            this.x + delta.x,
            this.y + delta.y,
            this.width,
            this.height,
            this.degrees
          );
        },
        /**
         * Returns the smallest rectangle that will contain this and the given
         * rectangle bounding boxes.
         * @param {OpenSeadragon.Rect} rect
         * @return {OpenSeadragon.Rect} The new rectangle.
         */
        union: function(rect) {
          var thisBoundingBox = this.getBoundingBox();
          var otherBoundingBox = rect.getBoundingBox();
          var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);
          var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);
          var right = Math.max(
            thisBoundingBox.x + thisBoundingBox.width,
            otherBoundingBox.x + otherBoundingBox.width
          );
          var bottom = Math.max(
            thisBoundingBox.y + thisBoundingBox.height,
            otherBoundingBox.y + otherBoundingBox.height
          );
          return new $2.Rect(
            left,
            top,
            right - left,
            bottom - top
          );
        },
        /**
         * Returns the bounding box of the intersection of this rectangle with the
         * given rectangle.
         * @param {OpenSeadragon.Rect} rect
         * @return {OpenSeadragon.Rect} the bounding box of the intersection
         * or null if the rectangles don't intersect.
         */
        intersection: function(rect) {
          var EPSILON = 1e-10;
          var intersectionPoints = [];
          var thisTopLeft = this.getTopLeft();
          if (rect.containsPoint(thisTopLeft, EPSILON)) {
            intersectionPoints.push(thisTopLeft);
          }
          var thisTopRight = this.getTopRight();
          if (rect.containsPoint(thisTopRight, EPSILON)) {
            intersectionPoints.push(thisTopRight);
          }
          var thisBottomLeft = this.getBottomLeft();
          if (rect.containsPoint(thisBottomLeft, EPSILON)) {
            intersectionPoints.push(thisBottomLeft);
          }
          var thisBottomRight = this.getBottomRight();
          if (rect.containsPoint(thisBottomRight, EPSILON)) {
            intersectionPoints.push(thisBottomRight);
          }
          var rectTopLeft = rect.getTopLeft();
          if (this.containsPoint(rectTopLeft, EPSILON)) {
            intersectionPoints.push(rectTopLeft);
          }
          var rectTopRight = rect.getTopRight();
          if (this.containsPoint(rectTopRight, EPSILON)) {
            intersectionPoints.push(rectTopRight);
          }
          var rectBottomLeft = rect.getBottomLeft();
          if (this.containsPoint(rectBottomLeft, EPSILON)) {
            intersectionPoints.push(rectBottomLeft);
          }
          var rectBottomRight = rect.getBottomRight();
          if (this.containsPoint(rectBottomRight, EPSILON)) {
            intersectionPoints.push(rectBottomRight);
          }
          var thisSegments = this._getSegments();
          var rectSegments = rect._getSegments();
          for (var i = 0; i < thisSegments.length; i++) {
            var thisSegment = thisSegments[i];
            for (var j = 0; j < rectSegments.length; j++) {
              var rectSegment = rectSegments[j];
              var intersect = getIntersection(
                thisSegment[0],
                thisSegment[1],
                rectSegment[0],
                rectSegment[1]
              );
              if (intersect) {
                intersectionPoints.push(intersect);
              }
            }
          }
          function getIntersection(a, b, c, d) {
            var abVector = b.minus(a);
            var cdVector = d.minus(c);
            var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;
            if (denom === 0) {
              return null;
            }
            var s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;
            var t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;
            if (-EPSILON <= s && s <= 1 - EPSILON && -EPSILON <= t && t <= 1 - EPSILON) {
              return new $2.Point(a.x + t * abVector.x, a.y + t * abVector.y);
            }
            return null;
          }
          if (intersectionPoints.length === 0) {
            return null;
          }
          var minX = intersectionPoints[0].x;
          var maxX = intersectionPoints[0].x;
          var minY = intersectionPoints[0].y;
          var maxY = intersectionPoints[0].y;
          for (var k = 1; k < intersectionPoints.length; k++) {
            var point = intersectionPoints[k];
            if (point.x < minX) {
              minX = point.x;
            }
            if (point.x > maxX) {
              maxX = point.x;
            }
            if (point.y < minY) {
              minY = point.y;
            }
            if (point.y > maxY) {
              maxY = point.y;
            }
          }
          return new $2.Rect(minX, minY, maxX - minX, maxY - minY);
        },
        // private
        _getSegments: function() {
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var bottomRight = this.getBottomRight();
          return [
            [topLeft, topRight],
            [topRight, bottomRight],
            [bottomRight, bottomLeft],
            [bottomLeft, topLeft]
          ];
        },
        /**
         * Rotates a rectangle around a point.
         * @function
         * @param {Number} degrees The angle in degrees to rotate.
         * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
         * Defaults to the center of the rectangle.
         * @return {OpenSeadragon.Rect}
         */
        rotate: function(degrees, pivot) {
          degrees = $2.positiveModulo(degrees, 360);
          if (degrees === 0) {
            return this.clone();
          }
          pivot = pivot || this.getCenter();
          var newTopLeft = this.getTopLeft().rotate(degrees, pivot);
          var newTopRight = this.getTopRight().rotate(degrees, pivot);
          var diff = newTopRight.minus(newTopLeft);
          diff = diff.apply(function(x) {
            var EPSILON = 1e-15;
            return Math.abs(x) < EPSILON ? 0 : x;
          });
          var radians = Math.atan(diff.y / diff.x);
          if (diff.x < 0) {
            radians += Math.PI;
          } else if (diff.y < 0) {
            radians += 2 * Math.PI;
          }
          return new $2.Rect(
            newTopLeft.x,
            newTopLeft.y,
            this.width,
            this.height,
            radians / Math.PI * 180
          );
        },
        /**
         * Retrieves the smallest horizontal (degrees=0) rectangle which contains
         * this rectangle.
         * @returns {OpenSeadragon.Rect}
         */
        getBoundingBox: function() {
          if (this.degrees === 0) {
            return this.clone();
          }
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var bottomRight = this.getBottomRight();
          var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
          var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
          var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
          var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
          return new $2.Rect(
            minX,
            minY,
            maxX - minX,
            maxY - minY
          );
        },
        /**
         * Retrieves the smallest horizontal (degrees=0) rectangle which contains
         * this rectangle and has integers x, y, width and height
         * @returns {OpenSeadragon.Rect}
         */
        getIntegerBoundingBox: function() {
          var boundingBox = this.getBoundingBox();
          var x = Math.floor(boundingBox.x);
          var y = Math.floor(boundingBox.y);
          var width = Math.ceil(boundingBox.width + boundingBox.x - x);
          var height = Math.ceil(boundingBox.height + boundingBox.y - y);
          return new $2.Rect(x, y, width, height);
        },
        /**
         * Determines whether a point is inside this rectangle (edge included).
         * @function
         * @param {OpenSeadragon.Point} point
         * @param {Number} [epsilon=0] the margin of error allowed
         * @returns {Boolean} true if the point is inside this rectangle, false
         * otherwise.
         */
        containsPoint: function(point, epsilon) {
          epsilon = epsilon || 0;
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var topDiff = topRight.minus(topLeft);
          var leftDiff = bottomLeft.minus(topLeft);
          return (point.x - topLeft.x) * topDiff.x + (point.y - topLeft.y) * topDiff.y >= -epsilon && (point.x - topRight.x) * topDiff.x + (point.y - topRight.y) * topDiff.y <= epsilon && (point.x - topLeft.x) * leftDiff.x + (point.y - topLeft.y) * leftDiff.y >= -epsilon && (point.x - bottomLeft.x) * leftDiff.x + (point.y - bottomLeft.y) * leftDiff.y <= epsilon;
        },
        /**
         * Provides a string representation of the rectangle which is useful for
         * debugging.
         * @function
         * @returns {String} A string representation of the rectangle.
         */
        toString: function() {
          return "[" + Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100 + ", " + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + ", " + Math.round(this.degrees * 100) / 100 + "deg]";
        }
      };
    })(OpenSeadragon);
    (function($2) {
      var THIS = {};
      $2.ReferenceStrip = function(options) {
        var _this = this, viewer = options.viewer, viewerSize = $2.getElementSize(viewer.element), element, style, i;
        if (!options.id) {
          options.id = "referencestrip-" + $2.now();
          this.element = $2.makeNeutralElement("div");
          this.element.id = options.id;
          this.element.className = "referencestrip";
        }
        options = $2.extend(true, {
          sizeRatio: $2.DEFAULT_SETTINGS.referenceStripSizeRatio,
          position: $2.DEFAULT_SETTINGS.referenceStripPosition,
          scroll: $2.DEFAULT_SETTINGS.referenceStripScroll,
          clickTimeThreshold: $2.DEFAULT_SETTINGS.clickTimeThreshold
        }, options, {
          //required overrides
          element: this.element,
          //These need to be overridden to prevent recursion since
          //the navigator is a viewer and a viewer has a navigator
          showNavigator: false,
          mouseNavEnabled: false,
          showNavigationControl: false,
          showSequenceControl: false
        });
        $2.extend(this, options);
        THIS[this.id] = {
          "animating": false
        };
        this.minPixelRatio = this.viewer.minPixelRatio;
        style = this.element.style;
        style.marginTop = "0px";
        style.marginRight = "0px";
        style.marginBottom = "0px";
        style.marginLeft = "0px";
        style.left = "0px";
        style.bottom = "0px";
        style.border = "0px";
        style.background = "#000";
        style.position = "relative";
        $2.setElementTouchActionNone(this.element);
        $2.setElementOpacity(this.element, 0.8);
        this.viewer = viewer;
        this.innerTracker = new $2.MouseTracker({
          element: this.element,
          dragHandler: $2.delegate(this, onStripDrag),
          scrollHandler: $2.delegate(this, onStripScroll),
          enterHandler: $2.delegate(this, onStripEnter),
          exitHandler: $2.delegate(this, onStripExit),
          keyDownHandler: $2.delegate(this, onKeyDown),
          keyHandler: $2.delegate(this, onKeyPress)
        });
        if (options.width && options.height) {
          this.element.style.width = options.width + "px";
          this.element.style.height = options.height + "px";
          viewer.addControl(
            this.element,
            { anchor: $2.ControlAnchor.BOTTOM_LEFT }
          );
        } else {
          if ("horizontal" == options.scroll) {
            this.element.style.width = viewerSize.x * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
            this.element.style.height = viewerSize.y * options.sizeRatio + "px";
            viewer.addControl(
              this.element,
              { anchor: $2.ControlAnchor.BOTTOM_LEFT }
            );
          } else {
            this.element.style.height = viewerSize.y * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
            this.element.style.width = viewerSize.x * options.sizeRatio + "px";
            viewer.addControl(
              this.element,
              { anchor: $2.ControlAnchor.TOP_LEFT }
            );
          }
        }
        this.panelWidth = viewerSize.x * this.sizeRatio + 8;
        this.panelHeight = viewerSize.y * this.sizeRatio + 8;
        this.panels = [];
        this.miniViewers = {};
        for (i = 0; i < viewer.tileSources.length; i++) {
          element = $2.makeNeutralElement("div");
          element.id = this.element.id + "-" + i;
          element.style.width = _this.panelWidth + "px";
          element.style.height = _this.panelHeight + "px";
          element.style.display = "inline";
          element.style.float = "left";
          element.style.cssFloat = "left";
          element.style.styleFloat = "left";
          element.style.padding = "2px";
          $2.setElementTouchActionNone(element);
          element.innerTracker = new $2.MouseTracker({
            element,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            pressHandler: function(event) {
              event.eventSource.dragging = $2.now();
            },
            releaseHandler: function(event) {
              var tracker = event.eventSource, id = tracker.element.id, page = Number(id.split("-")[2]), now = $2.now();
              if (event.insideElementPressed && event.insideElementReleased && tracker.dragging && now - tracker.dragging < tracker.clickTimeThreshold) {
                tracker.dragging = null;
                viewer.goToPage(page);
              }
            }
          });
          this.element.appendChild(element);
          element.activePanel = false;
          this.panels.push(element);
        }
        loadPanels(this, this.scroll == "vertical" ? viewerSize.y : viewerSize.x, 0);
        this.setFocus(0);
      };
      $2.extend(
        $2.ReferenceStrip.prototype,
        $2.EventSource.prototype,
        $2.Viewer.prototype,
        /** @lends OpenSeadragon.ReferenceStrip.prototype */
        {
          /**
           * @function
           */
          setFocus: function(page) {
            var element = this.element.querySelector("#" + this.element.id + "-" + page), viewerSize = $2.getElementSize(this.viewer.canvas), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), offsetLeft = -Number(this.element.style.marginLeft.replace("px", "")), offsetTop = -Number(this.element.style.marginTop.replace("px", "")), offset;
            if (this.currentSelected !== element) {
              if (this.currentSelected) {
                this.currentSelected.style.background = "#000";
              }
              this.currentSelected = element;
              this.currentSelected.style.background = "#999";
              if ("horizontal" == this.scroll) {
                offset = Number(page) * (this.panelWidth + 3);
                if (offset > offsetLeft + viewerSize.x - this.panelWidth) {
                  offset = Math.min(offset, scrollWidth - viewerSize.x);
                  this.element.style.marginLeft = -offset + "px";
                  loadPanels(this, viewerSize.x, -offset);
                } else if (offset < offsetLeft) {
                  offset = Math.max(0, offset - viewerSize.x / 2);
                  this.element.style.marginLeft = -offset + "px";
                  loadPanels(this, viewerSize.x, -offset);
                }
              } else {
                offset = Number(page) * (this.panelHeight + 3);
                if (offset > offsetTop + viewerSize.y - this.panelHeight) {
                  offset = Math.min(offset, scrollHeight - viewerSize.y);
                  this.element.style.marginTop = -offset + "px";
                  loadPanels(this, viewerSize.y, -offset);
                } else if (offset < offsetTop) {
                  offset = Math.max(0, offset - viewerSize.y / 2);
                  this.element.style.marginTop = -offset + "px";
                  loadPanels(this, viewerSize.y, -offset);
                }
              }
              this.currentPage = page;
              onStripEnter.call(this, { eventSource: this.innerTracker });
            }
          },
          /**
           * @function
           */
          update: function() {
            if (THIS[this.id].animating) {
              $2.console.log("image reference strip update");
              return true;
            }
            return false;
          },
          // Overrides Viewer.destroy
          destroy: function() {
            if (this.miniViewers) {
              for (var key in this.miniViewers) {
                this.miniViewers[key].destroy();
              }
            }
            if (this.element) {
              this.element.parentNode.removeChild(this.element);
            }
          }
        }
      );
      function onStripDrag(event) {
        var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $2.getElementSize(this.viewer.canvas);
        this.dragging = true;
        if (this.element) {
          if ("horizontal" == this.scroll) {
            if (-event.delta.x > 0) {
              if (offsetLeft > -(scrollWidth - viewerSize.x)) {
                this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
                loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
              }
            } else if (-event.delta.x < 0) {
              if (offsetLeft < 0) {
                this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
                loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
              }
            }
          } else {
            if (-event.delta.y > 0) {
              if (offsetTop > -(scrollHeight - viewerSize.y)) {
                this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
              }
            } else if (-event.delta.y < 0) {
              if (offsetTop < 0) {
                this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
              }
            }
          }
        }
        return false;
      }
      function onStripScroll(event) {
        var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $2.getElementSize(this.viewer.canvas);
        if (this.element) {
          if ("horizontal" == this.scroll) {
            if (event.scroll > 0) {
              if (offsetLeft > -(scrollWidth - viewerSize.x)) {
                this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
                loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
              }
            } else if (event.scroll < 0) {
              if (offsetLeft < 0) {
                this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
                loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
              }
            }
          } else {
            if (event.scroll < 0) {
              if (offsetTop > viewerSize.y - scrollHeight) {
                this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
              }
            } else if (event.scroll > 0) {
              if (offsetTop < 0) {
                this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
              }
            }
          }
        }
        return false;
      }
      function loadPanels(strip, viewerSize, scroll) {
        var panelSize, activePanelsStart, activePanelsEnd, miniViewer, style, i, element;
        if ("horizontal" == strip.scroll) {
          panelSize = strip.panelWidth;
        } else {
          panelSize = strip.panelHeight;
        }
        activePanelsStart = Math.ceil(viewerSize / panelSize) + 5;
        activePanelsEnd = Math.ceil((Math.abs(scroll) + viewerSize) / panelSize) + 1;
        activePanelsStart = activePanelsEnd - activePanelsStart;
        activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;
        for (i = activePanelsStart; i < activePanelsEnd && i < strip.panels.length; i++) {
          element = strip.panels[i];
          if (!element.activePanel) {
            var miniTileSource;
            var originalTileSource = strip.viewer.tileSources[i];
            if (originalTileSource.referenceStripThumbnailUrl) {
              miniTileSource = {
                type: "image",
                url: originalTileSource.referenceStripThumbnailUrl
              };
            } else {
              miniTileSource = originalTileSource;
            }
            miniViewer = new $2.Viewer({
              id: element.id,
              tileSources: [miniTileSource],
              element,
              navigatorSizeRatio: strip.sizeRatio,
              showNavigator: false,
              mouseNavEnabled: false,
              showNavigationControl: false,
              showSequenceControl: false,
              immediateRender: true,
              blendTime: 0,
              animationTime: 0,
              loadTilesWithAjax: strip.viewer.loadTilesWithAjax,
              ajaxHeaders: strip.viewer.ajaxHeaders,
              useCanvas: strip.useCanvas
            });
            miniViewer.displayRegion = $2.makeNeutralElement("div");
            miniViewer.displayRegion.id = element.id + "-displayregion";
            miniViewer.displayRegion.className = "displayregion";
            style = miniViewer.displayRegion.style;
            style.position = "relative";
            style.top = "0px";
            style.left = "0px";
            style.fontSize = "0px";
            style.overflow = "hidden";
            style.float = "left";
            style.cssFloat = "left";
            style.styleFloat = "left";
            style.zIndex = 999999999;
            style.cursor = "default";
            style.width = strip.panelWidth - 4 + "px";
            style.height = strip.panelHeight - 4 + "px";
            miniViewer.displayRegion.innerTracker = new $2.MouseTracker({
              element: miniViewer.displayRegion,
              startDisabled: true
            });
            element.getElementsByTagName("div")[0].appendChild(
              miniViewer.displayRegion
            );
            strip.miniViewers[element.id] = miniViewer;
            element.activePanel = true;
          }
        }
      }
      function onStripEnter(event) {
        var element = event.eventSource.element;
        if ("horizontal" == this.scroll) {
          element.style.marginBottom = "0px";
        } else {
          element.style.marginLeft = "0px";
        }
        return false;
      }
      function onStripExit(event) {
        var element = event.eventSource.element;
        if ("horizontal" == this.scroll) {
          element.style.marginBottom = "-" + $2.getElementSize(element).y / 2 + "px";
        } else {
          element.style.marginLeft = "-" + $2.getElementSize(element).x / 2 + "px";
        }
        return false;
      }
      function onKeyDown(event) {
        if (!event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
          switch (event.keyCode) {
            case 38:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              return false;
            case 40:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              return false;
            case 37:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              return false;
            case 39:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              return false;
            default:
              return true;
          }
        } else {
          return true;
        }
      }
      function onKeyPress(event) {
        if (!event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
          switch (event.keyCode) {
            case 61:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              return false;
            case 45:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              return false;
            case 48:
            case 119:
            case 87:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              return false;
            case 115:
            case 83:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              return false;
            case 97:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              return false;
            case 100:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              return false;
            default:
              return true;
          }
        } else {
          return true;
        }
      }
    })(OpenSeadragon);
    (function($2) {
      $2.DisplayRect = function(x, y, width, height, minLevel, maxLevel) {
        $2.Rect.apply(this, [x, y, width, height]);
        this.minLevel = minLevel;
        this.maxLevel = maxLevel;
      };
      $2.extend($2.DisplayRect.prototype, $2.Rect.prototype);
    })(OpenSeadragon);
    (function($2) {
      $2.Spring = function(options) {
        var args = arguments;
        if (typeof options != "object") {
          options = {
            initial: args.length && typeof args[0] == "number" ? args[0] : void 0,
            /**
             * Spring stiffness.
             * @member {Number} springStiffness
             * @memberof OpenSeadragon.Spring#
             */
            springStiffness: args.length > 1 ? args[1].springStiffness : 5,
            /**
             * Animation duration per spring.
             * @member {Number} animationTime
             * @memberof OpenSeadragon.Spring#
             */
            animationTime: args.length > 1 ? args[1].animationTime : 1.5
          };
        }
        $2.console.assert(
          typeof options.springStiffness === "number" && options.springStiffness !== 0,
          "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number"
        );
        $2.console.assert(
          typeof options.animationTime === "number" && options.animationTime >= 0,
          "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0"
        );
        if (options.exponential) {
          this._exponential = true;
          delete options.exponential;
        }
        $2.extend(true, this, options);
        this.current = {
          value: typeof this.initial == "number" ? this.initial : this._exponential ? 0 : 1,
          time: $2.now()
          // always work in milliseconds
        };
        $2.console.assert(
          !this._exponential || this.current.value !== 0,
          "[OpenSeadragon.Spring] value must be non-zero for exponential springs"
        );
        this.start = {
          value: this.current.value,
          time: this.current.time
        };
        this.target = {
          value: this.current.value,
          time: this.current.time
        };
        if (this._exponential) {
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
          this.current._logValue = Math.log(this.current.value);
        }
      };
      $2.Spring.prototype = {
        /**
         * @function
         * @param {Number} target
         */
        resetTo: function(target) {
          $2.console.assert(
            !this._exponential || target !== 0,
            "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs"
          );
          this.start.value = this.target.value = this.current.value = target;
          this.start.time = this.target.time = this.current.time = $2.now();
          if (this._exponential) {
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
            this.current._logValue = Math.log(this.current.value);
          }
        },
        /**
         * @function
         * @param {Number} target
         */
        springTo: function(target) {
          $2.console.assert(
            !this._exponential || target !== 0,
            "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs"
          );
          this.start.value = this.current.value;
          this.start.time = this.current.time;
          this.target.value = target;
          this.target.time = this.start.time + 1e3 * this.animationTime;
          if (this._exponential) {
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
          }
        },
        /**
         * @function
         * @param {Number} delta
         */
        shiftBy: function(delta) {
          this.start.value += delta;
          this.target.value += delta;
          if (this._exponential) {
            $2.console.assert(
              this.target.value !== 0 && this.start.value !== 0,
              "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs"
            );
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
          }
        },
        setExponential: function(value) {
          this._exponential = value;
          if (this._exponential) {
            $2.console.assert(
              this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
              "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs"
            );
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
            this.current._logValue = Math.log(this.current.value);
          }
        },
        /**
         * @function
         * @returns true if the value got updated, false otherwise
         */
        update: function() {
          this.current.time = $2.now();
          var startValue, targetValue;
          if (this._exponential) {
            startValue = this.start._logValue;
            targetValue = this.target._logValue;
          } else {
            startValue = this.start.value;
            targetValue = this.target.value;
          }
          var currentValue = this.current.time >= this.target.time ? targetValue : startValue + (targetValue - startValue) * transform(
            this.springStiffness,
            (this.current.time - this.start.time) / (this.target.time - this.start.time)
          );
          var oldValue = this.current.value;
          if (this._exponential) {
            this.current.value = Math.exp(currentValue);
          } else {
            this.current.value = currentValue;
          }
          return oldValue != this.current.value;
        },
        /**
         * Returns whether the spring is at the target value
         * @function
         * @returns {Boolean} True if at target value, false otherwise
         */
        isAtTargetValue: function() {
          return this.current.value === this.target.value;
        }
      };
      function transform(stiffness, x) {
        return (1 - Math.exp(stiffness * -x)) / (1 - Math.exp(-stiffness));
      }
    })(OpenSeadragon);
    (function($2) {
      function ImageJob(options) {
        $2.extend(true, this, {
          timeout: $2.DEFAULT_SETTINGS.timeout,
          jobId: null
        }, options);
        this.image = null;
      }
      ImageJob.prototype = {
        errorMsg: null,
        /**
         * Starts the image job.
         * @method
         */
        start: function() {
          var self = this;
          var selfAbort = this.abort;
          this.image = new Image();
          this.image.onload = function() {
            self.finish(true);
          };
          this.image.onabort = this.image.onerror = function() {
            self.errorMsg = "Image load aborted";
            self.finish(false);
          };
          this.jobId = window.setTimeout(function() {
            self.errorMsg = "Image load exceeded timeout (" + self.timeout + " ms)";
            self.finish(false);
          }, this.timeout);
          if (this.loadWithAjax) {
            this.request = $2.makeAjaxRequest({
              url: this.src,
              withCredentials: this.ajaxWithCredentials,
              headers: this.ajaxHeaders,
              responseType: "arraybuffer",
              success: function(request) {
                var blb;
                try {
                  blb = new window.Blob([request.response]);
                } catch (e) {
                  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                  if (e.name === "TypeError" && BlobBuilder) {
                    var bb = new BlobBuilder();
                    bb.append(request.response);
                    blb = bb.getBlob();
                  }
                }
                if (blb.size === 0) {
                  self.errorMsg = "Empty image response.";
                  self.finish(false);
                }
                var url = (window.URL || window.webkitURL).createObjectURL(blb);
                self.image.src = url;
              },
              error: function(request) {
                self.errorMsg = "Image load aborted - XHR error";
                self.finish(false);
              }
            });
            this.abort = function() {
              self.request.abort();
              if (typeof selfAbort === "function") {
                selfAbort();
              }
            };
          } else {
            if (this.crossOriginPolicy !== false) {
              this.image.crossOrigin = this.crossOriginPolicy;
            }
            this.image.src = this.src;
          }
        },
        finish: function(successful) {
          this.image.onload = this.image.onerror = this.image.onabort = null;
          if (!successful) {
            this.image = null;
          }
          if (this.jobId) {
            window.clearTimeout(this.jobId);
          }
          this.callback(this);
        }
      };
      $2.ImageLoader = function(options) {
        $2.extend(true, this, {
          jobLimit: $2.DEFAULT_SETTINGS.imageLoaderLimit,
          timeout: $2.DEFAULT_SETTINGS.timeout,
          jobQueue: [],
          jobsInProgress: 0
        }, options);
      };
      $2.ImageLoader.prototype = {
        /**
         * Add an unloaded image to the loader queue.
         * @method
         * @param {Object} options - Options for this job.
         * @param {String} [options.src] - URL of image to download.
         * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
         * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
         * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
         * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
         * requests.
         * @param {Function} [options.callback] - Called once image has been downloaded.
         * @param {Function} [options.abort] - Called when this image job is aborted.
         */
        addJob: function(options) {
          var _this = this, complete = function(job) {
            completeJob(_this, job, options.callback);
          }, jobOptions = {
            src: options.src,
            loadWithAjax: options.loadWithAjax,
            ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,
            crossOriginPolicy: options.crossOriginPolicy,
            ajaxWithCredentials: options.ajaxWithCredentials,
            callback: complete,
            abort: options.abort,
            timeout: this.timeout
          }, newJob = new ImageJob(jobOptions);
          if (!this.jobLimit || this.jobsInProgress < this.jobLimit) {
            newJob.start();
            this.jobsInProgress++;
          } else {
            this.jobQueue.push(newJob);
          }
        },
        /**
         * Clear any unstarted image loading jobs from the queue.
         * @method
         */
        clear: function() {
          for (var i = 0; i < this.jobQueue.length; i++) {
            var job = this.jobQueue[i];
            if (typeof job.abort === "function") {
              job.abort();
            }
          }
          this.jobQueue = [];
        }
      };
      function completeJob(loader, job, callback) {
        var nextJob;
        loader.jobsInProgress--;
        if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {
          nextJob = loader.jobQueue.shift();
          nextJob.start();
          loader.jobsInProgress++;
        }
        callback(job.image, job.errorMsg, job.request);
      }
    })(OpenSeadragon);
    (function($2) {
      $2.Tile = function(level, x, y, bounds, exists, url, context2D, loadWithAjax, ajaxHeaders, sourceBounds) {
        this.level = level;
        this.x = x;
        this.y = y;
        this.bounds = bounds;
        this.sourceBounds = sourceBounds;
        this.exists = exists;
        this.url = url;
        this.context2D = context2D;
        this.loadWithAjax = loadWithAjax;
        this.ajaxHeaders = ajaxHeaders;
        if (this.ajaxHeaders) {
          this.cacheKey = this.url + "+" + JSON.stringify(this.ajaxHeaders);
        } else {
          this.cacheKey = this.url;
        }
        this.loaded = false;
        this.loading = false;
        this.element = null;
        this.imgElement = null;
        this.image = null;
        this.style = null;
        this.position = null;
        this.size = null;
        this.blendStart = null;
        this.opacity = null;
        this.squaredDistance = null;
        this.visibility = null;
        this.beingDrawn = false;
        this.lastTouchTime = 0;
        this.isRightMost = false;
        this.isBottomMost = false;
      };
      $2.Tile.prototype = {
        /**
         * Provides a string representation of this tiles level and (x,y)
         * components.
         * @function
         * @returns {String}
         */
        toString: function() {
          return this.level + "/" + this.x + "_" + this.y;
        },
        // private
        _hasTransparencyChannel: function() {
          return !!this.context2D || this.url.match(".png");
        },
        /**
         * Renders the tile in an html container.
         * @function
         * @param {Element} container
         */
        drawHTML: function(container) {
          if (!this.cacheImageRecord) {
            $2.console.warn(
              "[Tile.drawHTML] attempting to draw tile %s when it's not cached",
              this.toString()
            );
            return;
          }
          if (!this.loaded) {
            $2.console.warn(
              "Attempting to draw tile %s when it's not yet loaded.",
              this.toString()
            );
            return;
          }
          if (!this.element) {
            this.element = $2.makeNeutralElement("div");
            this.imgElement = this.cacheImageRecord.getImage().cloneNode();
            this.imgElement.style.msInterpolationMode = "nearest-neighbor";
            this.imgElement.style.width = "100%";
            this.imgElement.style.height = "100%";
            this.style = this.element.style;
            this.style.position = "absolute";
          }
          if (this.element.parentNode != container) {
            container.appendChild(this.element);
          }
          if (this.imgElement.parentNode != this.element) {
            this.element.appendChild(this.imgElement);
          }
          this.style.top = this.position.y + "px";
          this.style.left = this.position.x + "px";
          this.style.height = this.size.y + "px";
          this.style.width = this.size.x + "px";
          $2.setElementOpacity(this.element, this.opacity);
        },
        /**
         * Renders the tile in a canvas-based context.
         * @function
         * @param {Canvas} context
         * @param {Function} drawingHandler - Method for firing the drawing event.
         * drawingHandler({context, tile, rendered})
         * where <code>rendered</code> is the context with the pre-drawn image.
         * @param {Number} [scale=1] - Apply a scale to position and size
         * @param {OpenSeadragon.Point} [translate] - A translation vector
         */
        drawCanvas: function(context, drawingHandler, scale, translate) {
          var position = this.position.times($2.pixelDensityRatio), size = this.size.times($2.pixelDensityRatio), rendered;
          if (!this.context2D && !this.cacheImageRecord) {
            $2.console.warn(
              "[Tile.drawCanvas] attempting to draw tile %s when it's not cached",
              this.toString()
            );
            return;
          }
          rendered = this.context2D || this.cacheImageRecord.getRenderedContext();
          if (!this.loaded || !rendered) {
            $2.console.warn(
              "Attempting to draw tile %s when it's not yet loaded.",
              this.toString()
            );
            return;
          }
          context.save();
          context.globalAlpha = this.opacity;
          if (typeof scale === "number" && scale !== 1) {
            position = position.times(scale);
            size = size.times(scale);
          }
          if (translate instanceof $2.Point) {
            position = position.plus(translate);
          }
          if (context.globalAlpha === 1 && this._hasTransparencyChannel()) {
            context.clearRect(
              position.x,
              position.y,
              size.x,
              size.y
            );
          }
          drawingHandler({ context, tile: this, rendered });
          var sourceWidth, sourceHeight;
          if (this.sourceBounds) {
            sourceWidth = Math.min(this.sourceBounds.width, rendered.canvas.width);
            sourceHeight = Math.min(this.sourceBounds.height, rendered.canvas.height);
          } else {
            sourceWidth = rendered.canvas.width;
            sourceHeight = rendered.canvas.height;
          }
          context.drawImage(
            rendered.canvas,
            0,
            0,
            sourceWidth,
            sourceHeight,
            position.x,
            position.y,
            size.x,
            size.y
          );
          context.restore();
        },
        /**
         * Get the ratio between current and original size.
         * @function
         * @return {Float}
         */
        getScaleForEdgeSmoothing: function() {
          var context;
          if (this.cacheImageRecord) {
            context = this.cacheImageRecord.getRenderedContext();
          } else if (this.context2D) {
            context = this.context2D;
          } else {
            $2.console.warn(
              "[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached",
              this.toString()
            );
            return 1;
          }
          return context.canvas.width / (this.size.x * $2.pixelDensityRatio);
        },
        /**
         * Get a translation vector that when applied to the tile position produces integer coordinates.
         * Needed to avoid swimming and twitching.
         * @function
         * @param {Number} [scale=1] - Scale to be applied to position.
         * @return {OpenSeadragon.Point}
         */
        getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {
          var x = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));
          var y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));
          return new $2.Point(x, y).minus(
            this.position.times($2.pixelDensityRatio).times(scale || 1).apply(function(x2) {
              return x2 % 1;
            })
          );
        },
        /**
         * Removes tile from its container.
         * @function
         */
        unload: function() {
          if (this.imgElement && this.imgElement.parentNode) {
            this.imgElement.parentNode.removeChild(this.imgElement);
          }
          if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
          }
          this.element = null;
          this.imgElement = null;
          this.loaded = false;
          this.loading = false;
        }
      };
    })(OpenSeadragon);
    (function($2) {
      $2.OverlayPlacement = $2.Placement;
      $2.OverlayRotationMode = $2.freezeObject({
        NO_ROTATION: 1,
        EXACT: 2,
        BOUNDING_BOX: 3
      });
      $2.Overlay = function(element, location, placement) {
        var options;
        if ($2.isPlainObject(element)) {
          options = element;
        } else {
          options = {
            element,
            location,
            placement
          };
        }
        this.element = options.element;
        this.style = options.element.style;
        this._init(options);
      };
      $2.Overlay.prototype = {
        // private
        _init: function(options) {
          this.location = options.location;
          this.placement = options.placement === void 0 ? $2.Placement.TOP_LEFT : options.placement;
          this.onDraw = options.onDraw;
          this.checkResize = options.checkResize === void 0 ? true : options.checkResize;
          this.width = options.width === void 0 ? null : options.width;
          this.height = options.height === void 0 ? null : options.height;
          this.rotationMode = options.rotationMode || $2.OverlayRotationMode.EXACT;
          if (this.location instanceof $2.Rect) {
            this.width = this.location.width;
            this.height = this.location.height;
            this.location = this.location.getTopLeft();
            this.placement = $2.Placement.TOP_LEFT;
          }
          this.scales = this.width !== null && this.height !== null;
          this.bounds = new $2.Rect(
            this.location.x,
            this.location.y,
            this.width,
            this.height
          );
          this.position = this.location;
        },
        /**
         * Internal function to adjust the position of an overlay
         * depending on it size and placement.
         * @function
         * @param {OpenSeadragon.Point} position
         * @param {OpenSeadragon.Point} size
         */
        adjust: function(position, size) {
          var properties = $2.Placement.properties[this.placement];
          if (!properties) {
            return;
          }
          if (properties.isHorizontallyCentered) {
            position.x -= size.x / 2;
          } else if (properties.isRight) {
            position.x -= size.x;
          }
          if (properties.isVerticallyCentered) {
            position.y -= size.y / 2;
          } else if (properties.isBottom) {
            position.y -= size.y;
          }
        },
        /**
         * @function
         */
        destroy: function() {
          var element = this.element;
          var style = this.style;
          if (element.parentNode) {
            element.parentNode.removeChild(element);
            if (element.prevElementParent) {
              style.display = "none";
              document.body.appendChild(element);
            }
          }
          this.onDraw = null;
          style.top = "";
          style.left = "";
          style.position = "";
          if (this.width !== null) {
            style.width = "";
          }
          if (this.height !== null) {
            style.height = "";
          }
          var transformOriginProp = $2.getCssPropertyWithVendorPrefix(
            "transformOrigin"
          );
          var transformProp = $2.getCssPropertyWithVendorPrefix(
            "transform"
          );
          if (transformOriginProp && transformProp) {
            style[transformOriginProp] = "";
            style[transformProp] = "";
          }
        },
        /**
         * @function
         * @param {Element} container
         */
        drawHTML: function(container, viewport) {
          var element = this.element;
          if (element.parentNode !== container) {
            element.prevElementParent = element.parentNode;
            element.prevNextSibling = element.nextSibling;
            container.appendChild(element);
            this.style.position = "absolute";
            this.size = $2.getElementSize(element);
          }
          var positionAndSize = this._getOverlayPositionAndSize(viewport);
          var position = positionAndSize.position;
          var size = this.size = positionAndSize.size;
          var rotate = positionAndSize.rotate;
          if (this.onDraw) {
            this.onDraw(position, size, this.element);
          } else {
            var style = this.style;
            style.left = position.x + "px";
            style.top = position.y + "px";
            if (this.width !== null) {
              style.width = size.x + "px";
            }
            if (this.height !== null) {
              style.height = size.y + "px";
            }
            var transformOriginProp = $2.getCssPropertyWithVendorPrefix(
              "transformOrigin"
            );
            var transformProp = $2.getCssPropertyWithVendorPrefix(
              "transform"
            );
            if (transformOriginProp && transformProp) {
              if (rotate) {
                style[transformOriginProp] = this._getTransformOrigin();
                style[transformProp] = "rotate(" + rotate + "deg)";
              } else {
                style[transformOriginProp] = "";
                style[transformProp] = "";
              }
            }
            if (style.display !== "none") {
              style.display = "block";
            }
          }
        },
        // private
        _getOverlayPositionAndSize: function(viewport) {
          var position = viewport.pixelFromPoint(this.location, true);
          var size = this._getSizeInPixels(viewport);
          this.adjust(position, size);
          var rotate = 0;
          if (viewport.degrees && this.rotationMode !== $2.OverlayRotationMode.NO_ROTATION) {
            if (this.rotationMode === $2.OverlayRotationMode.BOUNDING_BOX && this.width !== null && this.height !== null) {
              var rect = new $2.Rect(position.x, position.y, size.x, size.y);
              var boundingBox = this._getBoundingBox(rect, viewport.degrees);
              position = boundingBox.getTopLeft();
              size = boundingBox.getSize();
            } else {
              rotate = viewport.degrees;
            }
          }
          return {
            position,
            size,
            rotate
          };
        },
        // private
        _getSizeInPixels: function(viewport) {
          var width = this.size.x;
          var height = this.size.y;
          if (this.width !== null || this.height !== null) {
            var scaledSize = viewport.deltaPixelsFromPointsNoRotate(
              new $2.Point(this.width || 0, this.height || 0),
              true
            );
            if (this.width !== null) {
              width = scaledSize.x;
            }
            if (this.height !== null) {
              height = scaledSize.y;
            }
          }
          if (this.checkResize && (this.width === null || this.height === null)) {
            var eltSize = this.size = $2.getElementSize(this.element);
            if (this.width === null) {
              width = eltSize.x;
            }
            if (this.height === null) {
              height = eltSize.y;
            }
          }
          return new $2.Point(width, height);
        },
        // private
        _getBoundingBox: function(rect, degrees) {
          var refPoint = this._getPlacementPoint(rect);
          return rect.rotate(degrees, refPoint).getBoundingBox();
        },
        // private
        _getPlacementPoint: function(rect) {
          var result = new $2.Point(rect.x, rect.y);
          var properties = $2.Placement.properties[this.placement];
          if (properties) {
            if (properties.isHorizontallyCentered) {
              result.x += rect.width / 2;
            } else if (properties.isRight) {
              result.x += rect.width;
            }
            if (properties.isVerticallyCentered) {
              result.y += rect.height / 2;
            } else if (properties.isBottom) {
              result.y += rect.height;
            }
          }
          return result;
        },
        // private
        _getTransformOrigin: function() {
          var result = "";
          var properties = $2.Placement.properties[this.placement];
          if (!properties) {
            return result;
          }
          if (properties.isLeft) {
            result = "left";
          } else if (properties.isRight) {
            result = "right";
          }
          if (properties.isTop) {
            result += " top";
          } else if (properties.isBottom) {
            result += " bottom";
          }
          return result;
        },
        /**
         * Changes the overlay settings.
         * @function
         * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
         * If an object is specified, the options are the same than the constructor
         * except for the element which can not be changed.
         * @param {OpenSeadragon.Placement} placement
         */
        update: function(location, placement) {
          var options = $2.isPlainObject(location) ? location : {
            location,
            placement
          };
          this._init({
            location: options.location || this.location,
            placement: options.placement !== void 0 ? options.placement : this.placement,
            onDraw: options.onDraw || this.onDraw,
            checkResize: options.checkResize || this.checkResize,
            width: options.width !== void 0 ? options.width : this.width,
            height: options.height !== void 0 ? options.height : this.height,
            rotationMode: options.rotationMode || this.rotationMode
          });
        },
        /**
         * Returns the current bounds of the overlay in viewport coordinates
         * @function
         * @param {OpenSeadragon.Viewport} viewport the viewport
         * @returns {OpenSeadragon.Rect} overlay bounds
         */
        getBounds: function(viewport) {
          $2.console.assert(
            viewport,
            "A viewport must now be passed to Overlay.getBounds."
          );
          var width = this.width;
          var height = this.height;
          if (width === null || height === null) {
            var size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);
            if (width === null) {
              width = size.x;
            }
            if (height === null) {
              height = size.y;
            }
          }
          var location = this.location.clone();
          this.adjust(location, new $2.Point(width, height));
          return this._adjustBoundsForRotation(
            viewport,
            new $2.Rect(location.x, location.y, width, height)
          );
        },
        // private
        _adjustBoundsForRotation: function(viewport, bounds) {
          if (!viewport || viewport.degrees === 0 || this.rotationMode === $2.OverlayRotationMode.EXACT) {
            return bounds;
          }
          if (this.rotationMode === $2.OverlayRotationMode.BOUNDING_BOX) {
            if (this.width === null || this.height === null) {
              return bounds;
            }
            var positionAndSize = this._getOverlayPositionAndSize(viewport);
            return viewport.viewerElementToViewportRectangle(new $2.Rect(
              positionAndSize.position.x,
              positionAndSize.position.y,
              positionAndSize.size.x,
              positionAndSize.size.y
            ));
          }
          return bounds.rotate(
            -viewport.degrees,
            this._getPlacementPoint(bounds)
          );
        }
      };
    })(OpenSeadragon);
    (function($2) {
      $2.Drawer = function(options) {
        $2.console.assert(options.viewer, "[Drawer] options.viewer is required");
        var args = arguments;
        if (!$2.isPlainObject(options)) {
          options = {
            source: args[0],
            // Reference to Viewer tile source.
            viewport: args[1],
            // Reference to Viewer viewport.
            element: args[2]
            // Parent element.
          };
        }
        $2.console.assert(options.viewport, "[Drawer] options.viewport is required");
        $2.console.assert(options.element, "[Drawer] options.element is required");
        if (options.source) {
          $2.console.error("[Drawer] options.source is no longer accepted; use TiledImage instead");
        }
        this.viewer = options.viewer;
        this.viewport = options.viewport;
        this.debugGridColor = typeof options.debugGridColor === "string" ? [options.debugGridColor] : options.debugGridColor || $2.DEFAULT_SETTINGS.debugGridColor;
        if (options.opacity) {
          $2.console.error("[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead");
        }
        this.useCanvas = $2.supportsCanvas && (this.viewer ? this.viewer.useCanvas : true);
        this.container = $2.getElement(options.element);
        this.canvas = $2.makeNeutralElement(this.useCanvas ? "canvas" : "div");
        this.context = this.useCanvas ? this.canvas.getContext("2d") : null;
        this.sketchCanvas = null;
        this.sketchContext = null;
        this.element = this.container;
        this.container.dir = "ltr";
        if (this.useCanvas) {
          var viewportSize = this._calculateCanvasSize();
          this.canvas.width = viewportSize.x;
          this.canvas.height = viewportSize.y;
        }
        this.canvas.style.width = "100%";
        this.canvas.style.height = "100%";
        this.canvas.style.position = "absolute";
        $2.setElementOpacity(this.canvas, this.opacity, true);
        this.container.style.textAlign = "left";
        this.container.appendChild(this.canvas);
        this._imageSmoothingEnabled = true;
      };
      $2.Drawer.prototype = {
        // deprecated
        addOverlay: function(element, location, placement, onDraw) {
          $2.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead.");
          this.viewer.addOverlay(element, location, placement, onDraw);
          return this;
        },
        // deprecated
        updateOverlay: function(element, location, placement) {
          $2.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead.");
          this.viewer.updateOverlay(element, location, placement);
          return this;
        },
        // deprecated
        removeOverlay: function(element) {
          $2.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead.");
          this.viewer.removeOverlay(element);
          return this;
        },
        // deprecated
        clearOverlays: function() {
          $2.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead.");
          this.viewer.clearOverlays();
          return this;
        },
        /**
         * This function converts the given point from to the drawer coordinate by
         * multiplying it with the pixel density.
         * This function does not take rotation into account, thus assuming provided
         * point is at 0 degree.
         * @param {OpenSeadragon.Point} point - the pixel point to convert
         */
        viewportCoordToDrawerCoord: function(point) {
          var vpPoint = this.viewport.pixelFromPointNoRotate(point, true);
          return new $2.Point(
            vpPoint.x * $2.pixelDensityRatio,
            vpPoint.y * $2.pixelDensityRatio
          );
        },
        /**
         * This function will create multiple polygon paths on the drawing context by provided polygons,
         * then clip the context to the paths.
         * @param {(OpenSeadragon.Point[])[]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
         * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
         */
        clipWithPolygons: function(polygons, useSketch) {
          if (!this.useCanvas) {
            return;
          }
          var context = this._getContext(useSketch);
          context.beginPath();
          polygons.forEach(function(polygon) {
            polygon.forEach(function(coord, i) {
              context[i === 0 ? "moveTo" : "lineTo"](coord.x, coord.y);
            });
          });
          context.clip();
        },
        /**
         * Set the opacity of the drawer.
         * @param {Number} opacity
         * @return {OpenSeadragon.Drawer} Chainable.
         */
        setOpacity: function(opacity) {
          $2.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");
          var world = this.viewer.world;
          for (var i = 0; i < world.getItemCount(); i++) {
            world.getItemAt(i).setOpacity(opacity);
          }
          return this;
        },
        /**
         * Get the opacity of the drawer.
         * @returns {Number}
         */
        getOpacity: function() {
          $2.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");
          var world = this.viewer.world;
          var maxOpacity = 0;
          for (var i = 0; i < world.getItemCount(); i++) {
            var opacity = world.getItemAt(i).getOpacity();
            if (opacity > maxOpacity) {
              maxOpacity = opacity;
            }
          }
          return maxOpacity;
        },
        // deprecated
        needsUpdate: function() {
          $2.console.error("[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead.");
          return this.viewer.world.needsDraw();
        },
        // deprecated
        numTilesLoaded: function() {
          $2.console.error("[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead.");
          return this.viewer.tileCache.numTilesLoaded();
        },
        // deprecated
        reset: function() {
          $2.console.error("[Drawer.reset] this function is deprecated. Use World.resetItems instead.");
          this.viewer.world.resetItems();
          return this;
        },
        // deprecated
        update: function() {
          $2.console.error("[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead.");
          this.clear();
          this.viewer.world.draw();
          return this;
        },
        /**
         * @return {Boolean} True if rotation is supported.
         */
        canRotate: function() {
          return this.useCanvas;
        },
        /**
         * Destroy the drawer (unload current loaded tiles)
         */
        destroy: function() {
          this.canvas.width = 1;
          this.canvas.height = 1;
          this.sketchCanvas = null;
          this.sketchContext = null;
        },
        /**
         * Clears the Drawer so it's ready to draw another frame.
         */
        clear: function() {
          this.canvas.innerHTML = "";
          if (this.useCanvas) {
            var viewportSize = this._calculateCanvasSize();
            if (this.canvas.width != viewportSize.x || this.canvas.height != viewportSize.y) {
              this.canvas.width = viewportSize.x;
              this.canvas.height = viewportSize.y;
              this._updateImageSmoothingEnabled(this.context);
              if (this.sketchCanvas !== null) {
                var sketchCanvasSize = this._calculateSketchCanvasSize();
                this.sketchCanvas.width = sketchCanvasSize.x;
                this.sketchCanvas.height = sketchCanvasSize.y;
                this._updateImageSmoothingEnabled(this.sketchContext);
              }
            }
            this._clear();
          }
        },
        _clear: function(useSketch, bounds) {
          if (!this.useCanvas) {
            return;
          }
          var context = this._getContext(useSketch);
          if (bounds) {
            context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
          } else {
            var canvas = context.canvas;
            context.clearRect(0, 0, canvas.width, canvas.height);
          }
        },
        /**
         * Scale from OpenSeadragon viewer rectangle to drawer rectangle
         * (ignoring rotation)
         * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
         * @return {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
         */
        viewportToDrawerRectangle: function(rectangle) {
          var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);
          var size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);
          return new $2.Rect(
            topLeft.x * $2.pixelDensityRatio,
            topLeft.y * $2.pixelDensityRatio,
            size.x * $2.pixelDensityRatio,
            size.y * $2.pixelDensityRatio
          );
        },
        /**
         * Draws the given tile.
         * @param {OpenSeadragon.Tile} tile - The tile to draw.
         * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
         * drawingHandler({context, tile, rendered})
         * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
         * where <code>rendered</code> is the context with the pre-drawn image.
         * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
         * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
         */
        drawTile: function(tile, drawingHandler, useSketch, scale, translate) {
          $2.console.assert(tile, "[Drawer.drawTile] tile is required");
          $2.console.assert(drawingHandler, "[Drawer.drawTile] drawingHandler is required");
          if (this.useCanvas) {
            var context = this._getContext(useSketch);
            scale = scale || 1;
            tile.drawCanvas(context, drawingHandler, scale, translate);
          } else {
            tile.drawHTML(this.canvas);
          }
        },
        _getContext: function(useSketch) {
          var context = this.context;
          if (useSketch) {
            if (this.sketchCanvas === null) {
              this.sketchCanvas = document.createElement("canvas");
              var sketchCanvasSize = this._calculateSketchCanvasSize();
              this.sketchCanvas.width = sketchCanvasSize.x;
              this.sketchCanvas.height = sketchCanvasSize.y;
              this.sketchContext = this.sketchCanvas.getContext("2d");
              if (this.viewport.getRotation() === 0) {
                var self = this;
                this.viewer.addHandler("rotate", function resizeSketchCanvas() {
                  if (self.viewport.getRotation() === 0) {
                    return;
                  }
                  self.viewer.removeHandler("rotate", resizeSketchCanvas);
                  var sketchCanvasSize2 = self._calculateSketchCanvasSize();
                  self.sketchCanvas.width = sketchCanvasSize2.x;
                  self.sketchCanvas.height = sketchCanvasSize2.y;
                });
              }
              this._updateImageSmoothingEnabled(this.sketchContext);
            }
            context = this.sketchContext;
          }
          return context;
        },
        // private
        saveContext: function(useSketch) {
          if (!this.useCanvas) {
            return;
          }
          this._getContext(useSketch).save();
        },
        // private
        restoreContext: function(useSketch) {
          if (!this.useCanvas) {
            return;
          }
          this._getContext(useSketch).restore();
        },
        // private
        setClip: function(rect, useSketch) {
          if (!this.useCanvas) {
            return;
          }
          var context = this._getContext(useSketch);
          context.beginPath();
          context.rect(rect.x, rect.y, rect.width, rect.height);
          context.clip();
        },
        // private
        drawRectangle: function(rect, fillStyle, useSketch) {
          if (!this.useCanvas) {
            return;
          }
          var context = this._getContext(useSketch);
          context.save();
          context.fillStyle = fillStyle;
          context.fillRect(rect.x, rect.y, rect.width, rect.height);
          context.restore();
        },
        /**
         * Blends the sketch canvas in the main canvas.
         * @param {Object} options The options
         * @param {Float} options.opacity The opacity of the blending.
         * @param {Float} [options.scale=1] The scale at which tiles were drawn on
         * the sketch. Default is 1.
         * Use scale to draw at a lower scale and then enlarge onto the main canvas.
         * @param {OpenSeadragon.Point} [options.translate] A translation vector
         * that was used to draw the tiles
         * @param {String} [options.compositeOperation] - How the image is
         * composited onto other images; see compositeOperation in
         * {@link OpenSeadragon.Options} for possible values.
         * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
         * canvas to blend in the main canvas. If specified, options.scale and
         * options.translate get ignored.
         */
        blendSketch: function(opacity, scale, translate, compositeOperation) {
          var options = opacity;
          if (!$2.isPlainObject(options)) {
            options = {
              opacity,
              scale,
              translate,
              compositeOperation
            };
          }
          if (!this.useCanvas || !this.sketchCanvas) {
            return;
          }
          opacity = options.opacity;
          compositeOperation = options.compositeOperation;
          var bounds = options.bounds;
          this.context.save();
          this.context.globalAlpha = opacity;
          if (compositeOperation) {
            this.context.globalCompositeOperation = compositeOperation;
          }
          if (bounds) {
            if (bounds.x < 0) {
              bounds.width += bounds.x;
              bounds.x = 0;
            }
            if (bounds.x + bounds.width > this.canvas.width) {
              bounds.width = this.canvas.width - bounds.x;
            }
            if (bounds.y < 0) {
              bounds.height += bounds.y;
              bounds.y = 0;
            }
            if (bounds.y + bounds.height > this.canvas.height) {
              bounds.height = this.canvas.height - bounds.y;
            }
            this.context.drawImage(
              this.sketchCanvas,
              bounds.x,
              bounds.y,
              bounds.width,
              bounds.height,
              bounds.x,
              bounds.y,
              bounds.width,
              bounds.height
            );
          } else {
            scale = options.scale || 1;
            translate = options.translate;
            var position = translate instanceof $2.Point ? translate : new $2.Point(0, 0);
            var widthExt = 0;
            var heightExt = 0;
            if (translate) {
              var widthDiff = this.sketchCanvas.width - this.canvas.width;
              var heightDiff = this.sketchCanvas.height - this.canvas.height;
              widthExt = Math.round(widthDiff / 2);
              heightExt = Math.round(heightDiff / 2);
            }
            this.context.drawImage(
              this.sketchCanvas,
              position.x - widthExt * scale,
              position.y - heightExt * scale,
              (this.canvas.width + 2 * widthExt) * scale,
              (this.canvas.height + 2 * heightExt) * scale,
              -widthExt,
              -heightExt,
              this.canvas.width + 2 * widthExt,
              this.canvas.height + 2 * heightExt
            );
          }
          this.context.restore();
        },
        // private
        drawDebugInfo: function(tile, count, i, tiledImage) {
          if (!this.useCanvas) {
            return;
          }
          var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
          var context = this.context;
          context.save();
          context.lineWidth = 2 * $2.pixelDensityRatio;
          context.font = "small-caps bold " + 13 * $2.pixelDensityRatio + "px arial";
          context.strokeStyle = this.debugGridColor[colorIndex];
          context.fillStyle = this.debugGridColor[colorIndex];
          if (this.viewport.degrees !== 0) {
            this._offsetForRotation({ degrees: this.viewport.degrees });
          }
          if (tiledImage.getRotation(true) % 360 !== 0) {
            this._offsetForRotation({
              degrees: tiledImage.getRotation(true),
              point: tiledImage.viewport.pixelFromPointNoRotate(
                tiledImage._getRotationPoint(true),
                true
              )
            });
          }
          if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0) {
            if (tiledImage._drawer.viewer.viewport.getFlip()) {
              tiledImage._drawer._flip();
            }
          }
          context.strokeRect(
            tile.position.x * $2.pixelDensityRatio,
            tile.position.y * $2.pixelDensityRatio,
            tile.size.x * $2.pixelDensityRatio,
            tile.size.y * $2.pixelDensityRatio
          );
          var tileCenterX = (tile.position.x + tile.size.x / 2) * $2.pixelDensityRatio;
          var tileCenterY = (tile.position.y + tile.size.y / 2) * $2.pixelDensityRatio;
          context.translate(tileCenterX, tileCenterY);
          context.rotate(Math.PI / 180 * -this.viewport.degrees);
          context.translate(-tileCenterX, -tileCenterY);
          if (tile.x === 0 && tile.y === 0) {
            context.fillText(
              "Zoom: " + this.viewport.getZoom(),
              tile.position.x * $2.pixelDensityRatio,
              (tile.position.y - 30) * $2.pixelDensityRatio
            );
            context.fillText(
              "Pan: " + this.viewport.getBounds().toString(),
              tile.position.x * $2.pixelDensityRatio,
              (tile.position.y - 20) * $2.pixelDensityRatio
            );
          }
          context.fillText(
            "Level: " + tile.level,
            (tile.position.x + 10) * $2.pixelDensityRatio,
            (tile.position.y + 20) * $2.pixelDensityRatio
          );
          context.fillText(
            "Column: " + tile.x,
            (tile.position.x + 10) * $2.pixelDensityRatio,
            (tile.position.y + 30) * $2.pixelDensityRatio
          );
          context.fillText(
            "Row: " + tile.y,
            (tile.position.x + 10) * $2.pixelDensityRatio,
            (tile.position.y + 40) * $2.pixelDensityRatio
          );
          context.fillText(
            "Order: " + i + " of " + count,
            (tile.position.x + 10) * $2.pixelDensityRatio,
            (tile.position.y + 50) * $2.pixelDensityRatio
          );
          context.fillText(
            "Size: " + tile.size.toString(),
            (tile.position.x + 10) * $2.pixelDensityRatio,
            (tile.position.y + 60) * $2.pixelDensityRatio
          );
          context.fillText(
            "Position: " + tile.position.toString(),
            (tile.position.x + 10) * $2.pixelDensityRatio,
            (tile.position.y + 70) * $2.pixelDensityRatio
          );
          if (this.viewport.degrees !== 0) {
            this._restoreRotationChanges();
          }
          if (tiledImage.getRotation(true) % 360 !== 0) {
            this._restoreRotationChanges();
          }
          if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0) {
            if (tiledImage._drawer.viewer.viewport.getFlip()) {
              tiledImage._drawer._flip();
            }
          }
          context.restore();
        },
        // private
        debugRect: function(rect) {
          if (this.useCanvas) {
            var context = this.context;
            context.save();
            context.lineWidth = 2 * $2.pixelDensityRatio;
            context.strokeStyle = this.debugGridColor[0];
            context.fillStyle = this.debugGridColor[0];
            context.strokeRect(
              rect.x * $2.pixelDensityRatio,
              rect.y * $2.pixelDensityRatio,
              rect.width * $2.pixelDensityRatio,
              rect.height * $2.pixelDensityRatio
            );
            context.restore();
          }
        },
        /**
         * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
         *
         * @function
         * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
         * drawn smoothly on the canvas; see imageSmoothingEnabled in
         * {@link OpenSeadragon.Options} for more explanation.
         */
        setImageSmoothingEnabled: function(imageSmoothingEnabled) {
          if (this.useCanvas) {
            this._imageSmoothingEnabled = imageSmoothingEnabled;
            this._updateImageSmoothingEnabled(this.context);
            this.viewer.forceRedraw();
          }
        },
        // private
        _updateImageSmoothingEnabled: function(context) {
          context.msImageSmoothingEnabled = this._imageSmoothingEnabled;
          context.imageSmoothingEnabled = this._imageSmoothingEnabled;
        },
        /**
         * Get the canvas size
         * @param {Boolean} sketch If set to true return the size of the sketch canvas
         * @returns {OpenSeadragon.Point} The size of the canvas
         */
        getCanvasSize: function(sketch) {
          var canvas = this._getContext(sketch).canvas;
          return new $2.Point(canvas.width, canvas.height);
        },
        getCanvasCenter: function() {
          return new $2.Point(this.canvas.width / 2, this.canvas.height / 2);
        },
        // private
        _offsetForRotation: function(options) {
          var point = options.point ? options.point.times($2.pixelDensityRatio) : this.getCanvasCenter();
          var context = this._getContext(options.useSketch);
          context.save();
          context.translate(point.x, point.y);
          if (this.viewer.viewport.flipped) {
            context.rotate(Math.PI / 180 * -options.degrees);
            context.scale(-1, 1);
          } else {
            context.rotate(Math.PI / 180 * options.degrees);
          }
          context.translate(-point.x, -point.y);
        },
        // private
        _flip: function(options) {
          options = options || {};
          var point = options.point ? options.point.times($2.pixelDensityRatio) : this.getCanvasCenter();
          var context = this._getContext(options.useSketch);
          context.translate(point.x, 0);
          context.scale(-1, 1);
          context.translate(-point.x, 0);
        },
        // private
        _restoreRotationChanges: function(useSketch) {
          var context = this._getContext(useSketch);
          context.restore();
        },
        // private
        _calculateCanvasSize: function() {
          var pixelDensityRatio = $2.pixelDensityRatio;
          var viewportSize = this.viewport.getContainerSize();
          return {
            // canvas width and height are integers
            x: Math.round(viewportSize.x * pixelDensityRatio),
            y: Math.round(viewportSize.y * pixelDensityRatio)
          };
        },
        // private
        _calculateSketchCanvasSize: function() {
          var canvasSize = this._calculateCanvasSize();
          if (this.viewport.getRotation() === 0) {
            return canvasSize;
          }
          var sketchCanvasSize = Math.ceil(Math.sqrt(
            canvasSize.x * canvasSize.x + canvasSize.y * canvasSize.y
          ));
          return {
            x: sketchCanvasSize,
            y: sketchCanvasSize
          };
        }
      };
    })(OpenSeadragon);
    (function($2) {
      $2.Viewport = function(options) {
        var args = arguments;
        if (args.length && args[0] instanceof $2.Point) {
          options = {
            containerSize: args[0],
            contentSize: args[1],
            config: args[2]
          };
        }
        if (options.config) {
          $2.extend(true, options, options.config);
          delete options.config;
        }
        this._margins = $2.extend({
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }, options.margins || {});
        delete options.margins;
        $2.extend(true, this, {
          //required settings
          containerSize: null,
          contentSize: null,
          //internal state properties
          zoomPoint: null,
          viewer: null,
          //configurable options
          springStiffness: $2.DEFAULT_SETTINGS.springStiffness,
          animationTime: $2.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio: $2.DEFAULT_SETTINGS.minZoomImageRatio,
          maxZoomPixelRatio: $2.DEFAULT_SETTINGS.maxZoomPixelRatio,
          visibilityRatio: $2.DEFAULT_SETTINGS.visibilityRatio,
          wrapHorizontal: $2.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical: $2.DEFAULT_SETTINGS.wrapVertical,
          defaultZoomLevel: $2.DEFAULT_SETTINGS.defaultZoomLevel,
          minZoomLevel: $2.DEFAULT_SETTINGS.minZoomLevel,
          maxZoomLevel: $2.DEFAULT_SETTINGS.maxZoomLevel,
          degrees: $2.DEFAULT_SETTINGS.degrees,
          flipped: $2.DEFAULT_SETTINGS.flipped,
          homeFillsViewer: $2.DEFAULT_SETTINGS.homeFillsViewer
        }, options);
        this._updateContainerInnerSize();
        this.centerSpringX = new $2.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this.centerSpringY = new $2.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this.zoomSpring = new $2.Spring({
          exponential: true,
          initial: 1,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._oldCenterX = this.centerSpringX.current.value;
        this._oldCenterY = this.centerSpringY.current.value;
        this._oldZoom = this.zoomSpring.current.value;
        this._setContentBounds(new $2.Rect(0, 0, 1, 1), 1);
        this.goHome(true);
        this.update();
      };
      $2.Viewport.prototype = {
        /**
         * Updates the viewport's home bounds and constraints for the given content size.
         * @function
         * @param {OpenSeadragon.Point} contentSize - size of the content in content units
         * @return {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:reset-size
         */
        resetContentSize: function(contentSize) {
          $2.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
          $2.console.assert(contentSize instanceof $2.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
          $2.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
          $2.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");
          this._setContentBounds(new $2.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
          return this;
        },
        // deprecated
        setHomeBounds: function(bounds, contentFactor) {
          $2.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");
          this._setContentBounds(bounds, contentFactor);
        },
        // Set the viewport's content bounds
        // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
        // without rotation
        // @param {Number} contentFactor - how many content units per viewport unit
        // @fires OpenSeadragon.Viewer.event:reset-size
        // @private
        _setContentBounds: function(bounds, contentFactor) {
          $2.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");
          $2.console.assert(bounds instanceof $2.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");
          $2.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");
          $2.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");
          this._contentBoundsNoRotate = bounds.clone();
          this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
            contentFactor
          );
          this._contentBounds = bounds.rotate(this.degrees).getBoundingBox();
          this._contentSize = this._contentBounds.getSize().times(contentFactor);
          this._contentAspectRatio = this._contentSize.x / this._contentSize.y;
          if (this.viewer) {
            this.viewer.raiseEvent("reset-size", {
              contentSize: this._contentSizeNoRotate.clone(),
              contentFactor,
              homeBounds: this._contentBoundsNoRotate.clone(),
              contentBounds: this._contentBounds.clone()
            });
          }
        },
        /**
         * Returns the home zoom in "viewport zoom" value.
         * @function
         * @returns {Number} The home zoom in "viewport zoom".
         */
        getHomeZoom: function() {
          if (this.defaultZoomLevel) {
            return this.defaultZoomLevel;
          }
          var aspectFactor = this._contentAspectRatio / this.getAspectRatio();
          var output;
          if (this.homeFillsViewer) {
            output = aspectFactor >= 1 ? aspectFactor : 1;
          } else {
            output = aspectFactor >= 1 ? 1 : aspectFactor;
          }
          return output / this._contentBounds.width;
        },
        /**
         * Returns the home bounds in viewport coordinates.
         * @function
         * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
         */
        getHomeBounds: function() {
          return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
        },
        /**
         * Returns the home bounds in viewport coordinates.
         * This method ignores the viewport rotation. Use
         * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
         * @function
         * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
         */
        getHomeBoundsNoRotate: function() {
          var center = this._contentBounds.getCenter();
          var width = 1 / this.getHomeZoom();
          var height = width / this.getAspectRatio();
          return new $2.Rect(
            center.x - width / 2,
            center.y - height / 2,
            width,
            height
          );
        },
        /**
         * @function
         * @param {Boolean} immediately
         * @fires OpenSeadragon.Viewer.event:home
         */
        goHome: function(immediately) {
          if (this.viewer) {
            this.viewer.raiseEvent("home", {
              immediately
            });
          }
          return this.fitBounds(this.getHomeBounds(), immediately);
        },
        /**
         * @function
         */
        getMinZoom: function() {
          var homeZoom = this.getHomeZoom(), zoom = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * homeZoom;
          return zoom;
        },
        /**
         * @function
         */
        getMaxZoom: function() {
          var zoom = this.maxZoomLevel;
          if (!zoom) {
            zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
            zoom /= this._contentBounds.width;
          }
          return Math.max(zoom, this.getHomeZoom());
        },
        /**
         * @function
         */
        getAspectRatio: function() {
          return this._containerInnerSize.x / this._containerInnerSize.y;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
         */
        getContainerSize: function() {
          return new $2.Point(
            this.containerSize.x,
            this.containerSize.y
          );
        },
        /**
         * The margins push the "home" region in from the sides by the specified amounts.
         * @function
         * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
         */
        getMargins: function() {
          return $2.extend({}, this._margins);
        },
        /**
         * The margins push the "home" region in from the sides by the specified amounts.
         * @function
         * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
         */
        setMargins: function(margins) {
          $2.console.assert($2.type(margins) === "object", "[Viewport.setMargins] margins must be an object");
          this._margins = $2.extend({
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          }, margins);
          this._updateContainerInnerSize();
          if (this.viewer) {
            this.viewer.forceRedraw();
          }
        },
        /**
         * Returns the bounds of the visible area in viewport coordinates.
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
         */
        getBounds: function(current) {
          return this.getBoundsNoRotate(current).rotate(-this.getRotation());
        },
        /**
         * Returns the bounds of the visible area in viewport coordinates.
         * This method ignores the viewport rotation. Use
         * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
         */
        getBoundsNoRotate: function(current) {
          var center = this.getCenter(current);
          var width = 1 / this.getZoom(current);
          var height = width / this.getAspectRatio();
          return new $2.Rect(
            center.x - width / 2,
            center.y - height / 2,
            width,
            height
          );
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
         * including the space taken by margins, in viewport coordinates.
         */
        getBoundsWithMargins: function(current) {
          return this.getBoundsNoRotateWithMargins(current).rotate(
            -this.getRotation(),
            this.getCenter(current)
          );
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
         * including the space taken by margins, in viewport coordinates.
         */
        getBoundsNoRotateWithMargins: function(current) {
          var bounds = this.getBoundsNoRotate(current);
          var factor = this._containerInnerSize.x * this.getZoom(current);
          bounds.x -= this._margins.left / factor;
          bounds.y -= this._margins.top / factor;
          bounds.width += (this._margins.left + this._margins.right) / factor;
          bounds.height += (this._margins.top + this._margins.bottom) / factor;
          return bounds;
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         */
        getCenter: function(current) {
          var centerCurrent = new $2.Point(
            this.centerSpringX.current.value,
            this.centerSpringY.current.value
          ), centerTarget = new $2.Point(
            this.centerSpringX.target.value,
            this.centerSpringY.target.value
          ), oldZoomPixel, zoom, width, height, bounds, newZoomPixel, deltaZoomPixels, deltaZoomPoints;
          if (current) {
            return centerCurrent;
          } else if (!this.zoomPoint) {
            return centerTarget;
          }
          oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
          zoom = this.getZoom();
          width = 1 / zoom;
          height = width / this.getAspectRatio();
          bounds = new $2.Rect(
            centerCurrent.x - width / 2,
            centerCurrent.y - height / 2,
            width,
            height
          );
          newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
          deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
          deltaZoomPoints = deltaZoomPixels.divide(this._containerInnerSize.x * zoom);
          return centerTarget.plus(deltaZoomPoints);
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         */
        getZoom: function(current) {
          if (current) {
            return this.zoomSpring.current.value;
          } else {
            return this.zoomSpring.target.value;
          }
        },
        // private
        _applyZoomConstraints: function(zoom) {
          return Math.max(
            Math.min(zoom, this.getMaxZoom()),
            this.getMinZoom()
          );
        },
        /**
         * @function
         * @private
         * @param {OpenSeadragon.Rect} bounds
         * @return {OpenSeadragon.Rect} constrained bounds.
         */
        _applyBoundaryConstraints: function(bounds) {
          var newBounds = new $2.Rect(
            bounds.x,
            bounds.y,
            bounds.width,
            bounds.height
          );
          if (this.wrapHorizontal) {
          } else {
            var horizontalThreshold = this.visibilityRatio * newBounds.width;
            var boundsRight = newBounds.x + newBounds.width;
            var contentRight = this._contentBoundsNoRotate.x + this._contentBoundsNoRotate.width;
            var leftDx = this._contentBoundsNoRotate.x - boundsRight + horizontalThreshold;
            var rightDx = contentRight - newBounds.x - horizontalThreshold;
            if (horizontalThreshold > this._contentBoundsNoRotate.width) {
              newBounds.x += (leftDx + rightDx) / 2;
            } else if (rightDx < 0) {
              newBounds.x += rightDx;
            } else if (leftDx > 0) {
              newBounds.x += leftDx;
            }
          }
          if (this.wrapVertical) {
          } else {
            var verticalThreshold = this.visibilityRatio * newBounds.height;
            var boundsBottom = newBounds.y + newBounds.height;
            var contentBottom = this._contentBoundsNoRotate.y + this._contentBoundsNoRotate.height;
            var topDy = this._contentBoundsNoRotate.y - boundsBottom + verticalThreshold;
            var bottomDy = contentBottom - newBounds.y - verticalThreshold;
            if (verticalThreshold > this._contentBoundsNoRotate.height) {
              newBounds.y += (topDy + bottomDy) / 2;
            } else if (bottomDy < 0) {
              newBounds.y += bottomDy;
            } else if (topDy > 0) {
              newBounds.y += topDy;
            }
          }
          return newBounds;
        },
        /**
         * @function
         * @private
         * @param {Boolean} [immediately=false] - whether the function that triggered this event was
         * called with the "immediately" flag
         */
        _raiseConstraintsEvent: function(immediately) {
          if (this.viewer) {
            this.viewer.raiseEvent("constrain", {
              immediately
            });
          }
        },
        /**
         * Enforces the minZoom, maxZoom and visibilityRatio constraints by
         * zooming and panning to the closest acceptable zoom and location.
         * @function
         * @param {Boolean} [immediately=false]
         * @return {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:constrain
         */
        applyConstraints: function(immediately) {
          var actualZoom = this.getZoom();
          var constrainedZoom = this._applyZoomConstraints(actualZoom);
          if (actualZoom !== constrainedZoom) {
            this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
          }
          var bounds = this.getBoundsNoRotate();
          var constrainedBounds = this._applyBoundaryConstraints(bounds);
          this._raiseConstraintsEvent(immediately);
          if (bounds.x !== constrainedBounds.x || bounds.y !== constrainedBounds.y || immediately) {
            this.fitBounds(
              constrainedBounds.rotate(-this.getRotation()),
              immediately
            );
          }
          return this;
        },
        /**
         * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
         * @function
         * @param {Boolean} [immediately=false]
         * @return {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:constrain
         */
        ensureVisible: function(immediately) {
          return this.applyConstraints(immediately);
        },
        /**
         * @function
         * @private
         * @param {OpenSeadragon.Rect} bounds
         * @param {Object} options (immediately=false, constraints=false)
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        _fitBounds: function(bounds, options) {
          options = options || {};
          var immediately = options.immediately || false;
          var constraints = options.constraints || false;
          var aspect = this.getAspectRatio();
          var center = bounds.getCenter();
          var newBounds = new $2.Rect(
            bounds.x,
            bounds.y,
            bounds.width,
            bounds.height,
            bounds.degrees + this.getRotation()
          ).getBoundingBox();
          if (newBounds.getAspectRatio() >= aspect) {
            newBounds.height = newBounds.width / aspect;
          } else {
            newBounds.width = newBounds.height * aspect;
          }
          newBounds.x = center.x - newBounds.width / 2;
          newBounds.y = center.y - newBounds.height / 2;
          var newZoom = 1 / newBounds.width;
          if (constraints) {
            var newBoundsAspectRatio = newBounds.getAspectRatio();
            var newConstrainedZoom = this._applyZoomConstraints(newZoom);
            if (newZoom !== newConstrainedZoom) {
              newZoom = newConstrainedZoom;
              newBounds.width = 1 / newZoom;
              newBounds.x = center.x - newBounds.width / 2;
              newBounds.height = newBounds.width / newBoundsAspectRatio;
              newBounds.y = center.y - newBounds.height / 2;
            }
            newBounds = this._applyBoundaryConstraints(newBounds);
            center = newBounds.getCenter();
            this._raiseConstraintsEvent(immediately);
          }
          if (immediately) {
            this.panTo(center, true);
            return this.zoomTo(newZoom, null, true);
          }
          this.panTo(this.getCenter(true), true);
          this.zoomTo(this.getZoom(true), null, true);
          var oldBounds = this.getBounds();
          var oldZoom = this.getZoom();
          if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 1e-8) {
            this.zoomTo(newZoom, true);
            return this.panTo(center, immediately);
          }
          newBounds = newBounds.rotate(-this.getRotation());
          var referencePoint = newBounds.getTopLeft().times(newZoom).minus(oldBounds.getTopLeft().times(oldZoom)).divide(newZoom - oldZoom);
          return this.zoomTo(newZoom, referencePoint, immediately);
        },
        /**
         * Makes the viewport zoom and pan so that the specified bounds take
         * as much space as possible in the viewport.
         * Note: this method ignores the constraints (minZoom, maxZoom and
         * visibilityRatio).
         * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
         * them.
         * @function
         * @param {OpenSeadragon.Rect} bounds
         * @param {Boolean} [immediately=false]
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        fitBounds: function(bounds, immediately) {
          return this._fitBounds(bounds, {
            immediately,
            constraints: false
          });
        },
        /**
         * Makes the viewport zoom and pan so that the specified bounds take
         * as much space as possible in the viewport while enforcing the constraints
         * (minZoom, maxZoom and visibilityRatio).
         * Note: because this method enforces the constraints, part of the
         * provided bounds may end up outside of the viewport.
         * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
         * @function
         * @param {OpenSeadragon.Rect} bounds
         * @param {Boolean} [immediately=false]
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        fitBoundsWithConstraints: function(bounds, immediately) {
          return this._fitBounds(bounds, {
            immediately,
            constraints: true
          });
        },
        /**
         * Zooms so the image just fills the viewer vertically.
         * @param {Boolean} immediately
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        fitVertically: function(immediately) {
          var box = new $2.Rect(
            this._contentBounds.x + this._contentBounds.width / 2,
            this._contentBounds.y,
            0,
            this._contentBounds.height
          );
          return this.fitBounds(box, immediately);
        },
        /**
         * Zooms so the image just fills the viewer horizontally.
         * @param {Boolean} immediately
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        fitHorizontally: function(immediately) {
          var box = new $2.Rect(
            this._contentBounds.x,
            this._contentBounds.y + this._contentBounds.height / 2,
            this._contentBounds.width,
            0
          );
          return this.fitBounds(box, immediately);
        },
        /**
         * Returns bounds taking constraints into account
         * Added to improve constrained panning
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        getConstrainedBounds: function(current) {
          var bounds, constrainedBounds;
          bounds = this.getBounds(current);
          constrainedBounds = this._applyBoundaryConstraints(bounds);
          return constrainedBounds;
        },
        /**
         * @function
         * @param {OpenSeadragon.Point} delta
         * @param {Boolean} immediately
         * @return {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:pan
         */
        panBy: function(delta, immediately) {
          var center = new $2.Point(
            this.centerSpringX.target.value,
            this.centerSpringY.target.value
          );
          return this.panTo(center.plus(delta), immediately);
        },
        /**
         * @function
         * @param {OpenSeadragon.Point} center
         * @param {Boolean} immediately
         * @return {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:pan
         */
        panTo: function(center, immediately) {
          if (immediately) {
            this.centerSpringX.resetTo(center.x);
            this.centerSpringY.resetTo(center.y);
          } else {
            this.centerSpringX.springTo(center.x);
            this.centerSpringY.springTo(center.y);
          }
          if (this.viewer) {
            this.viewer.raiseEvent("pan", {
              center,
              immediately
            });
          }
          return this;
        },
        /**
         * @function
         * @return {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:zoom
         */
        zoomBy: function(factor, refPoint, immediately) {
          return this.zoomTo(
            this.zoomSpring.target.value * factor,
            refPoint,
            immediately
          );
        },
        /**
         * Zooms to the specified zoom level
         * @function
         * @param {Number} zoom The zoom level to zoom to.
         * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
         * the same screen location. Defaults to the viewport center.
         * @param {Boolean} [immediately=false]
         * @return {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:zoom
         */
        zoomTo: function(zoom, refPoint, immediately) {
          var _this = this;
          this.zoomPoint = refPoint instanceof $2.Point && !isNaN(refPoint.x) && !isNaN(refPoint.y) ? refPoint : null;
          if (immediately) {
            this._adjustCenterSpringsForZoomPoint(function() {
              _this.zoomSpring.resetTo(zoom);
            });
          } else {
            this.zoomSpring.springTo(zoom);
          }
          if (this.viewer) {
            this.viewer.raiseEvent("zoom", {
              zoom,
              refPoint,
              immediately
            });
          }
          return this;
        },
        /**
         * Rotates this viewport to the angle specified.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        setRotation: function(degrees) {
          if (!this.viewer || !this.viewer.drawer.canRotate()) {
            return this;
          }
          this.degrees = $2.positiveModulo(degrees, 360);
          this._setContentBounds(
            this.viewer.world.getHomeBounds(),
            this.viewer.world.getContentFactor()
          );
          this.viewer.forceRedraw();
          this.viewer.raiseEvent("rotate", { "degrees": degrees });
          return this;
        },
        /**
         * Gets the current rotation in degrees.
         * @function
         * @return {Number} The current rotation in degrees.
         */
        getRotation: function() {
          return this.degrees;
        },
        /**
         * @function
         * @return {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:resize
         */
        resize: function(newContainerSize, maintain) {
          var oldBounds = this.getBoundsNoRotate(), newBounds = oldBounds, widthDeltaFactor;
          this.containerSize.x = newContainerSize.x;
          this.containerSize.y = newContainerSize.y;
          this._updateContainerInnerSize();
          if (maintain) {
            widthDeltaFactor = newContainerSize.x / this.containerSize.x;
            newBounds.width = oldBounds.width * widthDeltaFactor;
            newBounds.height = newBounds.width / this.getAspectRatio();
          }
          if (this.viewer) {
            this.viewer.raiseEvent("resize", {
              newContainerSize,
              maintain
            });
          }
          return this.fitBounds(newBounds, true);
        },
        // private
        _updateContainerInnerSize: function() {
          this._containerInnerSize = new $2.Point(
            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
          );
        },
        /**
         * Update the zoom and center (X and Y) springs.
         * @function
         * @returns {Boolean} True if any change has been made, false otherwise.
         */
        update: function() {
          var _this = this;
          this._adjustCenterSpringsForZoomPoint(function() {
            _this.zoomSpring.update();
          });
          this.centerSpringX.update();
          this.centerSpringY.update();
          var changed = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom;
          this._oldCenterX = this.centerSpringX.current.value;
          this._oldCenterY = this.centerSpringY.current.value;
          this._oldZoom = this.zoomSpring.current.value;
          return changed;
        },
        _adjustCenterSpringsForZoomPoint: function(zoomSpringHandler) {
          if (this.zoomPoint) {
            var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
            zoomSpringHandler();
            var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
            var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
            var deltaZoomPoints = this.deltaPointsFromPixels(
              deltaZoomPixels,
              true
            );
            this.centerSpringX.shiftBy(deltaZoomPoints.x);
            this.centerSpringY.shiftBy(deltaZoomPoints.y);
            if (this.zoomSpring.isAtTargetValue()) {
              this.zoomPoint = null;
            }
          } else {
            zoomSpringHandler();
          }
        },
        /**
         * Convert a delta (translation vector) from viewport coordinates to pixels
         * coordinates. This method does not take rotation into account.
         * Consider using deltaPixelsFromPoints if you need to account for rotation.
         * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {
          return deltaPoints.times(
            this._containerInnerSize.x * this.getZoom(current)
          );
        },
        /**
         * Convert a delta (translation vector) from viewport coordinates to pixels
         * coordinates.
         * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPixelsFromPoints: function(deltaPoints, current) {
          return this.deltaPixelsFromPointsNoRotate(
            deltaPoints.rotate(this.getRotation()),
            current
          );
        },
        /**
         * Convert a delta (translation vector) from pixels coordinates to viewport
         * coordinates. This method does not take rotation into account.
         * Consider using deltaPointsFromPixels if you need to account for rotation.
         * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {
          return deltaPixels.divide(
            this._containerInnerSize.x * this.getZoom(current)
          );
        },
        /**
         * Convert a delta (translation vector) from pixels coordinates to viewport
         * coordinates.
         * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPointsFromPixels: function(deltaPixels, current) {
          return this.deltaPointsFromPixelsNoRotate(deltaPixels, current).rotate(-this.getRotation());
        },
        /**
         * Convert viewport coordinates to pixels coordinates.
         * This method does not take rotation into account.
         * Consider using pixelFromPoint if you need to account for rotation.
         * @param {OpenSeadragon.Point} point the viewport coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pixelFromPointNoRotate: function(point, current) {
          return this._pixelFromPointNoRotate(
            point,
            this.getBoundsNoRotate(current)
          );
        },
        /**
         * Convert viewport coordinates to pixel coordinates.
         * @param {OpenSeadragon.Point} point the viewport coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pixelFromPoint: function(point, current) {
          return this._pixelFromPoint(point, this.getBoundsNoRotate(current));
        },
        // private
        _pixelFromPointNoRotate: function(point, bounds) {
          return point.minus(
            bounds.getTopLeft()
          ).times(
            this._containerInnerSize.x / bounds.width
          ).plus(
            new $2.Point(this._margins.left, this._margins.top)
          );
        },
        // private
        _pixelFromPoint: function(point, bounds) {
          return this._pixelFromPointNoRotate(
            point.rotate(this.getRotation(), this.getCenter(true)),
            bounds
          );
        },
        /**
         * Convert pixel coordinates to viewport coordinates.
         * This method does not take rotation into account.
         * Consider using pointFromPixel if you need to account for rotation.
         * @param {OpenSeadragon.Point} pixel Pixel coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pointFromPixelNoRotate: function(pixel, current) {
          var bounds = this.getBoundsNoRotate(current);
          return pixel.minus(
            new $2.Point(this._margins.left, this._margins.top)
          ).divide(
            this._containerInnerSize.x / bounds.width
          ).plus(
            bounds.getTopLeft()
          );
        },
        /**
         * Convert pixel coordinates to viewport coordinates.
         * @param {OpenSeadragon.Point} pixel Pixel coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pointFromPixel: function(pixel, current) {
          return this.pointFromPixelNoRotate(pixel, current).rotate(
            -this.getRotation(),
            this.getCenter(true)
          );
        },
        // private
        _viewportToImageDelta: function(viewerX, viewerY) {
          var scale = this._contentBoundsNoRotate.width;
          return new $2.Point(
            viewerX * this._contentSizeNoRotate.x / scale,
            viewerY * this._contentSizeNoRotate.x / scale
          );
        },
        /**
         * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
         * This method can be called either by passing X,Y coordinates or an
         * OpenSeadragon.Point
         * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
         * @function
         * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
         * coordinate in viewport coordinate system.
         * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
         * @return {OpenSeadragon.Point} a point representing the coordinates in the image.
         */
        viewportToImageCoordinates: function(viewerX, viewerY) {
          if (viewerX instanceof $2.Point) {
            return this.viewportToImageCoordinates(viewerX.x, viewerX.y);
          }
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              $2.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.viewportToImageCoordinates(viewerX, viewerY, true);
            }
          }
          return this._viewportToImageDelta(
            viewerX - this._contentBoundsNoRotate.x,
            viewerY - this._contentBoundsNoRotate.y
          );
        },
        // private
        _imageToViewportDelta: function(imageX, imageY) {
          var scale = this._contentBoundsNoRotate.width;
          return new $2.Point(
            imageX / this._contentSizeNoRotate.x * scale,
            imageY / this._contentSizeNoRotate.x * scale
          );
        },
        /**
         * Translates from image coordinate system to OpenSeadragon viewer coordinate system
         * This method can be called either by passing X,Y coordinates or an
         * OpenSeadragon.Point
         * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
         * @function
         * @param {(OpenSeadragon.Point | Number)} imageX the point or the
         * X coordinate in image coordinate system.
         * @param {Number} [imageY] Y coordinate in image coordinate system.
         * @return {OpenSeadragon.Point} a point representing the coordinates in the viewport.
         */
        imageToViewportCoordinates: function(imageX, imageY) {
          if (imageX instanceof $2.Point) {
            return this.imageToViewportCoordinates(imageX.x, imageX.y);
          }
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              $2.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.imageToViewportCoordinates(imageX, imageY, true);
            }
          }
          var point = this._imageToViewportDelta(imageX, imageY);
          point.x += this._contentBoundsNoRotate.x;
          point.y += this._contentBoundsNoRotate.y;
          return point;
        },
        /**
         * Translates from a rectangle which describes a portion of the image in
         * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an
         * OpenSeadragon.Rect
         * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
         * @function
         * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
         * coordinate of the top left corner of the rectangle in image coordinate system.
         * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
         * in image coordinate system.
         * @param {Number} [pixelWidth] the width in pixel of the rectangle.
         * @param {Number} [pixelHeight] the height in pixel of the rectangle.
         * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
         */
        imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
          var rect = imageX;
          if (!(rect instanceof $2.Rect)) {
            rect = new $2.Rect(imageX, imageY, pixelWidth, pixelHeight);
          }
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              $2.console.error("[Viewport.imageToViewportRectangle] is not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.");
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.imageToViewportRectangle(
                imageX,
                imageY,
                pixelWidth,
                pixelHeight,
                true
              );
            }
          }
          var coordA = this.imageToViewportCoordinates(rect.x, rect.y);
          var coordB = this._imageToViewportDelta(rect.width, rect.height);
          return new $2.Rect(
            coordA.x,
            coordA.y,
            coordB.x,
            coordB.y,
            rect.degrees
          );
        },
        /**
         * Translates from a rectangle which describes a portion of
         * the viewport in point coordinates to image rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an
         * OpenSeadragon.Rect
         * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
         * @function
         * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
         * the X coordinate of the top left corner of the rectangle in viewport
         * coordinate system.
         * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
         * in viewport coordinate system.
         * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
         * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
         */
        viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
          var rect = viewerX;
          if (!(rect instanceof $2.Rect)) {
            rect = new $2.Rect(viewerX, viewerY, pointWidth, pointHeight);
          }
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              $2.console.error("[Viewport.viewportToImageRectangle] is not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.");
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.viewportToImageRectangle(
                viewerX,
                viewerY,
                pointWidth,
                pointHeight,
                true
              );
            }
          }
          var coordA = this.viewportToImageCoordinates(rect.x, rect.y);
          var coordB = this._viewportToImageDelta(rect.width, rect.height);
          return new $2.Rect(
            coordA.x,
            coordA.y,
            coordB.x,
            coordB.y,
            rect.degrees
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to image
         * coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToImageCoordinates: function(pixel) {
          var point = this.pointFromPixel(pixel, true);
          return this.viewportToImageCoordinates(point);
        },
        /**
         * Convert pixel coordinates relative to the image to
         * viewer element coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToViewerElementCoordinates: function(pixel) {
          var point = this.imageToViewportCoordinates(pixel);
          return this.pixelFromPoint(point, true);
        },
        /**
         * Convert pixel coordinates relative to the window to image coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToImageCoordinates: function(pixel) {
          $2.console.assert(
            this.viewer,
            "[Viewport.windowToImageCoordinates] the viewport must have a viewer."
          );
          var viewerCoordinates = pixel.minus(
            $2.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToImageCoordinates(viewerCoordinates);
        },
        /**
         * Convert image coordinates to pixel coordinates relative to the window.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToWindowCoordinates: function(pixel) {
          $2.console.assert(
            this.viewer,
            "[Viewport.imageToWindowCoordinates] the viewport must have a viewer."
          );
          var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
          return viewerCoordinates.plus(
            $2.getElementPosition(this.viewer.element)
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to viewport
         * coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToViewportCoordinates: function(pixel) {
          return this.pointFromPixel(pixel, true);
        },
        /**
         * Convert viewport coordinates to pixel coordinates relative to the
         * viewer element.
         * @param {OpenSeadragon.Point} point
         * @returns {OpenSeadragon.Point}
         */
        viewportToViewerElementCoordinates: function(point) {
          return this.pixelFromPoint(point, true);
        },
        /**
         * Convert a rectangle in pixel coordinates relative to the viewer element
         * to viewport coordinates.
         * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
         * @returns {OpenSeadragon.Rect} the converted rectangle
         */
        viewerElementToViewportRectangle: function(rectangle) {
          return $2.Rect.fromSummits(
            this.pointFromPixel(rectangle.getTopLeft(), true),
            this.pointFromPixel(rectangle.getTopRight(), true),
            this.pointFromPixel(rectangle.getBottomLeft(), true)
          );
        },
        /**
         * Convert a rectangle in viewport coordinates to pixel coordinates relative
         * to the viewer element.
         * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
         * @returns {OpenSeadragon.Rect} the converted rectangle
         */
        viewportToViewerElementRectangle: function(rectangle) {
          return $2.Rect.fromSummits(
            this.pixelFromPoint(rectangle.getTopLeft(), true),
            this.pixelFromPoint(rectangle.getTopRight(), true),
            this.pixelFromPoint(rectangle.getBottomLeft(), true)
          );
        },
        /**
         * Convert pixel coordinates relative to the window to viewport coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToViewportCoordinates: function(pixel) {
          $2.console.assert(
            this.viewer,
            "[Viewport.windowToViewportCoordinates] the viewport must have a viewer."
          );
          var viewerCoordinates = pixel.minus(
            $2.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToViewportCoordinates(viewerCoordinates);
        },
        /**
         * Convert viewport coordinates to pixel coordinates relative to the window.
         * @param {OpenSeadragon.Point} point
         * @returns {OpenSeadragon.Point}
         */
        viewportToWindowCoordinates: function(point) {
          $2.console.assert(
            this.viewer,
            "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer."
          );
          var viewerCoordinates = this.viewportToViewerElementCoordinates(point);
          return viewerCoordinates.plus(
            $2.getElementPosition(this.viewer.element)
          );
        },
        /**
         * Convert a viewport zoom to an image zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image.
         * @function
         * @param {Number} viewportZoom The viewport zoom
         * target zoom.
         * @returns {Number} imageZoom The image zoom
         */
        viewportToImageZoom: function(viewportZoom) {
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              $2.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.viewportToImageZoom(viewportZoom);
            }
          }
          var imageWidth = this._contentSizeNoRotate.x;
          var containerWidth = this._containerInnerSize.x;
          var scale = this._contentBoundsNoRotate.width;
          var viewportToImageZoomRatio = containerWidth / imageWidth * scale;
          return viewportZoom * viewportToImageZoomRatio;
        },
        /**
         * Convert an image zoom to a viewport zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image.
         * @function
         * @param {Number} imageZoom The image zoom
         * target zoom.
         * @returns {Number} viewportZoom The viewport zoom
         */
        imageToViewportZoom: function(imageZoom) {
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              $2.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image.");
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.imageToViewportZoom(imageZoom);
            }
          }
          var imageWidth = this._contentSizeNoRotate.x;
          var containerWidth = this._containerInnerSize.x;
          var scale = this._contentBoundsNoRotate.width;
          var viewportToImageZoomRatio = imageWidth / containerWidth / scale;
          return imageZoom * viewportToImageZoomRatio;
        },
        /**
         * Toggles flip state and demands a new drawing on navigator and viewer objects.
         * @function
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        toggleFlip: function() {
          this.setFlip(!this.getFlip());
          return this;
        },
        /**
         * Get flip state stored on viewport.
         * @function
         * @return {Boolean} Flip state.
         */
        getFlip: function() {
          return this.flipped;
        },
        /**
         * Sets flip state according to the state input argument.
         * @function
         * @param {Boolean} state - Flip state to set.
         * @return {OpenSeadragon.Viewport} Chainable.
         */
        setFlip: function(state) {
          if (this.flipped === state) {
            return this;
          }
          this.flipped = state;
          if (this.viewer.navigator) {
            this.viewer.navigator.setFlip(this.getFlip());
          }
          this.viewer.forceRedraw();
          this.viewer.raiseEvent("flip", { "flipped": state });
          return this;
        }
      };
    })(OpenSeadragon);
    (function($2) {
      $2.TiledImage = function(options) {
        var _this = this;
        $2.console.assert(options.tileCache, "[TiledImage] options.tileCache is required");
        $2.console.assert(options.drawer, "[TiledImage] options.drawer is required");
        $2.console.assert(options.viewer, "[TiledImage] options.viewer is required");
        $2.console.assert(options.imageLoader, "[TiledImage] options.imageLoader is required");
        $2.console.assert(options.source, "[TiledImage] options.source is required");
        $2.console.assert(
          !options.clip || options.clip instanceof $2.Rect,
          "[TiledImage] options.clip must be an OpenSeadragon.Rect if present"
        );
        $2.EventSource.call(this);
        this._tileCache = options.tileCache;
        delete options.tileCache;
        this._drawer = options.drawer;
        delete options.drawer;
        this._imageLoader = options.imageLoader;
        delete options.imageLoader;
        if (options.clip instanceof $2.Rect) {
          this._clip = options.clip.clone();
        }
        delete options.clip;
        var x = options.x || 0;
        delete options.x;
        var y = options.y || 0;
        delete options.y;
        this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
        this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;
        var scale = 1;
        if (options.width) {
          scale = options.width;
          delete options.width;
          if (options.height) {
            $2.console.error("specifying both width and height to a tiledImage is not supported");
            delete options.height;
          }
        } else if (options.height) {
          scale = options.height / this.normHeight;
          delete options.height;
        }
        var fitBounds = options.fitBounds;
        delete options.fitBounds;
        var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;
        delete options.fitBoundsPlacement;
        var degrees = options.degrees || 0;
        delete options.degrees;
        $2.extend(true, this, {
          //internal state properties
          viewer: null,
          tilesMatrix: {},
          // A '3d' dictionary [level][x][y] --> Tile.
          coverage: {},
          // A '3d' dictionary [level][x][y] --> Boolean; shows what areas have been drawn.
          loadingCoverage: {},
          // A '3d' dictionary [level][x][y] --> Boolean; shows what areas are loaded or are being loaded/blended.
          lastDrawn: [],
          // An unordered list of Tiles drawn last frame.
          lastResetTime: 0,
          // Last time for which the tiledImage was reset.
          _midDraw: false,
          // Is the tiledImage currently updating the viewport?
          _needsDraw: true,
          // Does the tiledImage need to update the viewport again?
          _hasOpaqueTile: false,
          // Do we have even one fully opaque tile?
          _tilesLoading: 0,
          // The number of pending tile requests.
          //configurable settings
          springStiffness: $2.DEFAULT_SETTINGS.springStiffness,
          animationTime: $2.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio: $2.DEFAULT_SETTINGS.minZoomImageRatio,
          wrapHorizontal: $2.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical: $2.DEFAULT_SETTINGS.wrapVertical,
          immediateRender: $2.DEFAULT_SETTINGS.immediateRender,
          blendTime: $2.DEFAULT_SETTINGS.blendTime,
          alwaysBlend: $2.DEFAULT_SETTINGS.alwaysBlend,
          minPixelRatio: $2.DEFAULT_SETTINGS.minPixelRatio,
          smoothTileEdgesMinZoom: $2.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
          iOSDevice: $2.DEFAULT_SETTINGS.iOSDevice,
          debugMode: $2.DEFAULT_SETTINGS.debugMode,
          crossOriginPolicy: $2.DEFAULT_SETTINGS.crossOriginPolicy,
          ajaxWithCredentials: $2.DEFAULT_SETTINGS.ajaxWithCredentials,
          placeholderFillStyle: $2.DEFAULT_SETTINGS.placeholderFillStyle,
          opacity: $2.DEFAULT_SETTINGS.opacity,
          preload: $2.DEFAULT_SETTINGS.preload,
          compositeOperation: $2.DEFAULT_SETTINGS.compositeOperation
        }, options);
        this._preload = this.preload;
        delete this.preload;
        this._fullyLoaded = false;
        this._xSpring = new $2.Spring({
          initial: x,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._ySpring = new $2.Spring({
          initial: y,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._scaleSpring = new $2.Spring({
          initial: scale,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._degreesSpring = new $2.Spring({
          initial: degrees,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._updateForScale();
        if (fitBounds) {
          this.fitBounds(fitBounds, fitBoundsPlacement, true);
        }
        this._drawingHandler = function(args) {
          _this.viewer.raiseEvent("tile-drawing", $2.extend({
            tiledImage: _this
          }, args));
        };
      };
      $2.extend(
        $2.TiledImage.prototype,
        $2.EventSource.prototype,
        /** @lends OpenSeadragon.TiledImage.prototype */
        {
          /**
           * @returns {Boolean} Whether the TiledImage needs to be drawn.
           */
          needsDraw: function() {
            return this._needsDraw;
          },
          /**
           * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
           */
          getFullyLoaded: function() {
            return this._fullyLoaded;
          },
          // private
          _setFullyLoaded: function(flag) {
            if (flag === this._fullyLoaded) {
              return;
            }
            this._fullyLoaded = flag;
            this.raiseEvent("fully-loaded-change", {
              fullyLoaded: this._fullyLoaded
            });
          },
          /**
           * Clears all tiles and triggers an update on the next call to
           * {@link OpenSeadragon.TiledImage#update}.
           */
          reset: function() {
            this._tileCache.clearTilesFor(this);
            this.lastResetTime = $2.now();
            this._needsDraw = true;
          },
          /**
           * Updates the TiledImage's bounds, animating if needed.
           * @returns {Boolean} Whether the TiledImage animated.
           */
          update: function() {
            var xUpdated = this._xSpring.update();
            var yUpdated = this._ySpring.update();
            var scaleUpdated = this._scaleSpring.update();
            var degreesUpdated = this._degreesSpring.update();
            if (xUpdated || yUpdated || scaleUpdated || degreesUpdated) {
              this._updateForScale();
              this._needsDraw = true;
              return true;
            }
            return false;
          },
          /**
           * Draws the TiledImage to its Drawer.
           */
          draw: function() {
            if (this.opacity !== 0 || this._preload) {
              this._midDraw = true;
              this._updateViewport();
              this._midDraw = false;
            } else {
              this._needsDraw = false;
            }
          },
          /**
           * Destroy the TiledImage (unload current loaded tiles).
           */
          destroy: function() {
            this.reset();
          },
          /**
           * Get this TiledImage's bounds in viewport coordinates.
           * @param {Boolean} [current=false] - Pass true for the current location;
           * false for target location.
           * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
           */
          getBounds: function(current) {
            return this.getBoundsNoRotate(current).rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          /**
           * Get this TiledImage's bounds in viewport coordinates without taking
           * rotation into account.
           * @param {Boolean} [current=false] - Pass true for the current location;
           * false for target location.
           * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
           */
          getBoundsNoRotate: function(current) {
            return current ? new $2.Rect(
              this._xSpring.current.value,
              this._ySpring.current.value,
              this._worldWidthCurrent,
              this._worldHeightCurrent
            ) : new $2.Rect(
              this._xSpring.target.value,
              this._ySpring.target.value,
              this._worldWidthTarget,
              this._worldHeightTarget
            );
          },
          // deprecated
          getWorldBounds: function() {
            $2.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead");
            return this.getBounds();
          },
          /**
           * Get the bounds of the displayed part of the tiled image.
           * @param {Boolean} [current=false] Pass true for the current location,
           * false for the target location.
           * @returns {$.Rect} The clipped bounds in viewport coordinates.
           */
          getClippedBounds: function(current) {
            var bounds = this.getBoundsNoRotate(current);
            if (this._clip) {
              var worldWidth = current ? this._worldWidthCurrent : this._worldWidthTarget;
              var ratio = worldWidth / this.source.dimensions.x;
              var clip = this._clip.times(ratio);
              bounds = new $2.Rect(
                bounds.x + clip.x,
                bounds.y + clip.y,
                clip.width,
                clip.height
              );
            }
            return bounds.rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          /**
           * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
           */
          getContentSize: function() {
            return new $2.Point(this.source.dimensions.x, this.source.dimensions.y);
          },
          // private
          _viewportToImageDelta: function(viewerX, viewerY, current) {
            var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new $2.Point(
              viewerX * (this.source.dimensions.x / scale),
              viewerY * (this.source.dimensions.y * this.contentAspectX / scale)
            );
          },
          /**
           * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
           * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
           * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
           * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @return {OpenSeadragon.Point} A point representing the coordinates in the image.
           */
          viewportToImageCoordinates: function(viewerX, viewerY, current) {
            var point;
            if (viewerX instanceof $2.Point) {
              current = viewerY;
              point = viewerX;
            } else {
              point = new $2.Point(viewerX, viewerY);
            }
            point = point.rotate(-this.getRotation(current), this._getRotationPoint(current));
            return current ? this._viewportToImageDelta(
              point.x - this._xSpring.current.value,
              point.y - this._ySpring.current.value
            ) : this._viewportToImageDelta(
              point.x - this._xSpring.target.value,
              point.y - this._ySpring.target.value
            );
          },
          // private
          _imageToViewportDelta: function(imageX, imageY, current) {
            var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new $2.Point(
              imageX / this.source.dimensions.x * scale,
              imageY / this.source.dimensions.y / this.contentAspectX * scale
            );
          },
          /**
           * Translates from image coordinate system to OpenSeadragon viewer coordinate system
           * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
           * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
           * @param {Number} [imageY] - The Y coordinate in image coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @return {OpenSeadragon.Point} A point representing the coordinates in the viewport.
           */
          imageToViewportCoordinates: function(imageX, imageY, current) {
            if (imageX instanceof $2.Point) {
              current = imageY;
              imageY = imageX.y;
              imageX = imageX.x;
            }
            var point = this._imageToViewportDelta(imageX, imageY);
            if (current) {
              point.x += this._xSpring.current.value;
              point.y += this._ySpring.current.value;
            } else {
              point.x += this._xSpring.target.value;
              point.y += this._ySpring.target.value;
            }
            return point.rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          /**
           * Translates from a rectangle which describes a portion of the image in
           * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
           * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
           * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
           * @param {Number} [imageY] - The top coordinate in image coordinate system.
           * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
           * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @return {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
           */
          imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
            var rect = imageX;
            if (rect instanceof $2.Rect) {
              current = imageY;
            } else {
              rect = new $2.Rect(imageX, imageY, pixelWidth, pixelHeight);
            }
            var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);
            var coordB = this._imageToViewportDelta(rect.width, rect.height, current);
            return new $2.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees + this.getRotation(current)
            );
          },
          /**
           * Translates from a rectangle which describes a portion of
           * the viewport in point coordinates to image rectangle coordinates.
           * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
           * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
           * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
           * @param {Number} [pointWidth] - The width in viewport coordinate system.
           * @param {Number} [pointHeight] - The height in viewport coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @return {OpenSeadragon.Rect} A rect representing the coordinates in the image.
           */
          viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight, current) {
            var rect = viewerX;
            if (viewerX instanceof $2.Rect) {
              current = viewerY;
            } else {
              rect = new $2.Rect(viewerX, viewerY, pointWidth, pointHeight);
            }
            var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);
            var coordB = this._viewportToImageDelta(rect.width, rect.height, current);
            return new $2.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees - this.getRotation(current)
            );
          },
          /**
           * Convert pixel coordinates relative to the viewer element to image
           * coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          viewerElementToImageCoordinates: function(pixel) {
            var point = this.viewport.pointFromPixel(pixel, true);
            return this.viewportToImageCoordinates(point);
          },
          /**
           * Convert pixel coordinates relative to the image to
           * viewer element coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          imageToViewerElementCoordinates: function(pixel) {
            var point = this.imageToViewportCoordinates(pixel);
            return this.viewport.pixelFromPoint(point, true);
          },
          /**
           * Convert pixel coordinates relative to the window to image coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          windowToImageCoordinates: function(pixel) {
            var viewerCoordinates = pixel.minus(
              OpenSeadragon.getElementPosition(this.viewer.element)
            );
            return this.viewerElementToImageCoordinates(viewerCoordinates);
          },
          /**
           * Convert image coordinates to pixel coordinates relative to the window.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          imageToWindowCoordinates: function(pixel) {
            var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
            return viewerCoordinates.plus(
              OpenSeadragon.getElementPosition(this.viewer.element)
            );
          },
          // private
          // Convert rectangle in viewport coordinates to this tiled image point
          // coordinates (x in [0, 1] and y in [0, aspectRatio])
          _viewportToTiledImageRectangle: function(rect) {
            var scale = this._scaleSpring.current.value;
            rect = rect.rotate(-this.getRotation(true), this._getRotationPoint(true));
            return new $2.Rect(
              (rect.x - this._xSpring.current.value) / scale,
              (rect.y - this._ySpring.current.value) / scale,
              rect.width / scale,
              rect.height / scale,
              rect.degrees
            );
          },
          /**
           * Convert a viewport zoom to an image zoom.
           * Image zoom: ratio of the original image size to displayed image size.
           * 1 means original image size, 0.5 half size...
           * Viewport zoom: ratio of the displayed image's width to viewport's width.
           * 1 means identical width, 2 means image's width is twice the viewport's width...
           * @function
           * @param {Number} viewportZoom The viewport zoom
           * @returns {Number} imageZoom The image zoom
           */
          viewportToImageZoom: function(viewportZoom) {
            var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return ratio * viewportZoom;
          },
          /**
           * Convert an image zoom to a viewport zoom.
           * Image zoom: ratio of the original image size to displayed image size.
           * 1 means original image size, 0.5 half size...
           * Viewport zoom: ratio of the displayed image's width to viewport's width.
           * 1 means identical width, 2 means image's width is twice the viewport's width...
           * Note: not accurate with multi-image.
           * @function
           * @param {Number} imageZoom The image zoom
           * @returns {Number} viewportZoom The viewport zoom
           */
          imageToViewportZoom: function(imageZoom) {
            var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return imageZoom / ratio;
          },
          /**
           * Sets the TiledImage's position in the world.
           * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setPosition: function(position, immediately) {
            var sameTarget = this._xSpring.target.value === position.x && this._ySpring.target.value === position.y;
            if (immediately) {
              if (sameTarget && this._xSpring.current.value === position.x && this._ySpring.current.value === position.y) {
                return;
              }
              this._xSpring.resetTo(position.x);
              this._ySpring.resetTo(position.y);
              this._needsDraw = true;
            } else {
              if (sameTarget) {
                return;
              }
              this._xSpring.springTo(position.x);
              this._ySpring.springTo(position.y);
              this._needsDraw = true;
            }
            if (!sameTarget) {
              this._raiseBoundsChange();
            }
          },
          /**
           * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
           * @param {Number} width - The new width, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setWidth: function(width, immediately) {
            this._setScale(width, immediately);
          },
          /**
           * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
           * @param {Number} height - The new height, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setHeight: function(height, immediately) {
            this._setScale(height / this.normHeight, immediately);
          },
          /**
           * Sets an array of polygons to crop the TiledImage during draw tiles.
           * The render function will use the default non-zero winding rule.
           * @param Polygons represented in an array of point object in image coordinates.
           * Example format: [
           *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
           *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
           *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
           * ]
           */
          setCroppingPolygons: function(polygons) {
            var isXYObject = function(obj) {
              return obj instanceof $2.Point || typeof obj.x === "number" && typeof obj.y === "number";
            };
            var objectToSimpleXYObject = function(objs) {
              return objs.map(function(obj) {
                try {
                  if (isXYObject(obj)) {
                    return { x: obj.x, y: obj.y };
                  } else {
                    throw new Error();
                  }
                } catch (e) {
                  throw new Error("A Provided cropping polygon point is not supported");
                }
              });
            };
            try {
              if (!$2.isArray(polygons)) {
                throw new Error("Provided cropping polygon is not an array");
              }
              this._croppingPolygons = polygons.map(function(polygon) {
                return objectToSimpleXYObject(polygon);
              });
            } catch (e) {
              $2.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported");
              $2.console.error(e);
              this._croppingPolygons = null;
            }
          },
          /**
           * Resets the cropping polygons, thus next render will remove all cropping
           * polygon effects.
           */
          resetCroppingPolygons: function() {
            this._croppingPolygons = null;
          },
          /**
           * Positions and scales the TiledImage to fit in the specified bounds.
           * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
           * twice
           * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
           * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
           * How to anchor the image in the bounds.
           * @param {Boolean} [immediately=false] Whether to animate to the new size
           * or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          fitBounds: function(bounds, anchor, immediately) {
            anchor = anchor || $2.Placement.CENTER;
            var anchorProperties = $2.Placement.properties[anchor];
            var aspectRatio = this.contentAspectX;
            var xOffset = 0;
            var yOffset = 0;
            var displayedWidthRatio = 1;
            var displayedHeightRatio = 1;
            if (this._clip) {
              aspectRatio = this._clip.getAspectRatio();
              displayedWidthRatio = this._clip.width / this.source.dimensions.x;
              displayedHeightRatio = this._clip.height / this.source.dimensions.y;
              if (bounds.getAspectRatio() > aspectRatio) {
                xOffset = this._clip.x / this._clip.height * bounds.height;
                yOffset = this._clip.y / this._clip.height * bounds.height;
              } else {
                xOffset = this._clip.x / this._clip.width * bounds.width;
                yOffset = this._clip.y / this._clip.width * bounds.width;
              }
            }
            if (bounds.getAspectRatio() > aspectRatio) {
              var height = bounds.height / displayedHeightRatio;
              var marginLeft = 0;
              if (anchorProperties.isHorizontallyCentered) {
                marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;
              } else if (anchorProperties.isRight) {
                marginLeft = bounds.width - bounds.height * aspectRatio;
              }
              this.setPosition(
                new $2.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),
                immediately
              );
              this.setHeight(height, immediately);
            } else {
              var width = bounds.width / displayedWidthRatio;
              var marginTop = 0;
              if (anchorProperties.isVerticallyCentered) {
                marginTop = (bounds.height - bounds.width / aspectRatio) / 2;
              } else if (anchorProperties.isBottom) {
                marginTop = bounds.height - bounds.width / aspectRatio;
              }
              this.setPosition(
                new $2.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),
                immediately
              );
              this.setWidth(width, immediately);
            }
          },
          /**
           * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
           * in image pixels, or null if none.
           */
          getClip: function() {
            if (this._clip) {
              return this._clip.clone();
            }
            return null;
          },
          /**
           * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
           * (portions of the image outside of this area will not be visible). Only works on
           * browsers that support the HTML5 canvas.
           * @fires OpenSeadragon.TiledImage.event:clip-change
           */
          setClip: function(newClip) {
            $2.console.assert(
              !newClip || newClip instanceof $2.Rect,
              "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null"
            );
            if (newClip instanceof $2.Rect) {
              this._clip = newClip.clone();
            } else {
              this._clip = null;
            }
            this._needsDraw = true;
            this.raiseEvent("clip-change");
          },
          /**
           * @returns {Number} The TiledImage's current opacity.
           */
          getOpacity: function() {
            return this.opacity;
          },
          /**
           * @param {Number} opacity Opacity the tiled image should be drawn at.
           * @fires OpenSeadragon.TiledImage.event:opacity-change
           */
          setOpacity: function(opacity) {
            if (opacity === this.opacity) {
              return;
            }
            this.opacity = opacity;
            this._needsDraw = true;
            this.raiseEvent("opacity-change", {
              opacity: this.opacity
            });
          },
          /**
           * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
           */
          getPreload: function() {
            return this._preload;
          },
          /**
           * Set true to load even when hidden. Set false to block loading when hidden.
           */
          setPreload: function(preload) {
            this._preload = !!preload;
            this._needsDraw = true;
          },
          /**
           * Get the rotation of this tiled image in degrees.
           * @param {Boolean} [current=false] True for current rotation, false for target.
           * @returns {Number} the rotation of this tiled image in degrees.
           */
          getRotation: function(current) {
            return current ? this._degreesSpring.current.value : this._degreesSpring.target.value;
          },
          /**
           * Set the current rotation of this tiled image in degrees.
           * @param {Number} degrees the rotation in degrees.
           * @param {Boolean} [immediately=false] Whether to animate to the new angle
           * or rotate immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setRotation: function(degrees, immediately) {
            if (this._degreesSpring.target.value === degrees && this._degreesSpring.isAtTargetValue()) {
              return;
            }
            if (immediately) {
              this._degreesSpring.resetTo(degrees);
            } else {
              this._degreesSpring.springTo(degrees);
            }
            this._needsDraw = true;
            this._raiseBoundsChange();
          },
          /**
           * Get the point around which this tiled image is rotated
           * @private
           * @param {Boolean} current True for current rotation point, false for target.
           * @returns {OpenSeadragon.Point}
           */
          _getRotationPoint: function(current) {
            return this.getBoundsNoRotate(current).getCenter();
          },
          /**
           * @returns {String} The TiledImage's current compositeOperation.
           */
          getCompositeOperation: function() {
            return this.compositeOperation;
          },
          /**
           * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
           * @fires OpenSeadragon.TiledImage.event:composite-operation-change
           */
          setCompositeOperation: function(compositeOperation) {
            if (compositeOperation === this.compositeOperation) {
              return;
            }
            this.compositeOperation = compositeOperation;
            this._needsDraw = true;
            this.raiseEvent("composite-operation-change", {
              compositeOperation: this.compositeOperation
            });
          },
          // private
          _setScale: function(scale, immediately) {
            var sameTarget = this._scaleSpring.target.value === scale;
            if (immediately) {
              if (sameTarget && this._scaleSpring.current.value === scale) {
                return;
              }
              this._scaleSpring.resetTo(scale);
              this._updateForScale();
              this._needsDraw = true;
            } else {
              if (sameTarget) {
                return;
              }
              this._scaleSpring.springTo(scale);
              this._updateForScale();
              this._needsDraw = true;
            }
            if (!sameTarget) {
              this._raiseBoundsChange();
            }
          },
          // private
          _updateForScale: function() {
            this._worldWidthTarget = this._scaleSpring.target.value;
            this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
            this._worldWidthCurrent = this._scaleSpring.current.value;
            this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
          },
          // private
          _raiseBoundsChange: function() {
            this.raiseEvent("bounds-change");
          },
          // private
          _isBottomItem: function() {
            return this.viewer.world.getItemAt(0) === this;
          },
          // private
          _getLevelsInterval: function() {
            var lowestLevel = Math.max(
              this.source.minLevel,
              Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
            );
            var currentZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(0),
              true
            ).x * this._scaleSpring.current.value;
            var highestLevel = Math.min(
              Math.abs(this.source.maxLevel),
              Math.abs(Math.floor(
                Math.log(currentZeroRatio / this.minPixelRatio) / Math.log(2)
              ))
            );
            highestLevel = Math.max(highestLevel, this.source.minLevel || 0);
            lowestLevel = Math.min(lowestLevel, highestLevel);
            return {
              lowestLevel,
              highestLevel
            };
          },
          /**
           * @private
           * @inner
           * Pretty much every other line in this needs to be documented so it's clear
           * how each piece of this routine contributes to the drawing process.  That's
           * why there are so many TODO's inside this function.
           */
          _updateViewport: function() {
            this._needsDraw = false;
            this._tilesLoading = 0;
            this.loadingCoverage = {};
            while (this.lastDrawn.length > 0) {
              var tile = this.lastDrawn.pop();
              tile.beingDrawn = false;
            }
            var viewport = this.viewport;
            var drawArea = this._viewportToTiledImageRectangle(
              viewport.getBoundsWithMargins(true)
            );
            if (!this.wrapHorizontal && !this.wrapVertical) {
              var tiledImageBounds = this._viewportToTiledImageRectangle(
                this.getClippedBounds(true)
              );
              drawArea = drawArea.intersection(tiledImageBounds);
              if (drawArea === null) {
                return;
              }
            }
            var levelsInterval = this._getLevelsInterval();
            var lowestLevel = levelsInterval.lowestLevel;
            var highestLevel = levelsInterval.highestLevel;
            var bestTile = null;
            var haveDrawn = false;
            var currentTime = $2.now();
            for (var level = highestLevel; level >= lowestLevel; level--) {
              var drawLevel = false;
              var currentRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(level),
                true
              ).x * this._scaleSpring.current.value;
              if (level === lowestLevel || !haveDrawn && currentRenderPixelRatio >= this.minPixelRatio) {
                drawLevel = true;
                haveDrawn = true;
              } else if (!haveDrawn) {
                continue;
              }
              var targetRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(level),
                false
              ).x * this._scaleSpring.current.value;
              var targetZeroRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(
                  Math.max(
                    this.source.getClosestLevel(),
                    0
                  )
                ),
                false
              ).x * this._scaleSpring.current.value;
              var optimalRatio = this.immediateRender ? 1 : targetZeroRatio;
              var levelOpacity = Math.min(1, (currentRenderPixelRatio - 0.5) / 0.5);
              var levelVisibility = optimalRatio / Math.abs(
                optimalRatio - targetRenderPixelRatio
              );
              bestTile = updateLevel(
                this,
                haveDrawn,
                drawLevel,
                level,
                levelOpacity,
                levelVisibility,
                drawArea,
                currentTime,
                bestTile
              );
              if (providesCoverage(this.coverage, level)) {
                break;
              }
            }
            drawTiles(this, this.lastDrawn);
            if (bestTile && !bestTile.context2D) {
              loadTile(this, bestTile, currentTime);
              this._needsDraw = true;
              this._setFullyLoaded(false);
            } else {
              this._setFullyLoaded(this._tilesLoading === 0);
            }
          },
          // private
          _getCornerTiles: function(level, topLeftBound, bottomRightBound) {
            var leftX;
            var rightX;
            if (this.wrapHorizontal) {
              leftX = $2.positiveModulo(topLeftBound.x, 1);
              rightX = $2.positiveModulo(bottomRightBound.x, 1);
            } else {
              leftX = Math.max(0, topLeftBound.x);
              rightX = Math.min(1, bottomRightBound.x);
            }
            var topY;
            var bottomY;
            var aspectRatio = 1 / this.source.aspectRatio;
            if (this.wrapVertical) {
              topY = $2.positiveModulo(topLeftBound.y, aspectRatio);
              bottomY = $2.positiveModulo(bottomRightBound.y, aspectRatio);
            } else {
              topY = Math.max(0, topLeftBound.y);
              bottomY = Math.min(aspectRatio, bottomRightBound.y);
            }
            var topLeftTile = this.source.getTileAtPoint(level, new $2.Point(leftX, topY));
            var bottomRightTile = this.source.getTileAtPoint(level, new $2.Point(rightX, bottomY));
            var numTiles = this.source.getNumTiles(level);
            if (this.wrapHorizontal) {
              topLeftTile.x += numTiles.x * Math.floor(topLeftBound.x);
              bottomRightTile.x += numTiles.x * Math.floor(bottomRightBound.x);
            }
            if (this.wrapVertical) {
              topLeftTile.y += numTiles.y * Math.floor(topLeftBound.y / aspectRatio);
              bottomRightTile.y += numTiles.y * Math.floor(bottomRightBound.y / aspectRatio);
            }
            return {
              topLeft: topLeftTile,
              bottomRight: bottomRightTile
            };
          }
        }
      );
      function updateLevel(tiledImage, haveDrawn, drawLevel, level, levelOpacity, levelVisibility, drawArea, currentTime, best) {
        var topLeftBound = drawArea.getBoundingBox().getTopLeft();
        var bottomRightBound = drawArea.getBoundingBox().getBottomRight();
        if (tiledImage.viewer) {
          tiledImage.viewer.raiseEvent("update-level", {
            tiledImage,
            havedrawn: haveDrawn,
            level,
            opacity: levelOpacity,
            visibility: levelVisibility,
            drawArea,
            topleft: topLeftBound,
            bottomright: bottomRightBound,
            currenttime: currentTime,
            best
          });
        }
        resetCoverage(tiledImage.coverage, level);
        resetCoverage(tiledImage.loadingCoverage, level);
        var cornerTiles = tiledImage._getCornerTiles(level, topLeftBound, bottomRightBound);
        var topLeftTile = cornerTiles.topLeft;
        var bottomRightTile = cornerTiles.bottomRight;
        var numberOfTiles = tiledImage.source.getNumTiles(level);
        var viewportCenter = tiledImage.viewport.pixelFromPoint(
          tiledImage.viewport.getCenter()
        );
        for (var x = topLeftTile.x; x <= bottomRightTile.x; x++) {
          for (var y = topLeftTile.y; y <= bottomRightTile.y; y++) {
            if (!tiledImage.wrapHorizontal && !tiledImage.wrapVertical) {
              var tileBounds = tiledImage.source.getTileBounds(level, x, y);
              if (drawArea.intersection(tileBounds) === null) {
                continue;
              }
            }
            best = updateTile(
              tiledImage,
              drawLevel,
              haveDrawn,
              x,
              y,
              level,
              levelOpacity,
              levelVisibility,
              viewportCenter,
              numberOfTiles,
              currentTime,
              best
            );
          }
        }
        return best;
      }
      function updateTile(tiledImage, haveDrawn, drawLevel, x, y, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best) {
        var tile = getTile(
          x,
          y,
          level,
          tiledImage,
          tiledImage.source,
          tiledImage.tilesMatrix,
          currentTime,
          numberOfTiles,
          tiledImage._worldWidthCurrent,
          tiledImage._worldHeightCurrent
        ), drawTile = drawLevel;
        if (tiledImage.viewer) {
          tiledImage.viewer.raiseEvent("update-tile", {
            tiledImage,
            tile
          });
        }
        setCoverage(tiledImage.coverage, level, x, y, false);
        var loadingCoverage = tile.loaded || tile.loading || isCovered(tiledImage.loadingCoverage, level, x, y);
        setCoverage(tiledImage.loadingCoverage, level, x, y, loadingCoverage);
        if (!tile.exists) {
          return best;
        }
        if (haveDrawn && !drawTile) {
          if (isCovered(tiledImage.coverage, level, x, y)) {
            setCoverage(tiledImage.coverage, level, x, y, true);
          } else {
            drawTile = true;
          }
        }
        if (!drawTile) {
          return best;
        }
        positionTile(
          tile,
          tiledImage.source.tileOverlap,
          tiledImage.viewport,
          viewportCenter,
          levelVisibility,
          tiledImage
        );
        if (!tile.loaded) {
          if (tile.context2D) {
            setTileLoaded(tiledImage, tile);
          } else {
            var imageRecord = tiledImage._tileCache.getImageRecord(tile.cacheKey);
            if (imageRecord) {
              var image = imageRecord.getImage();
              setTileLoaded(tiledImage, tile, image);
            }
          }
        }
        if (tile.loaded) {
          var needsDraw = blendTile(
            tiledImage,
            tile,
            x,
            y,
            level,
            levelOpacity,
            currentTime
          );
          if (needsDraw) {
            tiledImage._needsDraw = true;
          }
        } else if (tile.loading) {
          tiledImage._tilesLoading++;
        } else if (!loadingCoverage) {
          best = compareTiles(best, tile);
        }
        return best;
      }
      function getTile(x, y, level, tiledImage, tileSource, tilesMatrix, time, numTiles, worldWidth, worldHeight) {
        var xMod, yMod, bounds, sourceBounds, exists, url, ajaxHeaders, context2D, tile;
        if (!tilesMatrix[level]) {
          tilesMatrix[level] = {};
        }
        if (!tilesMatrix[level][x]) {
          tilesMatrix[level][x] = {};
        }
        if (!tilesMatrix[level][x][y]) {
          xMod = (numTiles.x + x % numTiles.x) % numTiles.x;
          yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
          bounds = tileSource.getTileBounds(level, xMod, yMod);
          sourceBounds = tileSource.getTileBounds(level, xMod, yMod, true);
          exists = tileSource.tileExists(level, xMod, yMod);
          url = tileSource.getTileUrl(level, xMod, yMod);
          if (tiledImage.loadTilesWithAjax) {
            ajaxHeaders = tileSource.getTileAjaxHeaders(level, xMod, yMod);
            if ($2.isPlainObject(tiledImage.ajaxHeaders)) {
              ajaxHeaders = $2.extend({}, tiledImage.ajaxHeaders, ajaxHeaders);
            }
          } else {
            ajaxHeaders = null;
          }
          context2D = tileSource.getContext2D ? tileSource.getContext2D(level, xMod, yMod) : void 0;
          bounds.x += (x - xMod) / numTiles.x;
          bounds.y += worldHeight / worldWidth * ((y - yMod) / numTiles.y);
          tile = new $2.Tile(
            level,
            x,
            y,
            bounds,
            exists,
            url,
            context2D,
            tiledImage.loadTilesWithAjax,
            ajaxHeaders,
            sourceBounds
          );
          if (xMod === numTiles.x - 1) {
            tile.isRightMost = true;
          }
          if (yMod === numTiles.y - 1) {
            tile.isBottomMost = true;
          }
          tilesMatrix[level][x][y] = tile;
        }
        tile = tilesMatrix[level][x][y];
        tile.lastTouchTime = time;
        return tile;
      }
      function loadTile(tiledImage, tile, time) {
        tile.loading = true;
        tiledImage._imageLoader.addJob({
          src: tile.url,
          loadWithAjax: tile.loadWithAjax,
          ajaxHeaders: tile.ajaxHeaders,
          crossOriginPolicy: tiledImage.crossOriginPolicy,
          ajaxWithCredentials: tiledImage.ajaxWithCredentials,
          callback: function(image, errorMsg, tileRequest) {
            onTileLoad(tiledImage, tile, time, image, errorMsg, tileRequest);
          },
          abort: function() {
            tile.loading = false;
          }
        });
      }
      function onTileLoad(tiledImage, tile, time, image, errorMsg, tileRequest) {
        if (!image) {
          $2.console.log("Tile %s failed to load: %s - error: %s", tile, tile.url, errorMsg);
          tiledImage.viewer.raiseEvent("tile-load-failed", {
            tile,
            tiledImage,
            time,
            message: errorMsg,
            tileRequest
          });
          tile.loading = false;
          tile.exists = false;
          return;
        }
        if (time < tiledImage.lastResetTime) {
          $2.console.log("Ignoring tile %s loaded before reset: %s", tile, tile.url);
          tile.loading = false;
          return;
        }
        var finish = function() {
          var cutoff = tiledImage.source.getClosestLevel();
          setTileLoaded(tiledImage, tile, image, cutoff, tileRequest);
        };
        if (!tiledImage._midDraw) {
          finish();
        } else {
          window.setTimeout(finish, 1);
        }
      }
      function setTileLoaded(tiledImage, tile, image, cutoff, tileRequest) {
        var increment = 0;
        function getCompletionCallback() {
          increment++;
          return completionCallback;
        }
        function completionCallback() {
          increment--;
          if (increment === 0) {
            tile.loading = false;
            tile.loaded = true;
            if (!tile.context2D) {
              tiledImage._tileCache.cacheTile({
                image,
                tile,
                cutoff,
                tiledImage
              });
            }
            tiledImage._needsDraw = true;
          }
        }
        tiledImage.viewer.raiseEvent("tile-loaded", {
          tile,
          tiledImage,
          tileRequest,
          image,
          getCompletionCallback
        });
        getCompletionCallback()();
      }
      function positionTile(tile, overlap, viewport, viewportCenter, levelVisibility, tiledImage) {
        var boundsTL = tile.bounds.getTopLeft();
        boundsTL.x *= tiledImage._scaleSpring.current.value;
        boundsTL.y *= tiledImage._scaleSpring.current.value;
        boundsTL.x += tiledImage._xSpring.current.value;
        boundsTL.y += tiledImage._ySpring.current.value;
        var boundsSize = tile.bounds.getSize();
        boundsSize.x *= tiledImage._scaleSpring.current.value;
        boundsSize.y *= tiledImage._scaleSpring.current.value;
        var positionC = viewport.pixelFromPointNoRotate(boundsTL, true), positionT = viewport.pixelFromPointNoRotate(boundsTL, false), sizeC = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true), sizeT = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false), tileCenter = positionT.plus(sizeT.divide(2)), tileSquaredDistance = viewportCenter.squaredDistanceTo(tileCenter);
        if (!overlap) {
          sizeC = sizeC.plus(new $2.Point(1, 1));
        }
        if (tile.isRightMost && tiledImage.wrapHorizontal) {
          sizeC.x += 0.75;
        }
        if (tile.isBottomMost && tiledImage.wrapVertical) {
          sizeC.y += 0.75;
        }
        tile.position = positionC;
        tile.size = sizeC;
        tile.squaredDistance = tileSquaredDistance;
        tile.visibility = levelVisibility;
      }
      function blendTile(tiledImage, tile, x, y, level, levelOpacity, currentTime) {
        var blendTimeMillis = 1e3 * tiledImage.blendTime, deltaTime, opacity;
        if (!tile.blendStart) {
          tile.blendStart = currentTime;
        }
        deltaTime = currentTime - tile.blendStart;
        opacity = blendTimeMillis ? Math.min(1, deltaTime / blendTimeMillis) : 1;
        if (tiledImage.alwaysBlend) {
          opacity *= levelOpacity;
        }
        tile.opacity = opacity;
        tiledImage.lastDrawn.push(tile);
        if (opacity === 1) {
          setCoverage(tiledImage.coverage, level, x, y, true);
          tiledImage._hasOpaqueTile = true;
        } else if (deltaTime < blendTimeMillis) {
          return true;
        }
        return false;
      }
      function providesCoverage(coverage, level, x, y) {
        var rows, cols, i, j;
        if (!coverage[level]) {
          return false;
        }
        if (x === void 0 || y === void 0) {
          rows = coverage[level];
          for (i in rows) {
            if (Object.prototype.hasOwnProperty.call(rows, i)) {
              cols = rows[i];
              for (j in cols) {
                if (Object.prototype.hasOwnProperty.call(cols, j) && !cols[j]) {
                  return false;
                }
              }
            }
          }
          return true;
        }
        return coverage[level][x] === void 0 || coverage[level][x][y] === void 0 || coverage[level][x][y] === true;
      }
      function isCovered(coverage, level, x, y) {
        if (x === void 0 || y === void 0) {
          return providesCoverage(coverage, level + 1);
        } else {
          return providesCoverage(coverage, level + 1, 2 * x, 2 * y) && providesCoverage(coverage, level + 1, 2 * x, 2 * y + 1) && providesCoverage(coverage, level + 1, 2 * x + 1, 2 * y) && providesCoverage(coverage, level + 1, 2 * x + 1, 2 * y + 1);
        }
      }
      function setCoverage(coverage, level, x, y, covers) {
        if (!coverage[level]) {
          $2.console.warn(
            "Setting coverage for a tile before its level's coverage has been reset: %s",
            level
          );
          return;
        }
        if (!coverage[level][x]) {
          coverage[level][x] = {};
        }
        coverage[level][x][y] = covers;
      }
      function resetCoverage(coverage, level) {
        coverage[level] = {};
      }
      function compareTiles(previousBest, tile) {
        if (!previousBest) {
          return tile;
        }
        if (tile.visibility > previousBest.visibility) {
          return tile;
        } else if (tile.visibility == previousBest.visibility) {
          if (tile.squaredDistance < previousBest.squaredDistance) {
            return tile;
          }
        }
        return previousBest;
      }
      function drawTiles(tiledImage, lastDrawn) {
        if (tiledImage.opacity === 0 || lastDrawn.length === 0 && !tiledImage.placeholderFillStyle) {
          return;
        }
        var tile = lastDrawn[0];
        var useSketch;
        if (tile) {
          useSketch = tiledImage.opacity < 1 || tiledImage.compositeOperation && tiledImage.compositeOperation !== "source-over" || !tiledImage._isBottomItem() && tile._hasTransparencyChannel();
        }
        var sketchScale;
        var sketchTranslate;
        var zoom = tiledImage.viewport.getZoom(true);
        var imageZoom = tiledImage.viewportToImageZoom(zoom);
        if (lastDrawn.length > 1 && imageZoom > tiledImage.smoothTileEdgesMinZoom && !tiledImage.iOSDevice && tiledImage.getRotation(true) % 360 === 0 && // TODO: support tile edge smoothing with tiled image rotation.
        $2.supportsCanvas) {
          useSketch = true;
          sketchScale = tile.getScaleForEdgeSmoothing();
          sketchTranslate = tile.getTranslationForEdgeSmoothing(
            sketchScale,
            tiledImage._drawer.getCanvasSize(false),
            tiledImage._drawer.getCanvasSize(true)
          );
        }
        var bounds;
        if (useSketch) {
          if (!sketchScale) {
            bounds = tiledImage.viewport.viewportToViewerElementRectangle(
              tiledImage.getClippedBounds(true)
            ).getIntegerBoundingBox();
            if (tiledImage._drawer.viewer.viewport.getFlip()) {
              if (tiledImage.viewport.degrees !== 0 || tiledImage.getRotation(true) % 360 !== 0) {
                bounds.x = tiledImage._drawer.viewer.container.clientWidth - (bounds.x + bounds.width);
              }
            }
            bounds = bounds.times($2.pixelDensityRatio);
          }
          tiledImage._drawer._clear(true, bounds);
        }
        if (!sketchScale) {
          if (tiledImage.viewport.degrees !== 0) {
            tiledImage._drawer._offsetForRotation({
              degrees: tiledImage.viewport.degrees,
              useSketch
            });
          }
          if (tiledImage.getRotation(true) % 360 !== 0) {
            tiledImage._drawer._offsetForRotation({
              degrees: tiledImage.getRotation(true),
              point: tiledImage.viewport.pixelFromPointNoRotate(
                tiledImage._getRotationPoint(true),
                true
              ),
              useSketch
            });
          }
          if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0) {
            if (tiledImage._drawer.viewer.viewport.getFlip()) {
              tiledImage._drawer._flip();
            }
          }
        }
        var usedClip = false;
        if (tiledImage._clip) {
          tiledImage._drawer.saveContext(useSketch);
          var box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);
          box = box.rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
          var clipRect = tiledImage._drawer.viewportToDrawerRectangle(box);
          if (sketchScale) {
            clipRect = clipRect.times(sketchScale);
          }
          if (sketchTranslate) {
            clipRect = clipRect.translate(sketchTranslate);
          }
          tiledImage._drawer.setClip(clipRect, useSketch);
          usedClip = true;
        }
        if (tiledImage._croppingPolygons) {
          tiledImage._drawer.saveContext(useSketch);
          try {
            var polygons = tiledImage._croppingPolygons.map(function(polygon) {
              return polygon.map(function(coord) {
                var point = tiledImage.imageToViewportCoordinates(coord.x, coord.y, true).rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
                var clipPoint = tiledImage._drawer.viewportCoordToDrawerCoord(point);
                if (sketchScale) {
                  clipPoint = clipPoint.times(sketchScale);
                }
                return clipPoint;
              });
            });
            tiledImage._drawer.clipWithPolygons(polygons, useSketch);
          } catch (e) {
            $2.console.error(e);
          }
          usedClip = true;
        }
        if (tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false) {
          var placeholderRect = tiledImage._drawer.viewportToDrawerRectangle(tiledImage.getBounds(true));
          if (sketchScale) {
            placeholderRect = placeholderRect.times(sketchScale);
          }
          if (sketchTranslate) {
            placeholderRect = placeholderRect.translate(sketchTranslate);
          }
          var fillStyle = null;
          if (typeof tiledImage.placeholderFillStyle === "function") {
            fillStyle = tiledImage.placeholderFillStyle(tiledImage, tiledImage._drawer.context);
          } else {
            fillStyle = tiledImage.placeholderFillStyle;
          }
          tiledImage._drawer.drawRectangle(placeholderRect, fillStyle, useSketch);
        }
        for (var i = lastDrawn.length - 1; i >= 0; i--) {
          tile = lastDrawn[i];
          tiledImage._drawer.drawTile(tile, tiledImage._drawingHandler, useSketch, sketchScale, sketchTranslate);
          tile.beingDrawn = true;
          if (tiledImage.viewer) {
            tiledImage.viewer.raiseEvent("tile-drawn", {
              tiledImage,
              tile
            });
          }
        }
        if (usedClip) {
          tiledImage._drawer.restoreContext(useSketch);
        }
        if (!sketchScale) {
          if (tiledImage.getRotation(true) % 360 !== 0) {
            tiledImage._drawer._restoreRotationChanges(useSketch);
          }
          if (tiledImage.viewport.degrees !== 0) {
            tiledImage._drawer._restoreRotationChanges(useSketch);
          }
        }
        if (useSketch) {
          if (sketchScale) {
            if (tiledImage.viewport.degrees !== 0) {
              tiledImage._drawer._offsetForRotation({
                degrees: tiledImage.viewport.degrees,
                useSketch: false
              });
            }
            if (tiledImage.getRotation(true) % 360 !== 0) {
              tiledImage._drawer._offsetForRotation({
                degrees: tiledImage.getRotation(true),
                point: tiledImage.viewport.pixelFromPointNoRotate(
                  tiledImage._getRotationPoint(true),
                  true
                ),
                useSketch: false
              });
            }
          }
          tiledImage._drawer.blendSketch({
            opacity: tiledImage.opacity,
            scale: sketchScale,
            translate: sketchTranslate,
            compositeOperation: tiledImage.compositeOperation,
            bounds
          });
          if (sketchScale) {
            if (tiledImage.getRotation(true) % 360 !== 0) {
              tiledImage._drawer._restoreRotationChanges(false);
            }
            if (tiledImage.viewport.degrees !== 0) {
              tiledImage._drawer._restoreRotationChanges(false);
            }
          }
        }
        if (!sketchScale) {
          if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0) {
            if (tiledImage._drawer.viewer.viewport.getFlip()) {
              tiledImage._drawer._flip();
            }
          }
        }
        drawDebugInfo(tiledImage, lastDrawn);
      }
      function drawDebugInfo(tiledImage, lastDrawn) {
        if (tiledImage.debugMode) {
          for (var i = lastDrawn.length - 1; i >= 0; i--) {
            var tile = lastDrawn[i];
            try {
              tiledImage._drawer.drawDebugInfo(
                tile,
                lastDrawn.length,
                i,
                tiledImage
              );
            } catch (e) {
              $2.console.error(e);
            }
          }
        }
      }
    })(OpenSeadragon);
    (function($2) {
      var TileRecord = function(options) {
        $2.console.assert(options, "[TileCache.cacheTile] options is required");
        $2.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
        $2.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
        this.tile = options.tile;
        this.tiledImage = options.tiledImage;
      };
      var ImageRecord = function(options) {
        $2.console.assert(options, "[ImageRecord] options is required");
        $2.console.assert(options.image, "[ImageRecord] options.image is required");
        this._image = options.image;
        this._tiles = [];
      };
      ImageRecord.prototype = {
        destroy: function() {
          this._image = null;
          this._renderedContext = null;
          this._tiles = null;
        },
        getImage: function() {
          return this._image;
        },
        getRenderedContext: function() {
          if (!this._renderedContext) {
            var canvas = document.createElement("canvas");
            canvas.width = this._image.width;
            canvas.height = this._image.height;
            this._renderedContext = canvas.getContext("2d");
            this._renderedContext.drawImage(this._image, 0, 0);
            this._image = null;
          }
          return this._renderedContext;
        },
        setRenderedContext: function(renderedContext) {
          $2.console.error("ImageRecord.setRenderedContext is deprecated. The rendered context should be created by the ImageRecord itself when calling ImageRecord.getRenderedContext.");
          this._renderedContext = renderedContext;
        },
        addTile: function(tile) {
          $2.console.assert(tile, "[ImageRecord.addTile] tile is required");
          this._tiles.push(tile);
        },
        removeTile: function(tile) {
          for (var i = 0; i < this._tiles.length; i++) {
            if (this._tiles[i] === tile) {
              this._tiles.splice(i, 1);
              return;
            }
          }
          $2.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", tile);
        },
        getTileCount: function() {
          return this._tiles.length;
        }
      };
      $2.TileCache = function(options) {
        options = options || {};
        this._maxImageCacheCount = options.maxImageCacheCount || $2.DEFAULT_SETTINGS.maxImageCacheCount;
        this._tilesLoaded = [];
        this._imagesLoaded = [];
        this._imagesLoadedCount = 0;
      };
      $2.TileCache.prototype = {
        /**
         * @returns {Number} The total number of tiles that have been loaded by
         * this TileCache.
         */
        numTilesLoaded: function() {
          return this._tilesLoaded.length;
        },
        /**
         * Caches the specified tile, removing an old tile if necessary to stay under the
         * maxImageCacheCount specified on construction. Note that if multiple tiles reference
         * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
         * the number of images below that number. Note, as well, that even the number of images
         * may temporarily surpass that number, but should eventually come back down to the max specified.
         * @param {Object} options - Tile info.
         * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
         * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
         * @param {Image} options.image - The image of the tile to cache.
         * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.
         * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
         * function will release an old tile. The cutoff option specifies a tile level at or below which
         * tiles will not be released.
         */
        cacheTile: function(options) {
          $2.console.assert(options, "[TileCache.cacheTile] options is required");
          $2.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
          $2.console.assert(options.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required");
          $2.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
          var cutoff = options.cutoff || 0;
          var insertionIndex = this._tilesLoaded.length;
          var imageRecord = this._imagesLoaded[options.tile.cacheKey];
          if (!imageRecord) {
            $2.console.assert(options.image, "[TileCache.cacheTile] options.image is required to create an ImageRecord");
            imageRecord = this._imagesLoaded[options.tile.cacheKey] = new ImageRecord({
              image: options.image
            });
            this._imagesLoadedCount++;
          }
          imageRecord.addTile(options.tile);
          options.tile.cacheImageRecord = imageRecord;
          if (this._imagesLoadedCount > this._maxImageCacheCount) {
            var worstTile = null;
            var worstTileIndex = -1;
            var worstTileRecord = null;
            var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;
            for (var i = this._tilesLoaded.length - 1; i >= 0; i--) {
              prevTileRecord = this._tilesLoaded[i];
              prevTile = prevTileRecord.tile;
              if (prevTile.level <= cutoff || prevTile.beingDrawn) {
                continue;
              } else if (!worstTile) {
                worstTile = prevTile;
                worstTileIndex = i;
                worstTileRecord = prevTileRecord;
                continue;
              }
              prevTime = prevTile.lastTouchTime;
              worstTime = worstTile.lastTouchTime;
              prevLevel = prevTile.level;
              worstLevel = worstTile.level;
              if (prevTime < worstTime || prevTime == worstTime && prevLevel > worstLevel) {
                worstTile = prevTile;
                worstTileIndex = i;
                worstTileRecord = prevTileRecord;
              }
            }
            if (worstTile && worstTileIndex >= 0) {
              this._unloadTile(worstTileRecord);
              insertionIndex = worstTileIndex;
            }
          }
          this._tilesLoaded[insertionIndex] = new TileRecord({
            tile: options.tile,
            tiledImage: options.tiledImage
          });
        },
        /**
         * Clears all tiles associated with the specified tiledImage.
         * @param {OpenSeadragon.TiledImage} tiledImage
         */
        clearTilesFor: function(tiledImage) {
          $2.console.assert(tiledImage, "[TileCache.clearTilesFor] tiledImage is required");
          var tileRecord;
          for (var i = 0; i < this._tilesLoaded.length; ++i) {
            tileRecord = this._tilesLoaded[i];
            if (tileRecord.tiledImage === tiledImage) {
              this._unloadTile(tileRecord);
              this._tilesLoaded.splice(i, 1);
              i--;
            }
          }
        },
        // private
        getImageRecord: function(cacheKey) {
          $2.console.assert(cacheKey, "[TileCache.getImageRecord] cacheKey is required");
          return this._imagesLoaded[cacheKey];
        },
        // private
        _unloadTile: function(tileRecord) {
          $2.console.assert(tileRecord, "[TileCache._unloadTile] tileRecord is required");
          var tile = tileRecord.tile;
          var tiledImage = tileRecord.tiledImage;
          tile.unload();
          tile.cacheImageRecord = null;
          var imageRecord = this._imagesLoaded[tile.cacheKey];
          imageRecord.removeTile(tile);
          if (!imageRecord.getTileCount()) {
            imageRecord.destroy();
            delete this._imagesLoaded[tile.cacheKey];
            this._imagesLoadedCount--;
          }
          tiledImage.viewer.raiseEvent("tile-unloaded", {
            tile,
            tiledImage
          });
        }
      };
    })(OpenSeadragon);
    (function($2) {
      $2.World = function(options) {
        var _this = this;
        $2.console.assert(options.viewer, "[World] options.viewer is required");
        $2.EventSource.call(this);
        this.viewer = options.viewer;
        this._items = [];
        this._needsDraw = false;
        this._autoRefigureSizes = true;
        this._needsSizesFigured = false;
        this._delegatedFigureSizes = function(event) {
          if (_this._autoRefigureSizes) {
            _this._figureSizes();
          } else {
            _this._needsSizesFigured = true;
          }
        };
        this._figureSizes();
      };
      $2.extend(
        $2.World.prototype,
        $2.EventSource.prototype,
        /** @lends OpenSeadragon.World.prototype */
        {
          /**
           * Add the specified item.
           * @param {OpenSeadragon.TiledImage} item - The item to add.
           * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          addItem: function(item, options) {
            $2.console.assert(item, "[World.addItem] item is required");
            $2.console.assert(item instanceof $2.TiledImage, "[World.addItem] only TiledImages supported at this time");
            options = options || {};
            if (options.index !== void 0) {
              var index = Math.max(0, Math.min(this._items.length, options.index));
              this._items.splice(index, 0, item);
            } else {
              this._items.push(item);
            }
            if (this._autoRefigureSizes) {
              this._figureSizes();
            } else {
              this._needsSizesFigured = true;
            }
            this._needsDraw = true;
            item.addHandler("bounds-change", this._delegatedFigureSizes);
            item.addHandler("clip-change", this._delegatedFigureSizes);
            this.raiseEvent("add-item", {
              item
            });
          },
          /**
           * Get the item at the specified index.
           * @param {Number} index - The item's index.
           * @returns {OpenSeadragon.TiledImage} The item at the specified index.
           */
          getItemAt: function(index) {
            $2.console.assert(index !== void 0, "[World.getItemAt] index is required");
            return this._items[index];
          },
          /**
           * Get the index of the given item or -1 if not present.
           * @param {OpenSeadragon.TiledImage} item - The item.
           * @returns {Number} The index of the item or -1 if not present.
           */
          getIndexOfItem: function(item) {
            $2.console.assert(item, "[World.getIndexOfItem] item is required");
            return $2.indexOf(this._items, item);
          },
          /**
           * @returns {Number} The number of items used.
           */
          getItemCount: function() {
            return this._items.length;
          },
          /**
           * Change the index of a item so that it appears over or under others.
           * @param {OpenSeadragon.TiledImage} item - The item to move.
           * @param {Number} index - The new index.
           * @fires OpenSeadragon.World.event:item-index-change
           */
          setItemIndex: function(item, index) {
            $2.console.assert(item, "[World.setItemIndex] item is required");
            $2.console.assert(index !== void 0, "[World.setItemIndex] index is required");
            var oldIndex = this.getIndexOfItem(item);
            if (index >= this._items.length) {
              throw new Error("Index bigger than number of layers.");
            }
            if (index === oldIndex || oldIndex === -1) {
              return;
            }
            this._items.splice(oldIndex, 1);
            this._items.splice(index, 0, item);
            this._needsDraw = true;
            this.raiseEvent("item-index-change", {
              item,
              previousIndex: oldIndex,
              newIndex: index
            });
          },
          /**
           * Remove an item.
           * @param {OpenSeadragon.TiledImage} item - The item to remove.
           * @fires OpenSeadragon.World.event:remove-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          removeItem: function(item) {
            $2.console.assert(item, "[World.removeItem] item is required");
            var index = $2.indexOf(this._items, item);
            if (index === -1) {
              return;
            }
            item.removeHandler("bounds-change", this._delegatedFigureSizes);
            item.removeHandler("clip-change", this._delegatedFigureSizes);
            item.destroy();
            this._items.splice(index, 1);
            this._figureSizes();
            this._needsDraw = true;
            this._raiseRemoveItem(item);
          },
          /**
           * Remove all items.
           * @fires OpenSeadragon.World.event:remove-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          removeAll: function() {
            this.viewer._cancelPendingImages();
            var item;
            var i;
            for (i = 0; i < this._items.length; i++) {
              item = this._items[i];
              item.removeHandler("bounds-change", this._delegatedFigureSizes);
              item.removeHandler("clip-change", this._delegatedFigureSizes);
              item.destroy();
            }
            var removedItems = this._items;
            this._items = [];
            this._figureSizes();
            this._needsDraw = true;
            for (i = 0; i < removedItems.length; i++) {
              item = removedItems[i];
              this._raiseRemoveItem(item);
            }
          },
          /**
           * Clears all tiles and triggers updates for all items.
           */
          resetItems: function() {
            for (var i = 0; i < this._items.length; i++) {
              this._items[i].reset();
            }
          },
          /**
           * Updates (i.e. animates bounds of) all items.
           */
          update: function() {
            var animated = false;
            for (var i = 0; i < this._items.length; i++) {
              animated = this._items[i].update() || animated;
            }
            return animated;
          },
          /**
           * Draws all items.
           */
          draw: function() {
            for (var i = 0; i < this._items.length; i++) {
              this._items[i].draw();
            }
            this._needsDraw = false;
          },
          /**
           * @returns {Boolean} true if any items need updating.
           */
          needsDraw: function() {
            for (var i = 0; i < this._items.length; i++) {
              if (this._items[i].needsDraw()) {
                return true;
              }
            }
            return this._needsDraw;
          },
          /**
           * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
           */
          getHomeBounds: function() {
            return this._homeBounds.clone();
          },
          /**
           * To facilitate zoom constraints, we keep track of the pixel density of the
           * densest item in the World (i.e. the item whose content size to viewport size
           * ratio is the highest) and save it as this "content factor".
           * @returns {Number} the number of content units per viewport unit.
           */
          getContentFactor: function() {
            return this._contentFactor;
          },
          /**
           * As a performance optimization, setting this flag to false allows the bounds-change event handler
           * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
           * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
           * or the system may behave oddly.
           * @param {Boolean} [value] The value to which to set the flag.
           */
          setAutoRefigureSizes: function(value) {
            this._autoRefigureSizes = value;
            if (value & this._needsSizesFigured) {
              this._figureSizes();
              this._needsSizesFigured = false;
            }
          },
          /**
           * Arranges all of the TiledImages with the specified settings.
           * @param {Object} options - Specifies how to arrange.
           * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
           * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
           * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
           * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
           * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
           * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
           * @fires OpenSeadragon.World.event:metrics-change
           */
          arrange: function(options) {
            options = options || {};
            var immediately = options.immediately || false;
            var layout = options.layout || $2.DEFAULT_SETTINGS.collectionLayout;
            var rows = options.rows || $2.DEFAULT_SETTINGS.collectionRows;
            var columns = options.columns || $2.DEFAULT_SETTINGS.collectionColumns;
            var tileSize = options.tileSize || $2.DEFAULT_SETTINGS.collectionTileSize;
            var tileMargin = options.tileMargin || $2.DEFAULT_SETTINGS.collectionTileMargin;
            var increment = tileSize + tileMargin;
            var wrap;
            if (!options.rows && columns) {
              wrap = columns;
            } else {
              wrap = Math.ceil(this._items.length / rows);
            }
            var x = 0;
            var y = 0;
            var item, box, width, height, position;
            this.setAutoRefigureSizes(false);
            for (var i = 0; i < this._items.length; i++) {
              if (i && i % wrap === 0) {
                if (layout === "horizontal") {
                  y += increment;
                  x = 0;
                } else {
                  x += increment;
                  y = 0;
                }
              }
              item = this._items[i];
              box = item.getBounds();
              if (box.width > box.height) {
                width = tileSize;
              } else {
                width = tileSize * (box.width / box.height);
              }
              height = width * (box.height / box.width);
              position = new $2.Point(
                x + (tileSize - width) / 2,
                y + (tileSize - height) / 2
              );
              item.setPosition(position, immediately);
              item.setWidth(width, immediately);
              if (layout === "horizontal") {
                x += increment;
              } else {
                y += increment;
              }
            }
            this.setAutoRefigureSizes(true);
          },
          // private
          _figureSizes: function() {
            var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
            var oldContentSize = this._contentSize ? this._contentSize.clone() : null;
            var oldContentFactor = this._contentFactor || 0;
            if (!this._items.length) {
              this._homeBounds = new $2.Rect(0, 0, 1, 1);
              this._contentSize = new $2.Point(1, 1);
              this._contentFactor = 1;
            } else {
              var item = this._items[0];
              var bounds = item.getBounds();
              this._contentFactor = item.getContentSize().x / bounds.width;
              var clippedBounds = item.getClippedBounds().getBoundingBox();
              var left = clippedBounds.x;
              var top = clippedBounds.y;
              var right = clippedBounds.x + clippedBounds.width;
              var bottom = clippedBounds.y + clippedBounds.height;
              for (var i = 1; i < this._items.length; i++) {
                item = this._items[i];
                bounds = item.getBounds();
                this._contentFactor = Math.max(
                  this._contentFactor,
                  item.getContentSize().x / bounds.width
                );
                clippedBounds = item.getClippedBounds().getBoundingBox();
                left = Math.min(left, clippedBounds.x);
                top = Math.min(top, clippedBounds.y);
                right = Math.max(right, clippedBounds.x + clippedBounds.width);
                bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);
              }
              this._homeBounds = new $2.Rect(left, top, right - left, bottom - top);
              this._contentSize = new $2.Point(
                this._homeBounds.width * this._contentFactor,
                this._homeBounds.height * this._contentFactor
              );
            }
            if (this._contentFactor !== oldContentFactor || !this._homeBounds.equals(oldHomeBounds) || !this._contentSize.equals(oldContentSize)) {
              this.raiseEvent("metrics-change", {});
            }
          },
          // private
          _raiseRemoveItem: function(item) {
            this.raiseEvent("remove-item", { item });
          }
        }
      );
    })(OpenSeadragon);
  }
});
export default require_openseadragon();
/*! Bundled license information:

openseadragon/build/openseadragon/openseadragon.js:
  (*! openseadragon 2.4.2 *)
  (*! Built on 2020-03-05 *)
  (*! Git commit: v2.4.2-0-c450749 *)
  (*! http://openseadragon.github.io *)
  (*! License: http://openseadragon.github.io/license/ *)
*/
//# sourceMappingURL=openseadragon.js.map
