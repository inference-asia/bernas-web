{
  "version": 3,
  "sources": ["../../@cubejs-client/vue3/src/QueryRenderer.js", "../../@cubejs-client/vue3/src/QueryBuilder.js", "../../@cubejs-client/vue3/src/index.js"],
  "sourcesContent": ["import { toPairs, fromPairs } from 'ramda';\nimport { isQueryPresent, areQueriesEqual } from '@cubejs-client/core';\nimport { h as createElement } from 'vue';\n\nexport default {\n  props: {\n    query: {\n      type: [Object, Array],\n      default: () => ({}),\n    },\n    // TODO: validate with current react implementation\n    queries: {\n      type: Object,\n    },\n    loadSql: {\n      required: false,\n    },\n    cubejsApi: {\n      type: Object,\n      required: true,\n    },\n    builderProps: {\n      type: Object,\n      required: false,\n      default: () => ({}),\n    },\n    chartType: {\n      type: String,\n      required: false,\n    },\n  },\n  data() {\n    return {\n      mutexObj: {},\n      error: undefined,\n      resultSet: undefined,\n      loading: false,\n      sqlQuery: undefined,\n    };\n  },\n  async mounted() {\n    const { query, queries } = this;\n\n    if (isQueryPresent(query)) {\n      await this.load();\n    } else if (isQueryPresent(queries)) {\n      await this.loadQueries(queries);\n    }\n  },\n  render() {\n    const { $slots, resultSet, error, loading, sqlQuery } = this;\n    const empty = createElement('div', {});\n    let slot = this.$slots.empty ? this.$slots.empty() : empty;\n    let controls = createElement('div', {});\n    const onlyDefault = !('empty' in this.$slots) && !('error' in this.$slots);\n\n    if ($slots.builder && this.builderProps.measures) {\n      controls = $slots.builder({ ...this.builderProps });\n    }\n\n    if ((!loading && resultSet && !error) || onlyDefault) {\n      let slotProps = {\n        resultSet,\n        sqlQuery,\n        query: this.builderProps.query || this.query,\n      };\n\n      if (onlyDefault) {\n        slotProps = {\n          loading,\n          error,\n          refetch: this.load,\n          ...this.builderProps,\n          ...slotProps,\n        };\n      }\n      slot = $slots.default ? $slots.default(slotProps) : slot;\n    } else if (error) {\n      slot = $slots.error ? $slots.error({ error, sqlQuery }) : slot;\n    }\n\n    return createElement('div', {}, [controls, slot]);\n  },\n  methods: {\n    async load() {\n      const { query } = this;\n\n      if (!isQueryPresent(query)) {\n        return;\n      }\n\n      try {\n        this.loading = true;\n        this.error = null;\n        this.resultSet = null;\n\n        if (this.loadSql === 'only') {\n          this.sqlQuery = await this.cubejsApi.sql(query, {\n            mutexObj: this.mutexObj,\n            mutexKey: 'sql',\n          });\n        } else if (this.loadSql) {\n          this.sqlQuery = await this.cubejsApi.sql(query, {\n            mutexObj: this.mutexObj,\n            mutexKey: 'sql',\n          });\n          this.resultSet = await this.cubejsApi.load(query, {\n            mutexObj: this.mutexObj,\n            mutexKey: 'query',\n          });\n        } else {\n          this.resultSet = await this.cubejsApi.load(query, {\n            mutexObj: this.mutexObj,\n            mutexKey: 'query',\n          });\n        }\n\n        this.loading = false;\n      } catch (error) {\n        this.error = error;\n        this.resultSet = undefined;\n        this.loading = false;\n      }\n    },\n    async loadQueries() {\n      const { queries } = this;\n      try {\n        this.error = undefined;\n        this.loading = true;\n\n        const resultPromises = Promise.all(\n          toPairs(queries).map(([name, query]) =>\n            this.cubejsApi\n              .load(query, {\n                mutexObj: this.mutexObj,\n                mutexKey: name,\n              })\n              .then((r) => [name, r])\n          )\n        );\n\n        this.resultSet = fromPairs(await resultPromises);\n        this.loading = false;\n      } catch (error) {\n        this.error = error;\n        this.loading = false;\n      }\n    },\n  },\n  watch: {\n    loading(loading) {\n      if (loading === false) {\n        this.$emit('queryStatus', {\n          isLoading: false,\n          error: this.error,\n          resultSet: this.resultSet,\n        });\n      } else {\n        this.$emit('queryStatus', { isLoading: true });\n      }\n    },\n    cubejsApi() {\n      this.load();\n    },\n    chartType() {\n      this.load();\n    },\n    query: {\n      deep: true,\n      handler(query, prevQuery) {\n        if (!areQueriesEqual(query, prevQuery)) {\n          this.load();\n        }\n      },\n    },\n    queries: {\n      handler(val) {\n        if (val) {\n          this.loadQueries();\n        }\n      },\n      deep: true,\n    },\n  },\n};\n", "import {\n  isQueryPresent,\n  defaultOrder,\n  defaultHeuristics,\n  GRANULARITIES,\n  ResultSet,\n  getOrderMembersFromOrder,\n  moveItemInArray,\n  movePivotItem,\n  areQueriesEqual,\n} from '@cubejs-client/core';\nimport { h } from 'vue';\nimport { clone, equals } from 'ramda';\n\nimport QueryRenderer from './QueryRenderer';\n\nconst QUERY_ELEMENTS = ['measures', 'dimensions', 'segments', 'timeDimensions', 'filters'];\n\nconst toOrderMember = (member) => ({\n  id: member.name,\n  title: member.title,\n});\n\nconst reduceOrderMembers = (array) =>\n  array.reduce((acc, { id, order }) => (order !== 'none' ? [...acc, [id, order]] : acc), []);\n\nconst operators = [ 'and', 'or' ]\n\nconst validateFilters = (filters) =>\n  filters.reduce((acc, raw) => {\n    if (raw.operator) {\n      return [...acc, raw];\n    }\n\n    const validBooleanFilter = operators.reduce((acc, operator) => {\n      const filters = raw[operator];\n\n      const booleanFilters = validateFilters(filters || []);\n\n      if (booleanFilters.length) {\n        return { ...acc, [operator]: booleanFilters };\n      }\n\n      return acc;\n    }, {});\n\n    if (operators.some((operator) => validBooleanFilter[operator])) {\n      return [...acc, validBooleanFilter];\n    }\n\n    return acc;\n  }, []);\n\nconst getDimensionOrMeasure = (meta, m) => {\n  const memberName = m.member || m.dimension;\n  return memberName && meta.resolveMember(memberName, ['dimensions', 'measures']);\n};\n\nconst resolveMembers = (meta, arr) =>\n  arr &&\n  arr.map((e, index) => {\n    return {\n      ...e,\n      member: getDimensionOrMeasure(meta, e),\n      index,\n      and: resolveMembers(meta, e.and),\n      or: resolveMembers(meta, e.or),\n    };\n  });\n\nexport default {\n  components: {\n    QueryRenderer,\n  },\n  props: {\n    query: {\n      type: Object,\n      default: () => ({}),\n    },\n    cubejsApi: {\n      type: Object,\n      required: true,\n    },\n    initialChartType: {\n      type: String,\n      default: () => 'line',\n    },\n    disableHeuristics: {\n      type: Boolean,\n    },\n    stateChangeHeuristics: {\n      type: Function,\n    },\n    initialVizState: {\n      type: Object,\n      default: () => ({}),\n    },\n  },\n  data() {\n    const {\n      query = this.query,\n      chartType = this.initialChartType,\n      pivotConfig,\n    } = this.initialVizState;\n\n    return {\n      initialQuery: query,\n      skipHeuristics: true,\n      meta: undefined,\n      mutex: {},\n      chartType,\n      measures: [],\n      dimensions: [],\n      segments: [],\n      timeDimensions: [],\n      filters: [],\n      availableMeasures: [],\n      availableDimensions: [],\n      availableTimeDimensions: [],\n      availableSegments: [],\n      limit: null,\n      offset: null,\n      renewQuery: false,\n      order: null,\n      prevValidatedQuery: null,\n      granularities: GRANULARITIES,\n      pivotConfig: ResultSet.getNormalizedPivotConfig(query || {}, pivotConfig),\n    };\n  },\n\n  render() {\n    const {\n      chartType,\n      cubejsApi,\n      dimensions,\n      filters,\n      measures,\n      meta,\n      query,\n      segments,\n      timeDimensions,\n      validatedQuery,\n      isQueryPresent,\n      availableSegments,\n      availableTimeDimensions,\n      availableDimensions,\n      availableMeasures,\n      limit,\n      offset,\n      setLimit,\n      removeLimit,\n      setOffset,\n      removeOffset,\n      renewQuery,\n      order,\n      orderMembers,\n    } = this;\n\n    let builderProps = {};\n\n    if (meta) {\n      builderProps = {\n        query,\n        validatedQuery,\n        isQueryPresent,\n        chartType,\n        measures,\n        dimensions,\n        segments,\n        timeDimensions,\n        filters,\n        availableSegments,\n        availableTimeDimensions,\n        availableDimensions,\n        availableMeasures,\n        updateChartType: this.updateChart,\n        limit,\n        offset,\n        setLimit,\n        removeLimit,\n        setOffset,\n        removeOffset,\n        renewQuery,\n        order,\n        orderMembers,\n        setOrder: this.setOrder,\n        pivotConfig: this.pivotConfig,\n        updateOrder: {\n          set: (memberId, newOrder) => {\n            this.order = reduceOrderMembers(\n              orderMembers.map((orderMember) => ({\n                ...orderMember,\n                order: orderMember.id === memberId ? newOrder : orderMember.order,\n              }))\n            );\n          },\n          update: (newOrder) => {\n            this.order = newOrder;\n          },\n          reorder: (sourceIndex, destinationIndex) => {\n            this.order = reduceOrderMembers(\n              moveItemInArray(orderMembers, sourceIndex, destinationIndex)\n            );\n          },\n        },\n        updatePivotConfig: {\n          moveItem: ({ sourceIndex, destinationIndex, sourceAxis, destinationAxis }) => {\n            this.pivotConfig = movePivotItem(\n              this.pivotConfig,\n              sourceIndex,\n              destinationIndex,\n              sourceAxis,\n              destinationAxis\n            );\n          },\n          update: (pivotConfig) => {\n            this.pivotConfig = {\n              x: pivotConfig.x || this.pivotConfig.x,\n              y: pivotConfig.y || this.pivotConfig.y,\n            };\n          },\n        },\n      };\n\n      QUERY_ELEMENTS.forEach((elementName) => {\n        const name = elementName.charAt(0).toUpperCase() + elementName.slice(1);\n\n        builderProps[`add${name}`] = (member) => {\n          this.addMember(elementName, member);\n        };\n\n        builderProps[`update${name}`] = (member, updateWith) => {\n          this.updateMember(elementName, member, updateWith);\n        };\n\n        builderProps[`remove${name}`] = (member) => {\n          this.removeMember(elementName, member);\n        };\n\n        builderProps[`set${name}`] = (members) => {\n          this.setMembers(elementName, members);\n        };\n      });\n    }\n\n    return h(\n      QueryRenderer,\n      {\n        query: this.validatedQuery,\n        cubejsApi,\n        builderProps,\n        slots: this.$slots,\n        on: {\n          queryStatus: (event) => {\n            this.$emit('queryStatus', event);\n          },\n        },\n      },\n      this.$slots\n    );\n  },\n  computed: {\n    isQueryPresent() {\n      const { validatedQuery } = this;\n\n      return isQueryPresent(validatedQuery);\n    },\n    orderMembers() {\n      return getOrderMembersFromOrder(\n        [\n          ...this.measures,\n          ...this.dimensions,\n          ...this.timeDimensions.map(({ dimension }) => toOrderMember(dimension)),\n        ]\n          .map((member, index) => {\n            const id = member.name || member.id;\n\n            if (!id) {\n              return false;\n            }\n\n            return {\n              index,\n              id,\n              title: member.title,\n            };\n          })\n          .filter(Boolean),\n        this.order\n      );\n    },\n    vizState() {\n      return {\n        query: this.validatedQuery,\n        chartType: this.chartType,\n        pivotConfig: this.pivotConfig,\n      };\n    },\n    validatedQuery() {\n      let validatedQuery = {};\n      let toQuery = (member) => member.name;\n      // TODO: implement timezone\n\n      let hasElements = false;\n      QUERY_ELEMENTS.forEach((element) => {\n        if (element === 'timeDimensions') {\n          toQuery = (member) => ({\n            dimension: member.dimension.name,\n            granularity: member.granularity,\n            dateRange: member.dateRange,\n          });\n        } else if (element === 'filters') {\n          toQuery = (member) => ({\n            member: member.member && member.member.name,\n            operator: member.operator,\n            values: member.values,\n            and: member.and && member.and.map(toQuery),\n            or: member.or && member.or.map(toQuery),\n          });\n        }\n\n        if (this[element].length > 0) {\n          validatedQuery[element] = this[element].map((x) => toQuery(x));\n\n          hasElements = true;\n        }\n      });\n\n      if (validatedQuery.filters) {\n        validatedQuery.filters = validateFilters(validatedQuery.filters)\n      }\n\n      // only set limit and offset if there are elements otherwise an invalid request with just limit/offset\n      // gets sent when the component is first mounted, but before the actual query is constructed.\n      if (hasElements) {\n        if (this.limit) {\n          validatedQuery.limit = this.limit;\n        }\n\n        if (this.offset) {\n          validatedQuery.offset = this.offset;\n        }\n\n        if (this.order) {\n          validatedQuery.order = this.order;\n        }\n\n        if (this.renewQuery) {\n          validatedQuery.renewQuery = this.renewQuery;\n        }\n      }\n\n      if (\n        !this.skipHeuristics &&\n        !this.disableHeuristics &&\n        isQueryPresent(validatedQuery) &&\n        this.meta\n      ) {\n        const heuristicsFn = this.stateChangeHeuristics || defaultHeuristics;\n        const { query, chartType, shouldApplyHeuristicOrder, pivotConfig } = heuristicsFn(\n          {\n            query: validatedQuery,\n            chartType: this.chartType,\n          },\n          this.prevValidatedQuery,\n          {\n            meta: this.meta,\n            sessionGranularity: validatedQuery?.timeDimensions?.[0]?.granularity,\n          }\n        );\n\n        validatedQuery = {\n          ...validatedQuery,\n          ...query,\n          ...(shouldApplyHeuristicOrder ? { order: defaultOrder(query) } : null),\n        };\n\n        this.chartType = chartType || this.chartType;\n        this.pivotConfig = ResultSet.getNormalizedPivotConfig(\n          validatedQuery,\n          pivotConfig || this.pivotConfig\n        );\n        this.copyQueryFromProps(validatedQuery);\n      }\n\n      // query heuristics should only apply on query change (not applied to the initial query)\n      if (this.prevValidatedQuery !== null) {\n        this.skipHeuristics = false;\n      }\n\n      this.prevValidatedQuery = validatedQuery;\n      return validatedQuery;\n    },\n  },\n\n  async mounted() {\n    this.meta = await this.cubejsApi.meta();\n\n    this.copyQueryFromProps();\n\n    if (isQueryPresent(this.initialQuery)) {\n      const dryRunResponse = await this.cubejsApi.dryRun(this.initialQuery);\n      this.pivotConfig = ResultSet.getNormalizedPivotConfig(\n        dryRunResponse?.pivotQuery || {},\n        this.pivotConfig\n      );\n    }\n  },\n\n  methods: {\n    copyQueryFromProps(query) {\n      const {\n        measures = [],\n        dimensions = [],\n        segments = [],\n        timeDimensions = [],\n        filters = [],\n        limit,\n        offset,\n        renewQuery,\n        order,\n      } = query || this.initialQuery;\n\n      this.measures = measures.map((m, index) => ({\n        index,\n        ...this.meta.resolveMember(m, 'measures'),\n      }));\n      this.dimensions = dimensions.map((m, index) => ({\n        index,\n        ...this.meta.resolveMember(m, 'dimensions'),\n      }));\n      this.segments = segments.map((m, index) => ({\n        index,\n        ...this.meta.resolveMember(m, 'segments'),\n      }));\n      this.timeDimensions = timeDimensions.map((m, index) => ({\n        ...m,\n        dimension: {\n          ...this.meta.resolveMember(m.dimension, 'dimensions'),\n          granularities: this.granularities,\n        },\n        index,\n      }));\n\n      const memberTypes = ['dimensions', 'measures'];\n      this.filters = filters.map((m, index) => {\n        const memberName = m.member || m.dimension;\n        return {\n          ...m,\n          member: memberName && this.meta.resolveMember(memberName, memberTypes),\n          operators: memberName && this.meta.filterOperatorsForMember(memberName, memberTypes),\n          and: resolveMembers(this.meta, m.and),\n          or: resolveMembers(this.meta, m.or),\n          index,\n        };\n      });\n\n      this.availableMeasures = this.meta.membersForQuery({}, 'measures') || [];\n      this.availableDimensions = this.meta.membersForQuery({}, 'dimensions') || [];\n      this.availableTimeDimensions = (this.meta.membersForQuery({}, 'dimensions') || []).filter(\n        (m) => m.type === 'time'\n      );\n      this.availableSegments = this.meta.membersForQuery({}, 'segments') || [];\n      this.limit = limit || 10000;\n      this.offset = offset || null;\n      this.renewQuery = renewQuery || false;\n      this.order = order || null;\n    },\n    addMember(element, member) {\n      const name = element.charAt(0).toUpperCase() + element.slice(1);\n      let mem;\n\n      if (element === 'timeDimensions') {\n        mem = this[`available${name}`].find((m) => m.name === member.dimension);\n        if (mem) {\n          const dimension = {\n            ...this.meta.resolveMember(mem.name, 'dimensions'),\n            granularities: this.granularities,\n          };\n\n          mem = {\n            ...mem,\n            granularity: member.granularity,\n            dateRange: member.dateRange,\n            dimension,\n            index: this[element].length,\n          };\n        }\n      } else if (element === 'filters') {\n        mem = {\n          ...member,\n          and: resolveMembers(this.meta, member.and),\n          or: resolveMembers(this.meta, member.or),\n          member: getDimensionOrMeasure(this.meta, member),\n        }\n      } else {\n        mem = this[`available${name}`].find((m) => m.name === member);\n      }\n\n      if (mem) {\n        this[element].push(mem);\n      }\n    },\n    removeMember(element, member) {\n      const name = element.charAt(0).toUpperCase() + element.slice(1);\n      let mem;\n\n      if (element === 'timeDimensions') {\n        mem = this[`available${name}`].find((x) => x.name === member);\n      } else if (element === 'filters') {\n        mem = member;\n      } else {\n        mem = this[`available${name}`].find((m) => m.name === member);\n      }\n\n      if (mem) {\n        const index = this[element].findIndex((x) => x.name === mem);\n        this[element].splice(index, 1);\n      }\n    },\n    updateMember(element, old, member) {\n      const name = element.charAt(0).toUpperCase() + element.slice(1);\n      let mem;\n      let index;\n\n      if (element === 'timeDimensions') {\n        index = this[element].findIndex((x) => x.dimension.name === old.dimension);\n        mem = this[`available${name}`].find((m) => m.name === member.dimension);\n        if (mem) {\n          const dimension = {\n            ...this.meta.resolveMember(mem.name, 'dimensions'),\n            granularities: this.granularities,\n          };\n\n          mem = {\n            ...mem,\n            dimension,\n            granularity: member.granularity,\n            dateRange: member.dateRange,\n            index,\n          };\n        }\n      } else if (element === 'filters') {\n        index = this[element].findIndex((x) => x.dimension === old);\n        mem = {\n          ...member,\n          and: resolveMembers(this.meta, member.and),\n          or: resolveMembers(this.meta, member.or),\n          member: getDimensionOrMeasure(this.meta, member),\n        };\n      } else {\n        index = this[element].findIndex((x) => x.name === old);\n        mem = this[`available${name}`].find((m) => m.name === member);\n      }\n\n      if (mem) {\n        this[element].splice(index, 1, mem);\n      }\n    },\n    setMembers(element, members) {\n      const name = element.charAt(0).toUpperCase() + element.slice(1);\n      let mem;\n      const elements = [];\n\n      members.filter(Boolean).forEach((m) => {\n        if (element === 'timeDimensions') {\n          mem = this[`available${name}`].find((x) => x.name === m.dimension);\n          if (mem) {\n            const dimension = {\n              ...this.meta.resolveMember(mem.name, 'dimensions'),\n              granularities: this.granularities,\n            };\n\n            mem = {\n              ...mem,\n              granularity: m.granularity,\n              dateRange: m.dateRange,\n              dimension,\n              index: this[element].length,\n            };\n          }\n        } else if (element === 'filters') {\n          mem = {\n            ...m,\n            and: resolveMembers(this.meta, m.and),\n            or: resolveMembers(this.meta, m.or),\n            member: getDimensionOrMeasure(this.meta, m),\n          };\n        } else {\n          mem = this[`available${name}`].find((x) => x.name === m);\n        }\n\n        if (mem) {\n          elements.push(mem);\n        }\n      });\n\n      this[element] = elements;\n    },\n    setLimit(limit) {\n      this.limit = limit;\n    },\n    removeLimit() {\n      this.limit = null;\n    },\n    setOffset(offset) {\n      this.offset = offset;\n    },\n    removeOffset() {\n      this.offset = null;\n    },\n    updateChart(chartType) {\n      this.chartType = chartType;\n    },\n    setOrder(order = {}) {\n      this.order = order;\n    },\n    emitVizStateChange(partialVizState) {\n      this.$emit(\n        'vizStateChange',\n        clone({\n          ...this.vizState,\n          ...partialVizState,\n        })\n      );\n    },\n  },\n\n  watch: {\n    validatedQuery: {\n      deep: true,\n      handler(query, prevQuery) {\n        const hasQueryChanged = !areQueriesEqual(query, prevQuery);\n\n        if (hasQueryChanged) {\n          this.emitVizStateChange({\n            query,\n          });\n        }\n\n        if (isQueryPresent(query) && hasQueryChanged) {\n          this.cubejsApi\n            .dryRun(query, {\n              mutexObj: this.mutex,\n            })\n            .then(({ pivotQuery }) => {\n              const pivotConfig = ResultSet.getNormalizedPivotConfig(pivotQuery, this.pivotConfig);\n\n              if (!equals(pivotConfig, this.pivotConfig)) {\n                this.pivotConfig = pivotConfig;\n              }\n            })\n            .catch((error) => console.error(error));\n        }\n      },\n    },\n    query: {\n      deep: true,\n      handler(query) {\n        if (!this.meta) {\n          // this is ok as if meta has not been loaded by the time query prop has changed,\n          // then the promise for loading meta (found in mounted()) will call\n          // copyQueryFromProps and will therefore update anyway.\n          return;\n        }\n        this.copyQueryFromProps(query);\n      },\n    },\n    pivotConfig: {\n      deep: true,\n      handler(pivotConfig, prevPivotConfig) {\n        if (!equals(pivotConfig, prevPivotConfig)) {\n          this.emitVizStateChange({\n            pivotConfig,\n          });\n        }\n      },\n    },\n    chartType(value) {\n      this.emitVizStateChange({\n        chartType: value,\n      });\n    },\n  },\n};\n", "import { GRANULARITIES } from '@cubejs-client/core';\n\nimport QueryRenderer from './QueryRenderer';\nimport QueryBuilder from './QueryBuilder';\n\nexport { QueryRenderer, QueryBuilder, GRANULARITIES };\n\nexport default {};\n"],
  "mappings": "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",
  "names": ["props", "query", "type", "Object", "Array", "default", "queries", "loadSql", "required", "cubejsApi", "builderProps", "chartType", "String", "data", "mutexObj", "error", "undefined", "resultSet", "loading", "sqlQuery", "mounted", "isQueryPresent", "load", "loadQueries", "render", "$slots", "empty", "createElement", "slot", "controls", "onlyDefault", "builder", "measures", "slotProps", "refetch", "methods", "sql", "mutexKey", "resultPromises", "Promise", "all", "toPairs", "map", "name", "then", "r", "fromPairs", "watch", "$emit", "isLoading", "deep", "handler", "prevQuery", "areQueriesEqual", "val", "QUERY_ELEMENTS", "toOrderMember", "member", "id", "title", "reduceOrderMembers", "array", "reduce", "acc", "order", "operators", "validateFilters", "filters", "raw", "operator", "validBooleanFilter", "booleanFilters", "length", "some", "getDimensionOrMeasure", "meta", "m", "memberName", "dimension", "resolveMember", "resolveMembers", "arr", "e", "index", "and", "or", "components", "QueryRenderer", "initialChartType", "disableHeuristics", "Boolean", "stateChangeHeuristics", "Function", "initialVizState", "pivotConfig", "initialQuery", "skipHeuristics", "mutex", "dimensions", "segments", "timeDimensions", "availableMeasures", "availableDimensions", "availableTimeDimensions", "availableSegments", "limit", "offset", "renewQuery", "prevValidatedQuery", "granularities", "GRANULARITIES", "ResultSet", "getNormalizedPivotConfig", "validatedQuery", "setLimit", "removeLimit", "setOffset", "removeOffset", "orderMembers", "updateChartType", "updateChart", "setOrder", "updateOrder", "set", "memberId", "newOrder", "orderMember", "update", "reorder", "sourceIndex", "destinationIndex", "moveItemInArray", "updatePivotConfig", "moveItem", "sourceAxis", "destinationAxis", "movePivotItem", "x", "y", "forEach", "elementName", "charAt", "toUpperCase", "slice", "addMember", "updateWith", "updateMember", "removeMember", "members", "setMembers", "h", "slots", "on", "queryStatus", "event", "computed", "getOrderMembersFromOrder", "filter", "vizState", "toQuery", "hasElements", "element", "granularity", "dateRange", "values", "heuristicsFn", "defaultHeuristics", "shouldApplyHeuristicOrder", "sessionGranularity", "defaultOrder", "copyQueryFromProps", "dryRunResponse", "dryRun", "pivotQuery", "memberTypes", "filterOperatorsForMember", "membersForQuery", "mem", "find", "push", "findIndex", "splice", "old", "elements", "emitVizStateChange", "partialVizState", "clone", "hasQueryChanged", "equals", "catch", "console", "prevPivotConfig", "value"]
}
