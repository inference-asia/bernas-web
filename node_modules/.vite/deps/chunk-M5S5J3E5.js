import {
  __commonJS,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o3 = "week", c = "month", f2 = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o3, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f3 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o3:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o4 = b.p(t2), f3 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f3 + "Date", n2[d] = f3 + "Date", n2[c] = f3 + "Month", n2[h] = f3 + "FullYear", n2[u] = f3 + "Hours", n2[s] = f3 + "Minutes", n2[i] = f3 + "Seconds", n2[r] = f3 + "Milliseconds", n2)[o4], $2 = o4 === a ? this.$D + (e2 - this.$W) : e2;
          if (o4 === c || o4 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f3) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f3), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o3) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o4 = n2.weekdays, c2 = n2.months, f3 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f3 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o4, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o4, 3);
                case "dddd":
                  return o4[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f2:
              $2 = D2() / 3;
              break;
            case o3:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o3 = this.quarter() - 1;
            return s2 ? this.month(3 * o3).startOf(t).startOf("day") : this.month(3 * o3 + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// node_modules/dayjs/locale/en.js
var require_en = __commonJS({
  "node_modules/dayjs/locale/en.js"(exports, module) {
    !function(e, n) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define(n) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_locale_en = n();
    }(exports, function() {
      "use strict";
      return { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(e) {
        var n = ["th", "st", "nd", "rd"], t = e % 100;
        return "[" + e + (n[(t - 20) % 10] || n[t] || n[0]) + "]";
      } };
    });
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject3) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject3(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view3 = new Uint8Array(buf);
          var chars = new Array(view3.length);
          for (var i = 0; i < view3.length; i++) {
            chars[i] = String.fromCharCode(view3[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view3 = new Uint8Array(buf.byteLength);
            view3.set(new Uint8Array(buf));
            return view3.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init2) {
          return new Promise(function(resolve, reject3) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject3(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject3(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject3(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject3(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/url-search-params-polyfill/index.js
var require_url_search_params_polyfill = __commonJS({
  "node_modules/url-search-params-polyfill/index.js"(exports) {
    (function(self2) {
      "use strict";
      var nativeURLSearchParams = self2.URLSearchParams && self2.URLSearchParams.prototype.get ? self2.URLSearchParams : null, isSupportObjectConstructor = nativeURLSearchParams && new nativeURLSearchParams({ a: 1 }).toString() === "a=1", decodesPlusesCorrectly = nativeURLSearchParams && new nativeURLSearchParams("s=%2B").get("s") === "+", __URLSearchParams__ = "__URLSearchParams__", encodesAmpersandsCorrectly = nativeURLSearchParams ? function() {
        var ampersandTest = new nativeURLSearchParams();
        ampersandTest.append("s", " &");
        return ampersandTest.toString() === "s=+%26";
      }() : true, prototype = URLSearchParamsPolyfill.prototype, iterable = !!(self2.Symbol && self2.Symbol.iterator);
      if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
        return;
      }
      function URLSearchParamsPolyfill(search) {
        search = search || "";
        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
          search = search.toString();
        }
        this[__URLSearchParams__] = parseToDict(search);
      }
      prototype.append = function(name, value) {
        appendTo(this[__URLSearchParams__], name, value);
      };
      prototype["delete"] = function(name) {
        delete this[__URLSearchParams__][name];
      };
      prototype.get = function(name) {
        var dict = this[__URLSearchParams__];
        return name in dict ? dict[name][0] : null;
      };
      prototype.getAll = function(name) {
        var dict = this[__URLSearchParams__];
        return name in dict ? dict[name].slice(0) : [];
      };
      prototype.has = function(name) {
        return name in this[__URLSearchParams__];
      };
      prototype.set = function set3(name, value) {
        this[__URLSearchParams__][name] = ["" + value];
      };
      prototype.toString = function() {
        var dict = this[__URLSearchParams__], query = [], i, key, name, value;
        for (key in dict) {
          name = encode(key);
          for (i = 0, value = dict[key]; i < value.length; i++) {
            query.push(name + "=" + encode(value[i]));
          }
        }
        return query.join("&");
      };
      var forSureUsePolyfill = !decodesPlusesCorrectly;
      var useProxy = !forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self2.Proxy;
      Object.defineProperty(self2, "URLSearchParams", {
        value: useProxy ? (
          // Safari 10.0 doesn't support Proxy, so it won't extend URLSearchParams on safari 10.0
          new Proxy(nativeURLSearchParams, {
            construct: function(target, args) {
              return new target(new URLSearchParamsPolyfill(args[0]).toString());
            }
          })
        ) : URLSearchParamsPolyfill
      });
      var USPProto = self2.URLSearchParams.prototype;
      USPProto.polyfill = true;
      USPProto.forEach = USPProto.forEach || function(callback, thisArg) {
        var dict = parseToDict(this.toString());
        Object.getOwnPropertyNames(dict).forEach(function(name) {
          dict[name].forEach(function(value) {
            callback.call(thisArg, value, name, this);
          }, this);
        }, this);
      };
      USPProto.sort = USPProto.sort || function() {
        var dict = parseToDict(this.toString()), keys4 = [], k, i, j;
        for (k in dict) {
          keys4.push(k);
        }
        keys4.sort();
        for (i = 0; i < keys4.length; i++) {
          this["delete"](keys4[i]);
        }
        for (i = 0; i < keys4.length; i++) {
          var key = keys4[i], values3 = dict[key];
          for (j = 0; j < values3.length; j++) {
            this.append(key, values3[j]);
          }
        }
      };
      USPProto.keys = USPProto.keys || function() {
        var items = [];
        this.forEach(function(item, name) {
          items.push(name);
        });
        return makeIterator(items);
      };
      USPProto.values = USPProto.values || function() {
        var items = [];
        this.forEach(function(item) {
          items.push(item);
        });
        return makeIterator(items);
      };
      USPProto.entries = USPProto.entries || function() {
        var items = [];
        this.forEach(function(item, name) {
          items.push([name, item]);
        });
        return makeIterator(items);
      };
      if (iterable) {
        USPProto[self2.Symbol.iterator] = USPProto[self2.Symbol.iterator] || USPProto.entries;
      }
      function encode(str) {
        var replace3 = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0"
        };
        return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function(match3) {
          return replace3[match3];
        });
      }
      function decode(str) {
        return str.replace(/[ +]/g, "%20").replace(/(%[a-f0-9]{2})+/ig, function(match3) {
          return decodeURIComponent(match3);
        });
      }
      function makeIterator(arr) {
        var iterator = {
          next: function() {
            var value = arr.shift();
            return { done: value === void 0, value };
          }
        };
        if (iterable) {
          iterator[self2.Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function parseToDict(search) {
        var dict = {};
        if (typeof search === "object") {
          if (isArray(search)) {
            for (var i = 0; i < search.length; i++) {
              var item = search[i];
              if (isArray(item) && item.length === 2) {
                appendTo(dict, item[0], item[1]);
              } else {
                throw new TypeError("Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements");
              }
            }
          } else {
            for (var key in search) {
              if (search.hasOwnProperty(key)) {
                appendTo(dict, key, search[key]);
              }
            }
          }
        } else {
          if (search.indexOf("?") === 0) {
            search = search.slice(1);
          }
          var pairs = search.split("&");
          for (var j = 0; j < pairs.length; j++) {
            var value = pairs[j], index2 = value.indexOf("=");
            if (-1 < index2) {
              appendTo(dict, decode(value.slice(0, index2)), decode(value.slice(index2 + 1)));
            } else {
              if (value) {
                appendTo(dict, decode(value), "");
              }
            }
          }
        }
        return dict;
      }
      function appendTo(dict, name, value) {
        var val = typeof value === "string" ? value : value !== null && value !== void 0 && typeof value.toString === "function" ? value.toString() : JSON.stringify(value);
        if (name in dict) {
          dict[name].push(val);
        } else {
          dict[name] = [val];
        }
      }
      function isArray(val) {
        return !!val && "[object Array]" === Object.prototype.toString.call(val);
      }
    })(typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : exports);
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// node_modules/@cubejs-client/core/dist/cubejs-client-core.esm.js
var import_dayjs = __toESM(require_dayjs_min());
var import_quarterOfYear = __toESM(require_quarterOfYear());
var import_en = __toESM(require_en());

// node_modules/ramda/es/internal/_isPlaceholder.js
function _isPlaceholder(a) {
  return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
}

// node_modules/ramda/es/internal/_curry1.js
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

// node_modules/ramda/es/internal/_curry2.js
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

// node_modules/ramda/es/add.js
var add = _curry2(function add2(a, b) {
  return Number(a) + Number(b);
});
var add_default = add;

// node_modules/ramda/es/internal/_concat.js
function _concat(set1, set22) {
  set1 = set1 || [];
  set22 = set22 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set22.length;
  var result = [];
  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set22[idx];
    idx += 1;
  }
  return result;
}

// node_modules/ramda/es/internal/_arity.js
function _arity(n, fn) {
  switch (n) {
    case 0:
      return function() {
        return fn.apply(this, arguments);
      };
    case 1:
      return function(a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function(a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
}

// node_modules/ramda/es/internal/_curryN.js
function _curryN(length3, received, fn) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left = length3;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length3, combined, fn));
  };
}

// node_modules/ramda/es/curryN.js
var curryN = _curry2(function curryN2(length3, fn) {
  if (length3 === 1) {
    return _curry1(fn);
  }
  return _arity(length3, _curryN(length3, [], fn));
});
var curryN_default = curryN;

// node_modules/ramda/es/addIndex.js
var addIndex = _curry1(function addIndex2(fn) {
  return curryN_default(fn.length, function() {
    var idx = 0;
    var origFn = arguments[0];
    var list = arguments[arguments.length - 1];
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function() {
      var result = origFn.apply(this, _concat(arguments, [idx, list]));
      idx += 1;
      return result;
    };
    return fn.apply(this, args);
  });
});

// node_modules/ramda/es/internal/_curry3.js
function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function(_c) {
          return fn(a, b, _c);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function(_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function(_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}

// node_modules/ramda/es/adjust.js
var adjust = _curry3(function adjust2(idx, fn, list) {
  if (idx >= list.length || idx < -list.length) {
    return list;
  }
  var start = idx < 0 ? list.length : 0;
  var _idx = start + idx;
  var _list = _concat(list);
  _list[_idx] = fn(list[_idx]);
  return _list;
});
var adjust_default = adjust;

// node_modules/ramda/es/internal/_isArray.js
var isArray_default = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
};

// node_modules/ramda/es/internal/_isTransformer.js
function _isTransformer(obj) {
  return obj != null && typeof obj["@@transducer/step"] === "function";
}

// node_modules/ramda/es/internal/_dispatchable.js
function _dispatchable(methodNames, xf, fn) {
  return function() {
    if (arguments.length === 0) {
      return fn();
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();
    if (!isArray_default(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === "function") {
          return obj[methodNames[idx]].apply(obj, args);
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
}

// node_modules/ramda/es/internal/_reduced.js
function _reduced(x) {
  return x && x["@@transducer/reduced"] ? x : {
    "@@transducer/value": x,
    "@@transducer/reduced": true
  };
}

// node_modules/ramda/es/internal/_xfBase.js
var xfBase_default = {
  init: function() {
    return this.xf["@@transducer/init"]();
  },
  result: function(result) {
    return this.xf["@@transducer/result"](result);
  }
};

// node_modules/ramda/es/internal/_xall.js
var XAll = function() {
  function XAll2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.all = true;
  }
  XAll2.prototype["@@transducer/init"] = xfBase_default.init;
  XAll2.prototype["@@transducer/result"] = function(result) {
    if (this.all) {
      result = this.xf["@@transducer/step"](result, true);
    }
    return this.xf["@@transducer/result"](result);
  };
  XAll2.prototype["@@transducer/step"] = function(result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced(this.xf["@@transducer/step"](result, false));
    }
    return result;
  };
  return XAll2;
}();
var _xall = _curry2(function _xall2(f2, xf) {
  return new XAll(f2, xf);
});
var xall_default = _xall;

// node_modules/ramda/es/all.js
var all = _curry2(
  _dispatchable(["all"], xall_default, function all2(fn, list) {
    var idx = 0;
    while (idx < list.length) {
      if (!fn(list[idx])) {
        return false;
      }
      idx += 1;
    }
    return true;
  })
);
var all_default = all;

// node_modules/ramda/es/max.js
var max = _curry2(function max2(a, b) {
  return b > a ? b : a;
});
var max_default = max;

// node_modules/ramda/es/internal/_map.js
function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
}

// node_modules/ramda/es/internal/_isString.js
function _isString(x) {
  return Object.prototype.toString.call(x) === "[object String]";
}

// node_modules/ramda/es/internal/_isArrayLike.js
var _isArrayLike = _curry1(function isArrayLike(x) {
  if (isArray_default(x)) {
    return true;
  }
  if (!x) {
    return false;
  }
  if (typeof x !== "object") {
    return false;
  }
  if (_isString(x)) {
    return false;
  }
  if (x.nodeType === 1) {
    return !!x.length;
  }
  if (x.length === 0) {
    return true;
  }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});
var isArrayLike_default = _isArrayLike;

// node_modules/ramda/es/internal/_xwrap.js
var XWrap = function() {
  function XWrap2(fn) {
    this.f = fn;
  }
  XWrap2.prototype["@@transducer/init"] = function() {
    throw new Error("init not implemented on XWrap");
  };
  XWrap2.prototype["@@transducer/result"] = function(acc) {
    return acc;
  };
  XWrap2.prototype["@@transducer/step"] = function(acc, x) {
    return this.f(acc, x);
  };
  return XWrap2;
}();
function _xwrap(fn) {
  return new XWrap(fn);
}

// node_modules/ramda/es/bind.js
var bind = _curry2(function bind2(fn, thisObj) {
  return _arity(fn.length, function() {
    return fn.apply(thisObj, arguments);
  });
});
var bind_default = bind;

// node_modules/ramda/es/internal/_reduce.js
function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf["@@transducer/step"](acc, list[idx]);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx += 1;
  }
  return xf["@@transducer/result"](acc);
}
function _iterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf["@@transducer/step"](acc, step.value);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    step = iter.next();
  }
  return xf["@@transducer/result"](acc);
}
function _methodReduce(xf, acc, obj, methodName) {
  return xf["@@transducer/result"](obj[methodName](bind_default(xf["@@transducer/step"], xf), acc));
}
var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
function _reduce(fn, acc, list) {
  if (typeof fn === "function") {
    fn = _xwrap(fn);
  }
  if (isArrayLike_default(list)) {
    return _arrayReduce(fn, acc, list);
  }
  if (typeof list["fantasy-land/reduce"] === "function") {
    return _methodReduce(fn, acc, list, "fantasy-land/reduce");
  }
  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }
  if (typeof list.next === "function") {
    return _iterableReduce(fn, acc, list);
  }
  if (typeof list.reduce === "function") {
    return _methodReduce(fn, acc, list, "reduce");
  }
  throw new TypeError("reduce: list must be array or iterable");
}

// node_modules/ramda/es/internal/_xmap.js
var XMap = function() {
  function XMap2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XMap2.prototype["@@transducer/init"] = xfBase_default.init;
  XMap2.prototype["@@transducer/result"] = xfBase_default.result;
  XMap2.prototype["@@transducer/step"] = function(result, input) {
    return this.xf["@@transducer/step"](result, this.f(input));
  };
  return XMap2;
}();
var _xmap = _curry2(function _xmap2(f2, xf) {
  return new XMap(f2, xf);
});
var xmap_default = _xmap;

// node_modules/ramda/es/internal/_has.js
function _has(prop3, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop3);
}

// node_modules/ramda/es/internal/_isArguments.js
var toString = Object.prototype.toString;
var _isArguments = function() {
  return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
    return toString.call(x) === "[object Arguments]";
  } : function _isArguments2(x) {
    return _has("callee", x);
  };
}();
var isArguments_default = _isArguments;

// node_modules/ramda/es/keys.js
var hasEnumBug = !{
  toString: null
}.propertyIsEnumerable("toString");
var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
var hasArgsEnumBug = function() {
  "use strict";
  return arguments.propertyIsEnumerable("length");
}();
var contains = function contains2(list, item) {
  var idx = 0;
  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};
var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? _curry1(function keys2(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) : _curry1(function keys3(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop3, nIdx;
  var ks = [];
  var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
  for (prop3 in obj) {
    if (_has(prop3, obj) && (!checkArgsLength || prop3 !== "length")) {
      ks[ks.length] = prop3;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop3 = nonEnumerableProps[nIdx];
      if (_has(prop3, obj) && !contains(ks, prop3)) {
        ks[ks.length] = prop3;
      }
      nIdx -= 1;
    }
  }
  return ks;
});
var keys_default = keys;

// node_modules/ramda/es/map.js
var map = _curry2(
  _dispatchable(["fantasy-land/map", "map"], xmap_default, function map2(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case "[object Function]":
        return curryN_default(functor.length, function() {
          return fn.call(this, functor.apply(this, arguments));
        });
      case "[object Object]":
        return _reduce(function(acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys_default(functor));
      default:
        return _map(fn, functor);
    }
  })
);
var map_default = map;

// node_modules/ramda/es/internal/_isInteger.js
var isInteger_default = Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
};

// node_modules/ramda/es/nth.js
var nth = _curry2(function nth2(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString(list) ? list.charAt(idx) : list[idx];
});
var nth_default = nth;

// node_modules/ramda/es/paths.js
var paths = _curry2(function paths2(pathsArray, obj) {
  return pathsArray.map(function(paths3) {
    var val = obj;
    var idx = 0;
    var p;
    while (idx < paths3.length) {
      if (val == null) {
        return;
      }
      p = paths3[idx];
      val = isInteger_default(p) ? nth_default(p, val) : val[p];
      idx += 1;
    }
    return val;
  });
});
var paths_default = paths;

// node_modules/ramda/es/path.js
var path = _curry2(function path2(pathAr, obj) {
  return paths_default([pathAr], obj)[0];
});
var path_default = path;

// node_modules/ramda/es/prop.js
var prop = _curry2(function prop2(p, obj) {
  return path_default([p], obj);
});
var prop_default = prop;

// node_modules/ramda/es/pluck.js
var pluck = _curry2(function pluck2(p, list) {
  return map_default(prop_default(p), list);
});
var pluck_default = pluck;

// node_modules/ramda/es/reduce.js
var reduce = _curry3(_reduce);
var reduce_default = reduce;

// node_modules/ramda/es/allPass.js
var allPass = _curry1(function allPass2(preds) {
  return curryN_default(reduce_default(max_default, 0, pluck_default("length", preds)), function() {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (!preds[idx].apply(this, arguments)) {
        return false;
      }
      idx += 1;
    }
    return true;
  });
});

// node_modules/ramda/es/always.js
var always = _curry1(function always2(val) {
  return function() {
    return val;
  };
});
var always_default = always;

// node_modules/ramda/es/and.js
var and = _curry2(function and2(a, b) {
  return a && b;
});
var and_default = and;

// node_modules/ramda/es/internal/_xany.js
var XAny = function() {
  function XAny2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.any = false;
  }
  XAny2.prototype["@@transducer/init"] = xfBase_default.init;
  XAny2.prototype["@@transducer/result"] = function(result) {
    if (!this.any) {
      result = this.xf["@@transducer/step"](result, false);
    }
    return this.xf["@@transducer/result"](result);
  };
  XAny2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.any = true;
      result = _reduced(this.xf["@@transducer/step"](result, true));
    }
    return result;
  };
  return XAny2;
}();
var _xany = _curry2(function _xany2(f2, xf) {
  return new XAny(f2, xf);
});
var xany_default = _xany;

// node_modules/ramda/es/any.js
var any = _curry2(
  _dispatchable(["any"], xany_default, function any2(fn, list) {
    var idx = 0;
    while (idx < list.length) {
      if (fn(list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  })
);

// node_modules/ramda/es/anyPass.js
var anyPass = _curry1(function anyPass2(preds) {
  return curryN_default(reduce_default(max_default, 0, pluck_default("length", preds)), function() {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (preds[idx].apply(this, arguments)) {
        return true;
      }
      idx += 1;
    }
    return false;
  });
});

// node_modules/ramda/es/ap.js
var ap = _curry2(function ap2(applyF, applyX) {
  return typeof applyX["fantasy-land/ap"] === "function" ? applyX["fantasy-land/ap"](applyF) : typeof applyF.ap === "function" ? applyF.ap(applyX) : typeof applyF === "function" ? function(x) {
    return applyF(x)(applyX(x));
  } : _reduce(function(acc, f2) {
    return _concat(acc, map_default(f2, applyX));
  }, [], applyF);
});
var ap_default = ap;

// node_modules/ramda/es/internal/_aperture.js
function _aperture(n, list) {
  var idx = 0;
  var limit = list.length - (n - 1);
  var acc = new Array(limit >= 0 ? limit : 0);
  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
    idx += 1;
  }
  return acc;
}

// node_modules/ramda/es/internal/_xaperture.js
var XAperture = function() {
  function XAperture2(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XAperture2.prototype["@@transducer/init"] = xfBase_default.init;
  XAperture2.prototype["@@transducer/result"] = function(result) {
    this.acc = null;
    return this.xf["@@transducer/result"](result);
  };
  XAperture2.prototype["@@transducer/step"] = function(result, input) {
    this.store(input);
    return this.full ? this.xf["@@transducer/step"](result, this.getCopy()) : result;
  };
  XAperture2.prototype.store = function(input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  XAperture2.prototype.getCopy = function() {
    return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
  };
  return XAperture2;
}();
var _xaperture = _curry2(function _xaperture2(n, xf) {
  return new XAperture(n, xf);
});
var xaperture_default = _xaperture;

// node_modules/ramda/es/aperture.js
var aperture = _curry2(
  _dispatchable([], xaperture_default, _aperture)
);

// node_modules/ramda/es/append.js
var append = _curry2(function append2(el, list) {
  return _concat(list, [el]);
});

// node_modules/ramda/es/apply.js
var apply = _curry2(function apply2(fn, args) {
  return fn.apply(this, args);
});
var apply_default = apply;

// node_modules/ramda/es/values.js
var values = _curry1(function values2(obj) {
  var props3 = keys_default(obj);
  var len = props3.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props3[idx]];
    idx += 1;
  }
  return vals;
});
var values_default = values;

// node_modules/ramda/es/applySpec.js
function mapValues(fn, obj) {
  return keys_default(obj).reduce(function(acc, key) {
    acc[key] = fn(obj[key]);
    return acc;
  }, {});
}
var applySpec = _curry1(function applySpec2(spec) {
  spec = mapValues(function(v) {
    return typeof v == "function" ? v : applySpec2(v);
  }, spec);
  return curryN_default(reduce_default(max_default, 0, pluck_default("length", values_default(spec))), function() {
    var args = arguments;
    return mapValues(function(f2) {
      return apply_default(f2, args);
    }, spec);
  });
});

// node_modules/ramda/es/applyTo.js
var applyTo = _curry2(function applyTo2(x, f2) {
  return f2(x);
});

// node_modules/ramda/es/ascend.js
var ascend = _curry3(function ascend2(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa < bb ? -1 : aa > bb ? 1 : 0;
});

// node_modules/ramda/es/assoc.js
var assoc = _curry3(function assoc2(prop3, val, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  result[prop3] = val;
  return result;
});
var assoc_default = assoc;

// node_modules/ramda/es/isNil.js
var isNil = _curry1(function isNil2(x) {
  return x == null;
});
var isNil_default = isNil;

// node_modules/ramda/es/assocPath.js
var assocPath = _curry3(function assocPath2(path3, val, obj) {
  if (path3.length === 0) {
    return val;
  }
  var idx = path3[0];
  if (path3.length > 1) {
    var nextObj = !isNil_default(obj) && _has(idx, obj) ? obj[idx] : isInteger_default(path3[1]) ? [] : {};
    val = assocPath2(Array.prototype.slice.call(path3, 1), val, nextObj);
  }
  if (isInteger_default(idx) && isArray_default(obj)) {
    var arr = [].concat(obj);
    arr[idx] = val;
    return arr;
  } else {
    return assoc_default(idx, val, obj);
  }
});
var assocPath_default = assocPath;

// node_modules/ramda/es/nAry.js
var nAry = _curry2(function nAry2(n, fn) {
  switch (n) {
    case 0:
      return function() {
        return fn.call(this);
      };
    case 1:
      return function(a0) {
        return fn.call(this, a0);
      };
    case 2:
      return function(a0, a1) {
        return fn.call(this, a0, a1);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn.call(this, a0, a1, a2);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn.call(this, a0, a1, a2, a3);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn.call(this, a0, a1, a2, a3, a4);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn.call(this, a0, a1, a2, a3, a4, a5);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      };
    default:
      throw new Error("First argument to nAry must be a non-negative integer no greater than ten");
  }
});
var nAry_default = nAry;

// node_modules/ramda/es/binary.js
var binary = _curry1(function binary2(fn) {
  return nAry_default(2, fn);
});

// node_modules/ramda/es/internal/_isFunction.js
function _isFunction(x) {
  var type3 = Object.prototype.toString.call(x);
  return type3 === "[object Function]" || type3 === "[object AsyncFunction]" || type3 === "[object GeneratorFunction]" || type3 === "[object AsyncGeneratorFunction]";
}

// node_modules/ramda/es/liftN.js
var liftN = _curry2(function liftN2(arity, fn) {
  var lifted = curryN_default(arity, fn);
  return curryN_default(arity, function() {
    return _reduce(ap_default, map_default(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
  });
});
var liftN_default = liftN;

// node_modules/ramda/es/lift.js
var lift = _curry1(function lift2(fn) {
  return liftN_default(fn.length, fn);
});
var lift_default = lift;

// node_modules/ramda/es/both.js
var both = _curry2(function both2(f2, g) {
  return _isFunction(f2) ? function _both() {
    return f2.apply(this, arguments) && g.apply(this, arguments);
  } : lift_default(and_default)(f2, g);
});

// node_modules/ramda/es/curry.js
var curry = _curry1(function curry2(fn) {
  return curryN_default(fn.length, fn);
});
var curry_default = curry;

// node_modules/ramda/es/call.js
var call = curry_default(function call2(fn) {
  return fn.apply(this, Array.prototype.slice.call(arguments, 1));
});

// node_modules/ramda/es/internal/_makeFlat.js
function _makeFlat(recursive) {
  return function flatt(list) {
    var value, jlen, j;
    var result = [];
    var idx = 0;
    var ilen = list.length;
    while (idx < ilen) {
      if (isArrayLike_default(list[idx])) {
        value = recursive ? flatt(list[idx]) : list[idx];
        j = 0;
        jlen = value.length;
        while (j < jlen) {
          result[result.length] = value[j];
          j += 1;
        }
      } else {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  };
}

// node_modules/ramda/es/internal/_forceReduced.js
function _forceReduced(x) {
  return {
    "@@transducer/value": x,
    "@@transducer/reduced": true
  };
}

// node_modules/ramda/es/internal/_flatCat.js
var preservingReduced = function(xf) {
  return {
    "@@transducer/init": xfBase_default.init,
    "@@transducer/result": function(result) {
      return xf["@@transducer/result"](result);
    },
    "@@transducer/step": function(result, input) {
      var ret = xf["@@transducer/step"](result, input);
      return ret["@@transducer/reduced"] ? _forceReduced(ret) : ret;
    }
  };
};
var _flatCat = function _xcat(xf) {
  var rxf = preservingReduced(xf);
  return {
    "@@transducer/init": xfBase_default.init,
    "@@transducer/result": function(result) {
      return rxf["@@transducer/result"](result);
    },
    "@@transducer/step": function(result, input) {
      return !isArrayLike_default(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
    }
  };
};
var flatCat_default = _flatCat;

// node_modules/ramda/es/internal/_xchain.js
var _xchain = _curry2(function _xchain2(f2, xf) {
  return map_default(f2, flatCat_default(xf));
});
var xchain_default = _xchain;

// node_modules/ramda/es/chain.js
var chain = _curry2(
  _dispatchable(["fantasy-land/chain", "chain"], xchain_default, function chain2(fn, monad) {
    if (typeof monad === "function") {
      return function(x) {
        return fn(monad(x))(x);
      };
    }
    return _makeFlat(false)(map_default(fn, monad));
  })
);
var chain_default = chain;

// node_modules/ramda/es/clamp.js
var clamp = _curry3(function clamp2(min3, max3, value) {
  if (min3 > max3) {
    throw new Error("min must not be greater than max in clamp(min, max, value)");
  }
  return value < min3 ? min3 : value > max3 ? max3 : value;
});

// node_modules/ramda/es/internal/_cloneRegExp.js
function _cloneRegExp(pattern) {
  return new RegExp(pattern.source, (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : ""));
}

// node_modules/ramda/es/type.js
var type = _curry1(function type2(val) {
  return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
});
var type_default = type;

// node_modules/ramda/es/internal/_clone.js
function _clone(value, refFrom, refTo, deep) {
  var copy = function copy2(copiedValue) {
    var len = refFrom.length;
    var idx = 0;
    while (idx < len) {
      if (value === refFrom[idx]) {
        return refTo[idx];
      }
      idx += 1;
    }
    refFrom[idx + 1] = value;
    refTo[idx + 1] = copiedValue;
    for (var key in value) {
      copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
    }
    return copiedValue;
  };
  switch (type_default(value)) {
    case "Object":
      return copy({});
    case "Array":
      return copy([]);
    case "Date":
      return new Date(value.valueOf());
    case "RegExp":
      return _cloneRegExp(value);
    default:
      return value;
  }
}

// node_modules/ramda/es/clone.js
var clone = _curry1(function clone2(value) {
  return value != null && typeof value.clone === "function" ? value.clone() : _clone(value, [], [], true);
});
var clone_default = clone;

// node_modules/ramda/es/comparator.js
var comparator = _curry1(function comparator2(pred) {
  return function(a, b) {
    return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
  };
});

// node_modules/ramda/es/not.js
var not = _curry1(function not2(a) {
  return !a;
});
var not_default = not;

// node_modules/ramda/es/complement.js
var complement = lift_default(not_default);

// node_modules/ramda/es/internal/_pipe.js
function _pipe(f2, g) {
  return function() {
    return g.call(this, f2.apply(this, arguments));
  };
}

// node_modules/ramda/es/internal/_checkForMethod.js
function _checkForMethod(methodname, fn) {
  return function() {
    var length3 = arguments.length;
    if (length3 === 0) {
      return fn();
    }
    var obj = arguments[length3 - 1];
    return isArray_default(obj) || typeof obj[methodname] !== "function" ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length3 - 1));
  };
}

// node_modules/ramda/es/slice.js
var slice = _curry3(
  _checkForMethod("slice", function slice2(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  })
);
var slice_default = slice;

// node_modules/ramda/es/tail.js
var tail = _curry1(
  _checkForMethod(
    "tail",
    slice_default(1, Infinity)
  )
);
var tail_default = tail;

// node_modules/ramda/es/pipe.js
function pipe() {
  if (arguments.length === 0) {
    throw new Error("pipe requires at least one argument");
  }
  return _arity(arguments[0].length, reduce_default(_pipe, arguments[0], tail_default(arguments)));
}

// node_modules/ramda/es/reverse.js
var reverse = _curry1(function reverse2(list) {
  return _isString(list) ? list.split("").reverse().join("") : Array.prototype.slice.call(list, 0).reverse();
});
var reverse_default = reverse;

// node_modules/ramda/es/compose.js
function compose() {
  if (arguments.length === 0) {
    throw new Error("compose requires at least one argument");
  }
  return pipe.apply(this, reverse_default(arguments));
}

// node_modules/ramda/es/head.js
var head = nth_default(0);
var head_default = head;

// node_modules/ramda/es/internal/_identity.js
function _identity(x) {
  return x;
}

// node_modules/ramda/es/identity.js
var identity = _curry1(_identity);
var identity_default = identity;

// node_modules/ramda/es/pipeWith.js
var pipeWith = _curry2(function pipeWith2(xf, list) {
  if (list.length <= 0) {
    return identity_default;
  }
  var headList = head_default(list);
  var tailList = tail_default(list);
  return _arity(headList.length, function() {
    return _reduce(function(result, f2) {
      return xf.call(this, f2, result);
    }, headList.apply(this, arguments), tailList);
  });
});
var pipeWith_default = pipeWith;

// node_modules/ramda/es/composeWith.js
var composeWith = _curry2(function composeWith2(xf, list) {
  return pipeWith_default.apply(this, [xf, reverse_default(list)]);
});

// node_modules/ramda/es/internal/_arrayFromIterator.js
function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
}

// node_modules/ramda/es/internal/_includesWith.js
function _includesWith(pred, x, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}

// node_modules/ramda/es/internal/_functionName.js
function _functionName(f2) {
  var match3 = String(f2).match(/^function (\w*)/);
  return match3 == null ? "" : match3[1];
}

// node_modules/ramda/es/internal/_objectIs.js
function _objectIs(a, b) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  } else {
    return a !== a && b !== b;
  }
}
var objectIs_default = typeof Object.is === "function" ? Object.is : _objectIs;

// node_modules/ramda/es/internal/_equals.js
function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);
  var b = _arrayFromIterator(bIterator);
  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  }
  return !_includesWith(function(b2, aItem) {
    return !_includesWith(eq, aItem, b2);
  }, b, a);
}
function _equals(a, b, stackA, stackB) {
  if (objectIs_default(a, b)) {
    return true;
  }
  var typeA = type_default(a);
  if (typeA !== type_default(b)) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
    return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
  }
  if (typeof a.equals === "function" || typeof b.equals === "function") {
    return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
  }
  switch (typeA) {
    case "Arguments":
    case "Array":
    case "Object":
      if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
        return a === b;
      }
      break;
    case "Boolean":
    case "Number":
    case "String":
      if (!(typeof a === typeof b && objectIs_default(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case "Date":
      if (!objectIs_default(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case "Error":
      return a.name === b.name && a.message === b.message;
    case "RegExp":
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }
      break;
  }
  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }
  switch (typeA) {
    case "Map":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
    case "Set":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
    case "Arguments":
    case "Array":
    case "Object":
    case "Boolean":
    case "Number":
    case "String":
    case "Date":
    case "Error":
    case "RegExp":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "ArrayBuffer":
      break;
    default:
      return false;
  }
  var keysA = keys_default(a);
  if (keysA.length !== keys_default(b).length) {
    return false;
  }
  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}

// node_modules/ramda/es/equals.js
var equals = _curry2(function equals2(a, b) {
  return _equals(a, b, [], []);
});
var equals_default = equals;

// node_modules/ramda/es/internal/_indexOf.js
function _indexOf(list, a, idx) {
  var inf, item;
  if (typeof list.indexOf === "function") {
    switch (typeof a) {
      case "number":
        if (a === 0) {
          inf = 1 / a;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === "number" && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        return list.indexOf(a, idx);
      case "string":
      case "boolean":
      case "function":
      case "undefined":
        return list.indexOf(a, idx);
      case "object":
        if (a === null) {
          return list.indexOf(a, idx);
        }
    }
  }
  while (idx < list.length) {
    if (equals_default(list[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}

// node_modules/ramda/es/internal/_includes.js
function _includes(a, list) {
  return _indexOf(list, a, 0) >= 0;
}

// node_modules/ramda/es/internal/_quote.js
function _quote(s) {
  var escaped = s.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
  return '"' + escaped.replace(/"/g, '\\"') + '"';
}

// node_modules/ramda/es/internal/_toISOString.js
var pad = function pad2(n) {
  return (n < 10 ? "0" : "") + n;
};
var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
  return d.toISOString();
} : function _toISOString3(d) {
  return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
};
var toISOString_default = _toISOString;

// node_modules/ramda/es/internal/_complement.js
function _complement(f2) {
  return function() {
    return !f2.apply(this, arguments);
  };
}

// node_modules/ramda/es/internal/_filter.js
function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
}

// node_modules/ramda/es/internal/_isObject.js
function _isObject(x) {
  return Object.prototype.toString.call(x) === "[object Object]";
}

// node_modules/ramda/es/internal/_xfilter.js
var XFilter = function() {
  function XFilter2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XFilter2.prototype["@@transducer/init"] = xfBase_default.init;
  XFilter2.prototype["@@transducer/result"] = xfBase_default.result;
  XFilter2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
  };
  return XFilter2;
}();
var _xfilter = _curry2(function _xfilter2(f2, xf) {
  return new XFilter(f2, xf);
});
var xfilter_default = _xfilter;

// node_modules/ramda/es/filter.js
var filter = _curry2(
  _dispatchable(["filter"], xfilter_default, function(pred, filterable) {
    return _isObject(filterable) ? _reduce(function(acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }
      return acc;
    }, {}, keys_default(filterable)) : (
      // else
      _filter(pred, filterable)
    );
  })
);
var filter_default = filter;

// node_modules/ramda/es/reject.js
var reject = _curry2(function reject2(pred, filterable) {
  return filter_default(_complement(pred), filterable);
});
var reject_default = reject;

// node_modules/ramda/es/internal/_toString.js
function _toString(x, seen) {
  var recur = function recur2(y) {
    var xs = seen.concat([x]);
    return _includes(y, xs) ? "<Circular>" : _toString(y, xs);
  };
  var mapPairs = function(obj, keys4) {
    return _map(function(k) {
      return _quote(k) + ": " + recur(obj[k]);
    }, keys4.slice().sort());
  };
  switch (Object.prototype.toString.call(x)) {
    case "[object Arguments]":
      return "(function() { return arguments; }(" + _map(recur, x).join(", ") + "))";
    case "[object Array]":
      return "[" + _map(recur, x).concat(mapPairs(x, reject_default(function(k) {
        return /^\d+$/.test(k);
      }, keys_default(x)))).join(", ") + "]";
    case "[object Boolean]":
      return typeof x === "object" ? "new Boolean(" + recur(x.valueOf()) + ")" : x.toString();
    case "[object Date]":
      return "new Date(" + (isNaN(x.valueOf()) ? recur(NaN) : _quote(toISOString_default(x))) + ")";
    case "[object Null]":
      return "null";
    case "[object Number]":
      return typeof x === "object" ? "new Number(" + recur(x.valueOf()) + ")" : 1 / x === -Infinity ? "-0" : x.toString(10);
    case "[object String]":
      return typeof x === "object" ? "new String(" + recur(x.valueOf()) + ")" : _quote(x);
    case "[object Undefined]":
      return "undefined";
    default:
      if (typeof x.toString === "function") {
        var repr = x.toString();
        if (repr !== "[object Object]") {
          return repr;
        }
      }
      return "{" + mapPairs(x, keys_default(x)).join(", ") + "}";
  }
}

// node_modules/ramda/es/toString.js
var toString2 = _curry1(function toString3(val) {
  return _toString(val, []);
});
var toString_default = toString2;

// node_modules/ramda/es/concat.js
var concat = _curry2(function concat2(a, b) {
  if (isArray_default(a)) {
    if (isArray_default(b)) {
      return a.concat(b);
    }
    throw new TypeError(toString_default(b) + " is not an array");
  }
  if (_isString(a)) {
    if (_isString(b)) {
      return a + b;
    }
    throw new TypeError(toString_default(b) + " is not a string");
  }
  if (a != null && _isFunction(a["fantasy-land/concat"])) {
    return a["fantasy-land/concat"](b);
  }
  if (a != null && _isFunction(a.concat)) {
    return a.concat(b);
  }
  throw new TypeError(toString_default(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
});
var concat_default = concat;

// node_modules/ramda/es/cond.js
var cond = _curry1(function cond2(pairs) {
  var arity = reduce_default(max_default, 0, map_default(function(pair3) {
    return pair3[0].length;
  }, pairs));
  return _arity(arity, function() {
    var idx = 0;
    while (idx < pairs.length) {
      if (pairs[idx][0].apply(this, arguments)) {
        return pairs[idx][1].apply(this, arguments);
      }
      idx += 1;
    }
  });
});

// node_modules/ramda/es/constructN.js
var constructN = _curry2(function constructN2(n, Fn) {
  if (n > 10) {
    throw new Error("Constructor with greater than ten arguments");
  }
  if (n === 0) {
    return function() {
      return new Fn();
    };
  }
  return curry_default(nAry_default(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
    switch (arguments.length) {
      case 1:
        return new Fn($0);
      case 2:
        return new Fn($0, $1);
      case 3:
        return new Fn($0, $1, $2);
      case 4:
        return new Fn($0, $1, $2, $3);
      case 5:
        return new Fn($0, $1, $2, $3, $4);
      case 6:
        return new Fn($0, $1, $2, $3, $4, $5);
      case 7:
        return new Fn($0, $1, $2, $3, $4, $5, $6);
      case 8:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
      case 9:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
      case 10:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
    }
  }));
});
var constructN_default = constructN;

// node_modules/ramda/es/construct.js
var construct = _curry1(function construct2(Fn) {
  return constructN_default(Fn.length, Fn);
});

// node_modules/ramda/es/contains.js
var contains3 = _curry2(_includes);

// node_modules/ramda/es/converge.js
var converge = _curry2(function converge2(after, fns) {
  return curryN_default(reduce_default(max_default, 0, pluck_default("length", fns)), function() {
    var args = arguments;
    var context = this;
    return after.apply(context, _map(function(fn) {
      return fn.apply(context, args);
    }, fns));
  });
});
var converge_default = converge;

// node_modules/ramda/es/internal/_xreduceBy.js
var XReduceBy = function() {
  function XReduceBy2(valueFn, valueAcc, keyFn, xf) {
    this.valueFn = valueFn;
    this.valueAcc = valueAcc;
    this.keyFn = keyFn;
    this.xf = xf;
    this.inputs = {};
  }
  XReduceBy2.prototype["@@transducer/init"] = xfBase_default.init;
  XReduceBy2.prototype["@@transducer/result"] = function(result) {
    var key;
    for (key in this.inputs) {
      if (_has(key, this.inputs)) {
        result = this.xf["@@transducer/step"](result, this.inputs[key]);
        if (result["@@transducer/reduced"]) {
          result = result["@@transducer/value"];
          break;
        }
      }
    }
    this.inputs = null;
    return this.xf["@@transducer/result"](result);
  };
  XReduceBy2.prototype["@@transducer/step"] = function(result, input) {
    var key = this.keyFn(input);
    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
    return result;
  };
  return XReduceBy2;
}();
var _xreduceBy = _curryN(4, [], function _xreduceBy2(valueFn, valueAcc, keyFn, xf) {
  return new XReduceBy(valueFn, valueAcc, keyFn, xf);
});
var xreduceBy_default = _xreduceBy;

// node_modules/ramda/es/reduceBy.js
var reduceBy = _curryN(
  4,
  [],
  _dispatchable([], xreduceBy_default, function reduceBy2(valueFn, valueAcc, keyFn, list) {
    return _reduce(function(acc, elt) {
      var key = keyFn(elt);
      acc[key] = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, [], [], false), elt);
      return acc;
    }, {}, list);
  })
);
var reduceBy_default = reduceBy;

// node_modules/ramda/es/countBy.js
var countBy = reduceBy_default(function(acc, elem) {
  return acc + 1;
}, 0);

// node_modules/ramda/es/dec.js
var dec = add_default(-1);

// node_modules/ramda/es/defaultTo.js
var defaultTo = _curry2(function defaultTo2(d, v) {
  return v == null || v !== v ? d : v;
});
var defaultTo_default = defaultTo;

// node_modules/ramda/es/descend.js
var descend = _curry3(function descend2(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa > bb ? -1 : aa < bb ? 1 : 0;
});

// node_modules/ramda/es/internal/_Set.js
var _Set = function() {
  function _Set2() {
    this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
    this._items = {};
  }
  _Set2.prototype.add = function(item) {
    return !hasOrAdd(item, true, this);
  };
  _Set2.prototype.has = function(item) {
    return hasOrAdd(item, false, this);
  };
  return _Set2;
}();
function hasOrAdd(item, shouldAdd, set3) {
  var type3 = typeof item;
  var prevSize, newSize;
  switch (type3) {
    case "string":
    case "number":
      if (item === 0 && 1 / item === -Infinity) {
        if (set3._items["-0"]) {
          return true;
        } else {
          if (shouldAdd) {
            set3._items["-0"] = true;
          }
          return false;
        }
      }
      if (set3._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set3._nativeSet.size;
          set3._nativeSet.add(item);
          newSize = set3._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set3._nativeSet.has(item);
        }
      } else {
        if (!(type3 in set3._items)) {
          if (shouldAdd) {
            set3._items[type3] = {};
            set3._items[type3][item] = true;
          }
          return false;
        } else if (item in set3._items[type3]) {
          return true;
        } else {
          if (shouldAdd) {
            set3._items[type3][item] = true;
          }
          return false;
        }
      }
    case "boolean":
      if (type3 in set3._items) {
        var bIdx = item ? 1 : 0;
        if (set3._items[type3][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set3._items[type3][bIdx] = true;
          }
          return false;
        }
      } else {
        if (shouldAdd) {
          set3._items[type3] = item ? [false, true] : [true, false];
        }
        return false;
      }
    case "function":
      if (set3._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set3._nativeSet.size;
          set3._nativeSet.add(item);
          newSize = set3._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set3._nativeSet.has(item);
        }
      } else {
        if (!(type3 in set3._items)) {
          if (shouldAdd) {
            set3._items[type3] = [item];
          }
          return false;
        }
        if (!_includes(item, set3._items[type3])) {
          if (shouldAdd) {
            set3._items[type3].push(item);
          }
          return false;
        }
        return true;
      }
    case "undefined":
      if (set3._items[type3]) {
        return true;
      } else {
        if (shouldAdd) {
          set3._items[type3] = true;
        }
        return false;
      }
    case "object":
      if (item === null) {
        if (!set3._items["null"]) {
          if (shouldAdd) {
            set3._items["null"] = true;
          }
          return false;
        }
        return true;
      }
    default:
      type3 = Object.prototype.toString.call(item);
      if (!(type3 in set3._items)) {
        if (shouldAdd) {
          set3._items[type3] = [item];
        }
        return false;
      }
      if (!_includes(item, set3._items[type3])) {
        if (shouldAdd) {
          set3._items[type3].push(item);
        }
        return false;
      }
      return true;
  }
}
var Set_default = _Set;

// node_modules/ramda/es/difference.js
var difference = _curry2(function difference2(first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  var secondLen = second.length;
  var toFilterOut = new Set_default();
  for (var i = 0; i < secondLen; i += 1) {
    toFilterOut.add(second[i]);
  }
  while (idx < firstLen) {
    if (toFilterOut.add(first[idx])) {
      out[out.length] = first[idx];
    }
    idx += 1;
  }
  return out;
});
var difference_default = difference;

// node_modules/ramda/es/differenceWith.js
var differenceWith = _curry3(function differenceWith2(pred, first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!_includesWith(pred, first[idx], second) && !_includesWith(pred, first[idx], out)) {
      out.push(first[idx]);
    }
    idx += 1;
  }
  return out;
});
var differenceWith_default = differenceWith;

// node_modules/ramda/es/dissoc.js
var dissoc = _curry2(function dissoc2(prop3, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  delete result[prop3];
  return result;
});
var dissoc_default = dissoc;

// node_modules/ramda/es/remove.js
var remove = _curry3(function remove2(start, count, list) {
  var result = Array.prototype.slice.call(list, 0);
  result.splice(start, count);
  return result;
});
var remove_default = remove;

// node_modules/ramda/es/update.js
var update = _curry3(function update2(idx, x, list) {
  return adjust_default(idx, always_default(x), list);
});
var update_default = update;

// node_modules/ramda/es/dissocPath.js
var dissocPath = _curry2(function dissocPath2(path3, obj) {
  switch (path3.length) {
    case 0:
      return obj;
    case 1:
      return isInteger_default(path3[0]) && isArray_default(obj) ? remove_default(path3[0], 1, obj) : dissoc_default(path3[0], obj);
    default:
      var head2 = path3[0];
      var tail2 = Array.prototype.slice.call(path3, 1);
      if (obj[head2] == null) {
        return obj;
      } else if (isInteger_default(head2) && isArray_default(obj)) {
        return update_default(head2, dissocPath2(tail2, obj[head2]), obj);
      } else {
        return assoc_default(head2, dissocPath2(tail2, obj[head2]), obj);
      }
  }
});

// node_modules/ramda/es/divide.js
var divide = _curry2(function divide2(a, b) {
  return a / b;
});

// node_modules/ramda/es/internal/_xdrop.js
var XDrop = function() {
  function XDrop2(n, xf) {
    this.xf = xf;
    this.n = n;
  }
  XDrop2.prototype["@@transducer/init"] = xfBase_default.init;
  XDrop2.prototype["@@transducer/result"] = xfBase_default.result;
  XDrop2.prototype["@@transducer/step"] = function(result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }
    return this.xf["@@transducer/step"](result, input);
  };
  return XDrop2;
}();
var _xdrop = _curry2(function _xdrop2(n, xf) {
  return new XDrop(n, xf);
});
var xdrop_default = _xdrop;

// node_modules/ramda/es/drop.js
var drop = _curry2(
  _dispatchable(["drop"], xdrop_default, function drop2(n, xs) {
    return slice_default(Math.max(0, n), Infinity, xs);
  })
);
var drop_default = drop;

// node_modules/ramda/es/internal/_xtake.js
var XTake = function() {
  function XTake2(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }
  XTake2.prototype["@@transducer/init"] = xfBase_default.init;
  XTake2.prototype["@@transducer/result"] = xfBase_default.result;
  XTake2.prototype["@@transducer/step"] = function(result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf["@@transducer/step"](result, input);
    return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
  };
  return XTake2;
}();
var _xtake = _curry2(function _xtake2(n, xf) {
  return new XTake(n, xf);
});
var xtake_default = _xtake;

// node_modules/ramda/es/take.js
var take = _curry2(
  _dispatchable(["take"], xtake_default, function take2(n, xs) {
    return slice_default(0, n < 0 ? Infinity : n, xs);
  })
);
var take_default = take;

// node_modules/ramda/es/internal/_dropLast.js
function dropLast(n, xs) {
  return take_default(n < xs.length ? xs.length - n : 0, xs);
}

// node_modules/ramda/es/internal/_xdropLast.js
var XDropLast = function() {
  function XDropLast2(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XDropLast2.prototype["@@transducer/init"] = xfBase_default.init;
  XDropLast2.prototype["@@transducer/result"] = function(result) {
    this.acc = null;
    return this.xf["@@transducer/result"](result);
  };
  XDropLast2.prototype["@@transducer/step"] = function(result, input) {
    if (this.full) {
      result = this.xf["@@transducer/step"](result, this.acc[this.pos]);
    }
    this.store(input);
    return result;
  };
  XDropLast2.prototype.store = function(input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  return XDropLast2;
}();
var _xdropLast = _curry2(function _xdropLast2(n, xf) {
  return new XDropLast(n, xf);
});
var xdropLast_default = _xdropLast;

// node_modules/ramda/es/dropLast.js
var dropLast2 = _curry2(
  _dispatchable([], xdropLast_default, dropLast)
);
var dropLast_default = dropLast2;

// node_modules/ramda/es/internal/_dropLastWhile.js
function dropLastWhile(pred, xs) {
  var idx = xs.length - 1;
  while (idx >= 0 && pred(xs[idx])) {
    idx -= 1;
  }
  return slice_default(0, idx + 1, xs);
}

// node_modules/ramda/es/internal/_xdropLastWhile.js
var XDropLastWhile = function() {
  function XDropLastWhile2(fn, xf) {
    this.f = fn;
    this.retained = [];
    this.xf = xf;
  }
  XDropLastWhile2.prototype["@@transducer/init"] = xfBase_default.init;
  XDropLastWhile2.prototype["@@transducer/result"] = function(result) {
    this.retained = null;
    return this.xf["@@transducer/result"](result);
  };
  XDropLastWhile2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
  };
  XDropLastWhile2.prototype.flush = function(result, input) {
    result = _reduce(this.xf["@@transducer/step"], result, this.retained);
    this.retained = [];
    return this.xf["@@transducer/step"](result, input);
  };
  XDropLastWhile2.prototype.retain = function(result, input) {
    this.retained.push(input);
    return result;
  };
  return XDropLastWhile2;
}();
var _xdropLastWhile = _curry2(function _xdropLastWhile2(fn, xf) {
  return new XDropLastWhile(fn, xf);
});
var xdropLastWhile_default = _xdropLastWhile;

// node_modules/ramda/es/dropLastWhile.js
var dropLastWhile2 = _curry2(
  _dispatchable([], xdropLastWhile_default, dropLastWhile)
);

// node_modules/ramda/es/internal/_xdropRepeatsWith.js
var XDropRepeatsWith = function() {
  function XDropRepeatsWith2(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.lastValue = void 0;
    this.seenFirstValue = false;
  }
  XDropRepeatsWith2.prototype["@@transducer/init"] = xfBase_default.init;
  XDropRepeatsWith2.prototype["@@transducer/result"] = xfBase_default.result;
  XDropRepeatsWith2.prototype["@@transducer/step"] = function(result, input) {
    var sameAsLast = false;
    if (!this.seenFirstValue) {
      this.seenFirstValue = true;
    } else if (this.pred(this.lastValue, input)) {
      sameAsLast = true;
    }
    this.lastValue = input;
    return sameAsLast ? result : this.xf["@@transducer/step"](result, input);
  };
  return XDropRepeatsWith2;
}();
var _xdropRepeatsWith = _curry2(function _xdropRepeatsWith2(pred, xf) {
  return new XDropRepeatsWith(pred, xf);
});
var xdropRepeatsWith_default = _xdropRepeatsWith;

// node_modules/ramda/es/last.js
var last = nth_default(-1);
var last_default = last;

// node_modules/ramda/es/dropRepeatsWith.js
var dropRepeatsWith = _curry2(
  _dispatchable([], xdropRepeatsWith_default, function dropRepeatsWith2(pred, list) {
    var result = [];
    var idx = 1;
    var len = list.length;
    if (len !== 0) {
      result[0] = list[0];
      while (idx < len) {
        if (!pred(last_default(result), list[idx])) {
          result[result.length] = list[idx];
        }
        idx += 1;
      }
    }
    return result;
  })
);
var dropRepeatsWith_default = dropRepeatsWith;

// node_modules/ramda/es/dropRepeats.js
var dropRepeats = _curry1(
  _dispatchable(
    [],
    xdropRepeatsWith_default(equals_default),
    dropRepeatsWith_default(equals_default)
  )
);

// node_modules/ramda/es/internal/_xdropWhile.js
var XDropWhile = function() {
  function XDropWhile2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XDropWhile2.prototype["@@transducer/init"] = xfBase_default.init;
  XDropWhile2.prototype["@@transducer/result"] = xfBase_default.result;
  XDropWhile2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f) {
      if (this.f(input)) {
        return result;
      }
      this.f = null;
    }
    return this.xf["@@transducer/step"](result, input);
  };
  return XDropWhile2;
}();
var _xdropWhile = _curry2(function _xdropWhile2(f2, xf) {
  return new XDropWhile(f2, xf);
});
var xdropWhile_default = _xdropWhile;

// node_modules/ramda/es/dropWhile.js
var dropWhile = _curry2(
  _dispatchable(["dropWhile"], xdropWhile_default, function dropWhile2(pred, xs) {
    var idx = 0;
    var len = xs.length;
    while (idx < len && pred(xs[idx])) {
      idx += 1;
    }
    return slice_default(idx, Infinity, xs);
  })
);

// node_modules/ramda/es/or.js
var or = _curry2(function or2(a, b) {
  return a || b;
});
var or_default = or;

// node_modules/ramda/es/either.js
var either = _curry2(function either2(f2, g) {
  return _isFunction(f2) ? function _either() {
    return f2.apply(this, arguments) || g.apply(this, arguments);
  } : lift_default(or_default)(f2, g);
});

// node_modules/ramda/es/empty.js
var empty = _curry1(function empty2(x) {
  return x != null && typeof x["fantasy-land/empty"] === "function" ? x["fantasy-land/empty"]() : x != null && x.constructor != null && typeof x.constructor["fantasy-land/empty"] === "function" ? x.constructor["fantasy-land/empty"]() : x != null && typeof x.empty === "function" ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === "function" ? x.constructor.empty() : isArray_default(x) ? [] : _isString(x) ? "" : _isObject(x) ? {} : isArguments_default(x) ? /* @__PURE__ */ function() {
    return arguments;
  }() : void 0;
});
var empty_default = empty;

// node_modules/ramda/es/takeLast.js
var takeLast = _curry2(function takeLast2(n, xs) {
  return drop_default(n >= 0 ? xs.length - n : 0, xs);
});
var takeLast_default = takeLast;

// node_modules/ramda/es/endsWith.js
var endsWith = _curry2(function(suffix, list) {
  return equals_default(takeLast_default(suffix.length, list), suffix);
});

// node_modules/ramda/es/eqBy.js
var eqBy = _curry3(function eqBy2(f2, x, y) {
  return equals_default(f2(x), f2(y));
});

// node_modules/ramda/es/eqProps.js
var eqProps = _curry3(function eqProps2(prop3, obj1, obj2) {
  return equals_default(obj1[prop3], obj2[prop3]);
});

// node_modules/ramda/es/evolve.js
var evolve = _curry2(function evolve2(transformations, object) {
  var result = object instanceof Array ? [] : {};
  var transformation, key, type3;
  for (key in object) {
    transformation = transformations[key];
    type3 = typeof transformation;
    result[key] = type3 === "function" ? transformation(object[key]) : transformation && type3 === "object" ? evolve2(transformation, object[key]) : object[key];
  }
  return result;
});

// node_modules/ramda/es/internal/_xfind.js
var XFind = function() {
  function XFind2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.found = false;
  }
  XFind2.prototype["@@transducer/init"] = xfBase_default.init;
  XFind2.prototype["@@transducer/result"] = function(result) {
    if (!this.found) {
      result = this.xf["@@transducer/step"](result, void 0);
    }
    return this.xf["@@transducer/result"](result);
  };
  XFind2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf["@@transducer/step"](result, input));
    }
    return result;
  };
  return XFind2;
}();
var _xfind = _curry2(function _xfind2(f2, xf) {
  return new XFind(f2, xf);
});
var xfind_default = _xfind;

// node_modules/ramda/es/find.js
var find = _curry2(
  _dispatchable(["find"], xfind_default, function find2(fn, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (fn(list[idx])) {
        return list[idx];
      }
      idx += 1;
    }
  })
);

// node_modules/ramda/es/internal/_xfindIndex.js
var XFindIndex = function() {
  function XFindIndex2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.idx = -1;
    this.found = false;
  }
  XFindIndex2.prototype["@@transducer/init"] = xfBase_default.init;
  XFindIndex2.prototype["@@transducer/result"] = function(result) {
    if (!this.found) {
      result = this.xf["@@transducer/step"](result, -1);
    }
    return this.xf["@@transducer/result"](result);
  };
  XFindIndex2.prototype["@@transducer/step"] = function(result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf["@@transducer/step"](result, this.idx));
    }
    return result;
  };
  return XFindIndex2;
}();
var _xfindIndex = _curry2(function _xfindIndex2(f2, xf) {
  return new XFindIndex(f2, xf);
});
var xfindIndex_default = _xfindIndex;

// node_modules/ramda/es/findIndex.js
var findIndex = _curry2(
  _dispatchable([], xfindIndex_default, function findIndex2(fn, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (fn(list[idx])) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  })
);

// node_modules/ramda/es/internal/_xfindLast.js
var XFindLast = function() {
  function XFindLast2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XFindLast2.prototype["@@transducer/init"] = xfBase_default.init;
  XFindLast2.prototype["@@transducer/result"] = function(result) {
    return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.last));
  };
  XFindLast2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.last = input;
    }
    return result;
  };
  return XFindLast2;
}();
var _xfindLast = _curry2(function _xfindLast2(f2, xf) {
  return new XFindLast(f2, xf);
});
var xfindLast_default = _xfindLast;

// node_modules/ramda/es/findLast.js
var findLast = _curry2(
  _dispatchable([], xfindLast_default, function findLast2(fn, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      if (fn(list[idx])) {
        return list[idx];
      }
      idx -= 1;
    }
  })
);

// node_modules/ramda/es/internal/_xfindLastIndex.js
var XFindLastIndex = function() {
  function XFindLastIndex2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.idx = -1;
    this.lastIdx = -1;
  }
  XFindLastIndex2.prototype["@@transducer/init"] = xfBase_default.init;
  XFindLastIndex2.prototype["@@transducer/result"] = function(result) {
    return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.lastIdx));
  };
  XFindLastIndex2.prototype["@@transducer/step"] = function(result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.lastIdx = this.idx;
    }
    return result;
  };
  return XFindLastIndex2;
}();
var _xfindLastIndex = _curry2(function _xfindLastIndex2(f2, xf) {
  return new XFindLastIndex(f2, xf);
});
var xfindLastIndex_default = _xfindLastIndex;

// node_modules/ramda/es/findLastIndex.js
var findLastIndex = _curry2(
  _dispatchable([], xfindLastIndex_default, function findLastIndex2(fn, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      if (fn(list[idx])) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  })
);

// node_modules/ramda/es/flatten.js
var flatten = _curry1(
  _makeFlat(true)
);
var flatten_default = flatten;

// node_modules/ramda/es/flip.js
var flip = _curry1(function flip2(fn) {
  return curryN_default(fn.length, function(a, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a;
    return fn.apply(this, args);
  });
});
var flip_default = flip;

// node_modules/ramda/es/forEach.js
var forEach = _curry2(
  _checkForMethod("forEach", function forEach2(fn, list) {
    var len = list.length;
    var idx = 0;
    while (idx < len) {
      fn(list[idx]);
      idx += 1;
    }
    return list;
  })
);

// node_modules/ramda/es/forEachObjIndexed.js
var forEachObjIndexed = _curry2(function forEachObjIndexed2(fn, obj) {
  var keyList = keys_default(obj);
  var idx = 0;
  while (idx < keyList.length) {
    var key = keyList[idx];
    fn(obj[key], key, obj);
    idx += 1;
  }
  return obj;
});

// node_modules/ramda/es/fromPairs.js
var fromPairs = _curry1(function fromPairs2(pairs) {
  var result = {};
  var idx = 0;
  while (idx < pairs.length) {
    result[pairs[idx][0]] = pairs[idx][1];
    idx += 1;
  }
  return result;
});
var fromPairs_default = fromPairs;

// node_modules/ramda/es/groupBy.js
var groupBy = _curry2(
  _checkForMethod(
    "groupBy",
    reduceBy_default(function(acc, item) {
      if (acc == null) {
        acc = [];
      }
      acc.push(item);
      return acc;
    }, null)
  )
);
var groupBy_default = groupBy;

// node_modules/ramda/es/groupWith.js
var groupWith = _curry2(function(fn, list) {
  var res = [];
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    var nextidx = idx + 1;
    while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
      nextidx += 1;
    }
    res.push(list.slice(idx, nextidx));
    idx = nextidx;
  }
  return res;
});

// node_modules/ramda/es/gt.js
var gt = _curry2(function gt2(a, b) {
  return a > b;
});

// node_modules/ramda/es/gte.js
var gte = _curry2(function gte2(a, b) {
  return a >= b;
});

// node_modules/ramda/es/hasPath.js
var hasPath = _curry2(function hasPath2(_path, obj) {
  if (_path.length === 0 || isNil_default(obj)) {
    return false;
  }
  var val = obj;
  var idx = 0;
  while (idx < _path.length) {
    if (!isNil_default(val) && _has(_path[idx], val)) {
      val = val[_path[idx]];
      idx += 1;
    } else {
      return false;
    }
  }
  return true;
});
var hasPath_default = hasPath;

// node_modules/ramda/es/has.js
var has = _curry2(function has2(prop3, obj) {
  return hasPath_default([prop3], obj);
});

// node_modules/ramda/es/hasIn.js
var hasIn = _curry2(function hasIn2(prop3, obj) {
  return prop3 in obj;
});

// node_modules/ramda/es/identical.js
var identical = _curry2(objectIs_default);

// node_modules/ramda/es/ifElse.js
var ifElse = _curry3(function ifElse2(condition, onTrue, onFalse) {
  return curryN_default(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
  });
});

// node_modules/ramda/es/inc.js
var inc = add_default(1);

// node_modules/ramda/es/includes.js
var includes = _curry2(_includes);

// node_modules/ramda/es/indexBy.js
var indexBy = reduceBy_default(function(acc, elem) {
  return elem;
}, null);
var indexBy_default = indexBy;

// node_modules/ramda/es/indexOf.js
var indexOf = _curry2(function indexOf2(target, xs) {
  return typeof xs.indexOf === "function" && !isArray_default(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
});

// node_modules/ramda/es/init.js
var init = slice_default(0, -1);

// node_modules/ramda/es/innerJoin.js
var innerJoin = _curry3(function innerJoin2(pred, xs, ys) {
  return _filter(function(x) {
    return _includesWith(pred, x, ys);
  }, xs);
});

// node_modules/ramda/es/insert.js
var insert = _curry3(function insert2(idx, elt, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  var result = Array.prototype.slice.call(list, 0);
  result.splice(idx, 0, elt);
  return result;
});

// node_modules/ramda/es/insertAll.js
var insertAll = _curry3(function insertAll2(idx, elts, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
});

// node_modules/ramda/es/uniqBy.js
var uniqBy = _curry2(function uniqBy2(fn, list) {
  var set3 = new Set_default();
  var result = [];
  var idx = 0;
  var appliedItem, item;
  while (idx < list.length) {
    item = list[idx];
    appliedItem = fn(item);
    if (set3.add(appliedItem)) {
      result.push(item);
    }
    idx += 1;
  }
  return result;
});
var uniqBy_default = uniqBy;

// node_modules/ramda/es/uniq.js
var uniq = uniqBy_default(identity_default);
var uniq_default = uniq;

// node_modules/ramda/es/intersection.js
var intersection = _curry2(function intersection2(list1, list2) {
  var lookupList, filteredList;
  if (list1.length > list2.length) {
    lookupList = list1;
    filteredList = list2;
  } else {
    lookupList = list2;
    filteredList = list1;
  }
  return uniq_default(_filter(flip_default(_includes)(lookupList), filteredList));
});

// node_modules/ramda/es/intersperse.js
var intersperse = _curry2(
  _checkForMethod("intersperse", function intersperse2(separator, list) {
    var out = [];
    var idx = 0;
    var length3 = list.length;
    while (idx < length3) {
      if (idx === length3 - 1) {
        out.push(list[idx]);
      } else {
        out.push(list[idx], separator);
      }
      idx += 1;
    }
    return out;
  })
);

// node_modules/ramda/es/internal/_objectAssign.js
function _objectAssign(target) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var output = Object(target);
  var idx = 1;
  var length3 = arguments.length;
  while (idx < length3) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (_has(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
}
var objectAssign_default = typeof Object.assign === "function" ? Object.assign : _objectAssign;

// node_modules/ramda/es/objOf.js
var objOf = _curry2(function objOf2(key, val) {
  var obj = {};
  obj[key] = val;
  return obj;
});
var objOf_default = objOf;

// node_modules/ramda/es/internal/_stepCat.js
var _stepCatArray = {
  "@@transducer/init": Array,
  "@@transducer/step": function(xs, x) {
    xs.push(x);
    return xs;
  },
  "@@transducer/result": _identity
};
var _stepCatString = {
  "@@transducer/init": String,
  "@@transducer/step": function(a, b) {
    return a + b;
  },
  "@@transducer/result": _identity
};
var _stepCatObject = {
  "@@transducer/init": Object,
  "@@transducer/step": function(result, input) {
    return objectAssign_default(result, isArrayLike_default(input) ? objOf_default(input[0], input[1]) : input);
  },
  "@@transducer/result": _identity
};
function _stepCat(obj) {
  if (_isTransformer(obj)) {
    return obj;
  }
  if (isArrayLike_default(obj)) {
    return _stepCatArray;
  }
  if (typeof obj === "string") {
    return _stepCatString;
  }
  if (typeof obj === "object") {
    return _stepCatObject;
  }
  throw new Error("Cannot create transformer for " + obj);
}

// node_modules/ramda/es/into.js
var into = _curry3(function into2(acc, xf, list) {
  return _isTransformer(acc) ? _reduce(xf(acc), acc["@@transducer/init"](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
});

// node_modules/ramda/es/invert.js
var invert = _curry1(function invert2(obj) {
  var props3 = keys_default(obj);
  var len = props3.length;
  var idx = 0;
  var out = {};
  while (idx < len) {
    var key = props3[idx];
    var val = obj[key];
    var list = _has(val, out) ? out[val] : out[val] = [];
    list[list.length] = key;
    idx += 1;
  }
  return out;
});

// node_modules/ramda/es/invertObj.js
var invertObj = _curry1(function invertObj2(obj) {
  var props3 = keys_default(obj);
  var len = props3.length;
  var idx = 0;
  var out = {};
  while (idx < len) {
    var key = props3[idx];
    out[obj[key]] = key;
    idx += 1;
  }
  return out;
});

// node_modules/ramda/es/invoker.js
var invoker = _curry2(function invoker2(arity, method) {
  return curryN_default(arity + 1, function() {
    var target = arguments[arity];
    if (target != null && _isFunction(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }
    throw new TypeError(toString_default(target) + ' does not have a method named "' + method + '"');
  });
});
var invoker_default = invoker;

// node_modules/ramda/es/is.js
var is = _curry2(function is2(Ctor, val) {
  return val != null && val.constructor === Ctor || val instanceof Ctor;
});
var is_default = is;

// node_modules/ramda/es/isEmpty.js
var isEmpty = _curry1(function isEmpty2(x) {
  return x != null && equals_default(x, empty_default(x));
});

// node_modules/ramda/es/join.js
var join = invoker_default(1, "join");

// node_modules/ramda/es/juxt.js
var juxt = _curry1(function juxt2(fns) {
  return converge_default(function() {
    return Array.prototype.slice.call(arguments, 0);
  }, fns);
});
var juxt_default = juxt;

// node_modules/ramda/es/keysIn.js
var keysIn = _curry1(function keysIn2(obj) {
  var prop3;
  var ks = [];
  for (prop3 in obj) {
    ks[ks.length] = prop3;
  }
  return ks;
});

// node_modules/ramda/es/lastIndexOf.js
var lastIndexOf = _curry2(function lastIndexOf2(target, xs) {
  if (typeof xs.lastIndexOf === "function" && !isArray_default(xs)) {
    return xs.lastIndexOf(target);
  } else {
    var idx = xs.length - 1;
    while (idx >= 0) {
      if (equals_default(xs[idx], target)) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }
});

// node_modules/ramda/es/internal/_isNumber.js
function _isNumber(x) {
  return Object.prototype.toString.call(x) === "[object Number]";
}

// node_modules/ramda/es/length.js
var length = _curry1(function length2(list) {
  return list != null && _isNumber(list.length) ? list.length : NaN;
});
var length_default = length;

// node_modules/ramda/es/lens.js
var lens = _curry2(function lens2(getter, setter) {
  return function(toFunctorFn) {
    return function(target) {
      return map_default(function(focus) {
        return setter(focus, target);
      }, toFunctorFn(getter(target)));
    };
  };
});
var lens_default = lens;

// node_modules/ramda/es/lensIndex.js
var lensIndex = _curry1(function lensIndex2(n) {
  return lens_default(nth_default(n), update_default(n));
});

// node_modules/ramda/es/lensPath.js
var lensPath = _curry1(function lensPath2(p) {
  return lens_default(path_default(p), assocPath_default(p));
});

// node_modules/ramda/es/lensProp.js
var lensProp = _curry1(function lensProp2(k) {
  return lens_default(prop_default(k), assoc_default(k));
});

// node_modules/ramda/es/lt.js
var lt = _curry2(function lt2(a, b) {
  return a < b;
});

// node_modules/ramda/es/lte.js
var lte = _curry2(function lte2(a, b) {
  return a <= b;
});

// node_modules/ramda/es/mapAccum.js
var mapAccum = _curry3(function mapAccum2(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var tuple = [acc];
  while (idx < len) {
    tuple = fn(tuple[0], list[idx]);
    result[idx] = tuple[1];
    idx += 1;
  }
  return [tuple[0], result];
});

// node_modules/ramda/es/mapAccumRight.js
var mapAccumRight = _curry3(function mapAccumRight2(fn, acc, list) {
  var idx = list.length - 1;
  var result = [];
  var tuple = [acc];
  while (idx >= 0) {
    tuple = fn(tuple[0], list[idx]);
    result[idx] = tuple[1];
    idx -= 1;
  }
  return [tuple[0], result];
});

// node_modules/ramda/es/mapObjIndexed.js
var mapObjIndexed = _curry2(function mapObjIndexed2(fn, obj) {
  return _reduce(function(acc, key) {
    acc[key] = fn(obj[key], key, obj);
    return acc;
  }, {}, keys_default(obj));
});

// node_modules/ramda/es/match.js
var match = _curry2(function match2(rx, str) {
  return str.match(rx) || [];
});

// node_modules/ramda/es/mathMod.js
var mathMod = _curry2(function mathMod2(m, p) {
  if (!isInteger_default(m)) {
    return NaN;
  }
  if (!isInteger_default(p) || p < 1) {
    return NaN;
  }
  return (m % p + p) % p;
});

// node_modules/ramda/es/maxBy.js
var maxBy = _curry3(function maxBy2(f2, a, b) {
  return f2(b) > f2(a) ? b : a;
});
var maxBy_default = maxBy;

// node_modules/ramda/es/sum.js
var sum = reduce_default(add_default, 0);
var sum_default = sum;

// node_modules/ramda/es/mean.js
var mean = _curry1(function mean2(list) {
  return sum_default(list) / list.length;
});
var mean_default = mean;

// node_modules/ramda/es/median.js
var median = _curry1(function median2(list) {
  var len = list.length;
  if (len === 0) {
    return NaN;
  }
  var width = 2 - len % 2;
  var idx = (len - width) / 2;
  return mean_default(Array.prototype.slice.call(list, 0).sort(function(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }).slice(idx, idx + width));
});

// node_modules/ramda/es/memoizeWith.js
var memoizeWith = _curry2(function memoizeWith2(mFn, fn) {
  var cache = {};
  return _arity(fn.length, function() {
    var key = mFn.apply(this, arguments);
    if (!_has(key, cache)) {
      cache[key] = fn.apply(this, arguments);
    }
    return cache[key];
  });
});

// node_modules/ramda/es/merge.js
var merge = _curry2(function merge2(l, r) {
  return objectAssign_default({}, l, r);
});

// node_modules/ramda/es/mergeAll.js
var mergeAll = _curry1(function mergeAll2(list) {
  return objectAssign_default.apply(null, [{}].concat(list));
});
var mergeAll_default = mergeAll;

// node_modules/ramda/es/mergeWithKey.js
var mergeWithKey = _curry3(function mergeWithKey2(fn, l, r) {
  var result = {};
  var k;
  for (k in l) {
    if (_has(k, l)) {
      result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }
  for (k in r) {
    if (_has(k, r) && !_has(k, result)) {
      result[k] = r[k];
    }
  }
  return result;
});
var mergeWithKey_default = mergeWithKey;

// node_modules/ramda/es/mergeDeepWithKey.js
var mergeDeepWithKey = _curry3(function mergeDeepWithKey2(fn, lObj, rObj) {
  return mergeWithKey_default(function(k, lVal, rVal) {
    if (_isObject(lVal) && _isObject(rVal)) {
      return mergeDeepWithKey2(fn, lVal, rVal);
    } else {
      return fn(k, lVal, rVal);
    }
  }, lObj, rObj);
});
var mergeDeepWithKey_default = mergeDeepWithKey;

// node_modules/ramda/es/mergeDeepLeft.js
var mergeDeepLeft = _curry2(function mergeDeepLeft2(lObj, rObj) {
  return mergeDeepWithKey_default(function(k, lVal, rVal) {
    return lVal;
  }, lObj, rObj);
});
var mergeDeepLeft_default = mergeDeepLeft;

// node_modules/ramda/es/mergeDeepRight.js
var mergeDeepRight = _curry2(function mergeDeepRight2(lObj, rObj) {
  return mergeDeepWithKey_default(function(k, lVal, rVal) {
    return rVal;
  }, lObj, rObj);
});

// node_modules/ramda/es/mergeDeepWith.js
var mergeDeepWith = _curry3(function mergeDeepWith2(fn, lObj, rObj) {
  return mergeDeepWithKey_default(function(k, lVal, rVal) {
    return fn(lVal, rVal);
  }, lObj, rObj);
});

// node_modules/ramda/es/mergeLeft.js
var mergeLeft = _curry2(function mergeLeft2(l, r) {
  return objectAssign_default({}, r, l);
});

// node_modules/ramda/es/mergeRight.js
var mergeRight = _curry2(function mergeRight2(l, r) {
  return objectAssign_default({}, l, r);
});

// node_modules/ramda/es/mergeWith.js
var mergeWith = _curry3(function mergeWith2(fn, l, r) {
  return mergeWithKey_default(function(_, _l, _r) {
    return fn(_l, _r);
  }, l, r);
});

// node_modules/ramda/es/min.js
var min = _curry2(function min2(a, b) {
  return b < a ? b : a;
});

// node_modules/ramda/es/minBy.js
var minBy = _curry3(function minBy2(f2, a, b) {
  return f2(b) < f2(a) ? b : a;
});
var minBy_default = minBy;

// node_modules/ramda/es/modulo.js
var modulo = _curry2(function modulo2(a, b) {
  return a % b;
});

// node_modules/ramda/es/move.js
var move = _curry3(function(from, to, list) {
  var length3 = list.length;
  var result = list.slice();
  var positiveFrom = from < 0 ? length3 + from : from;
  var positiveTo = to < 0 ? length3 + to : to;
  var item = result.splice(positiveFrom, 1);
  return positiveFrom < 0 || positiveFrom >= list.length || positiveTo < 0 || positiveTo >= list.length ? list : [].concat(result.slice(0, positiveTo)).concat(item).concat(result.slice(positiveTo, list.length));
});

// node_modules/ramda/es/multiply.js
var multiply = _curry2(function multiply2(a, b) {
  return a * b;
});
var multiply_default = multiply;

// node_modules/ramda/es/negate.js
var negate = _curry1(function negate2(n) {
  return -n;
});

// node_modules/ramda/es/none.js
var none = _curry2(function none2(fn, input) {
  return all_default(_complement(fn), input);
});

// node_modules/ramda/es/nthArg.js
var nthArg = _curry1(function nthArg2(n) {
  var arity = n < 0 ? 1 : n + 1;
  return curryN_default(arity, function() {
    return nth_default(n, arguments);
  });
});

// node_modules/ramda/es/o.js
var o = _curry3(function o2(f2, g, x) {
  return f2(g(x));
});

// node_modules/ramda/es/internal/_of.js
function _of(x) {
  return [x];
}

// node_modules/ramda/es/of.js
var of = _curry1(_of);

// node_modules/ramda/es/omit.js
var omit = _curry2(function omit2(names, obj) {
  var result = {};
  var index2 = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    index2[names[idx]] = 1;
    idx += 1;
  }
  for (var prop3 in obj) {
    if (!index2.hasOwnProperty(prop3)) {
      result[prop3] = obj[prop3];
    }
  }
  return result;
});

// node_modules/ramda/es/once.js
var once = _curry1(function once2(fn) {
  var called = false;
  var result;
  return _arity(fn.length, function() {
    if (called) {
      return result;
    }
    called = true;
    result = fn.apply(this, arguments);
    return result;
  });
});

// node_modules/ramda/es/internal/_assertPromise.js
function _assertPromise(name, p) {
  if (p == null || !_isFunction(p.then)) {
    throw new TypeError("`" + name + "` expected a Promise, received " + _toString(p, []));
  }
}

// node_modules/ramda/es/otherwise.js
var otherwise = _curry2(function otherwise2(f2, p) {
  _assertPromise("otherwise", p);
  return p.then(null, f2);
});

// node_modules/ramda/es/over.js
var Identity = function(x) {
  return {
    value: x,
    map: function(f2) {
      return Identity(f2(x));
    }
  };
};
var over = _curry3(function over2(lens3, f2, x) {
  return lens3(function(y) {
    return Identity(f2(y));
  })(x).value;
});
var over_default = over;

// node_modules/ramda/es/pair.js
var pair = _curry2(function pair2(fst, snd) {
  return [fst, snd];
});

// node_modules/ramda/es/internal/_createPartialApplicator.js
function _createPartialApplicator(concat3) {
  return _curry2(function(fn, args) {
    return _arity(Math.max(0, fn.length - args.length), function() {
      return fn.apply(this, concat3(args, arguments));
    });
  });
}

// node_modules/ramda/es/partial.js
var partial = _createPartialApplicator(_concat);

// node_modules/ramda/es/partialRight.js
var partialRight = _createPartialApplicator(
  flip_default(_concat)
);

// node_modules/ramda/es/partition.js
var partition = juxt_default([filter_default, reject_default]);

// node_modules/ramda/es/pathEq.js
var pathEq = _curry3(function pathEq2(_path, val, obj) {
  return equals_default(path_default(_path, obj), val);
});

// node_modules/ramda/es/pathOr.js
var pathOr = _curry3(function pathOr2(d, p, obj) {
  return defaultTo_default(d, path_default(p, obj));
});
var pathOr_default = pathOr;

// node_modules/ramda/es/pathSatisfies.js
var pathSatisfies = _curry3(function pathSatisfies2(pred, propPath, obj) {
  return pred(path_default(propPath, obj));
});

// node_modules/ramda/es/pick.js
var pick = _curry2(function pick2(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});

// node_modules/ramda/es/pickAll.js
var pickAll = _curry2(function pickAll2(names, obj) {
  var result = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    var name = names[idx];
    result[name] = obj[name];
    idx += 1;
  }
  return result;
});
var pickAll_default = pickAll;

// node_modules/ramda/es/pickBy.js
var pickBy = _curry2(function pickBy2(test3, obj) {
  var result = {};
  for (var prop3 in obj) {
    if (test3(obj[prop3], prop3, obj)) {
      result[prop3] = obj[prop3];
    }
  }
  return result;
});

// node_modules/ramda/es/prepend.js
var prepend = _curry2(function prepend2(el, list) {
  return _concat([el], list);
});
var prepend_default = prepend;

// node_modules/ramda/es/product.js
var product = reduce_default(multiply_default, 1);

// node_modules/ramda/es/useWith.js
var useWith = _curry2(function useWith2(fn, transformers) {
  return curryN_default(transformers.length, function() {
    var args = [];
    var idx = 0;
    while (idx < transformers.length) {
      args.push(transformers[idx].call(this, arguments[idx]));
      idx += 1;
    }
    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
  });
});
var useWith_default = useWith;

// node_modules/ramda/es/project.js
var project = useWith_default(_map, [pickAll_default, identity_default]);

// node_modules/ramda/es/propEq.js
var propEq = _curry3(function propEq2(name, val, obj) {
  return equals_default(val, obj[name]);
});

// node_modules/ramda/es/propIs.js
var propIs = _curry3(function propIs2(type3, name, obj) {
  return is_default(type3, obj[name]);
});

// node_modules/ramda/es/propOr.js
var propOr = _curry3(function propOr2(val, p, obj) {
  return pathOr_default(val, [p], obj);
});

// node_modules/ramda/es/propSatisfies.js
var propSatisfies = _curry3(function propSatisfies2(pred, name, obj) {
  return pred(obj[name]);
});

// node_modules/ramda/es/props.js
var props = _curry2(function props2(ps, obj) {
  return ps.map(function(p) {
    return path_default([p], obj);
  });
});

// node_modules/ramda/es/range.js
var range = _curry2(function range2(from, to) {
  if (!(_isNumber(from) && _isNumber(to))) {
    throw new TypeError("Both arguments to range must be numbers");
  }
  var result = [];
  var n = from;
  while (n < to) {
    result.push(n);
    n += 1;
  }
  return result;
});

// node_modules/ramda/es/reduceRight.js
var reduceRight = _curry3(function reduceRight2(fn, acc, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    acc = fn(list[idx], acc);
    idx -= 1;
  }
  return acc;
});
var reduceRight_default = reduceRight;

// node_modules/ramda/es/reduceWhile.js
var reduceWhile = _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
  return _reduce(function(acc, x) {
    return pred(acc, x) ? fn(acc, x) : _reduced(acc);
  }, a, list);
});

// node_modules/ramda/es/reduced.js
var reduced = _curry1(_reduced);

// node_modules/ramda/es/times.js
var times = _curry2(function times2(fn, n) {
  var len = Number(n);
  var idx = 0;
  var list;
  if (len < 0 || isNaN(len)) {
    throw new RangeError("n must be a non-negative number");
  }
  list = new Array(len);
  while (idx < len) {
    list[idx] = fn(idx);
    idx += 1;
  }
  return list;
});
var times_default = times;

// node_modules/ramda/es/repeat.js
var repeat = _curry2(function repeat2(value, n) {
  return times_default(always_default(value), n);
});

// node_modules/ramda/es/replace.js
var replace = _curry3(function replace2(regex, replacement, str) {
  return str.replace(regex, replacement);
});

// node_modules/ramda/es/scan.js
var scan = _curry3(function scan2(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [acc];
  while (idx < len) {
    acc = fn(acc, list[idx]);
    result[idx + 1] = acc;
    idx += 1;
  }
  return result;
});

// node_modules/ramda/es/sequence.js
var sequence = _curry2(function sequence2(of2, traversable) {
  return typeof traversable.sequence === "function" ? traversable.sequence(of2) : reduceRight_default(function(x, acc) {
    return ap_default(map_default(prepend_default, x), acc);
  }, of2([]), traversable);
});
var sequence_default = sequence;

// node_modules/ramda/es/set.js
var set = _curry3(function set2(lens3, v, x) {
  return over_default(lens3, always_default(v), x);
});

// node_modules/ramda/es/sort.js
var sort = _curry2(function sort2(comparator3, list) {
  return Array.prototype.slice.call(list, 0).sort(comparator3);
});

// node_modules/ramda/es/sortBy.js
var sortBy = _curry2(function sortBy2(fn, list) {
  return Array.prototype.slice.call(list, 0).sort(function(a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
});

// node_modules/ramda/es/sortWith.js
var sortWith = _curry2(function sortWith2(fns, list) {
  return Array.prototype.slice.call(list, 0).sort(function(a, b) {
    var result = 0;
    var i = 0;
    while (result === 0 && i < fns.length) {
      result = fns[i](a, b);
      i += 1;
    }
    return result;
  });
});

// node_modules/ramda/es/split.js
var split = invoker_default(1, "split");

// node_modules/ramda/es/splitAt.js
var splitAt = _curry2(function splitAt2(index2, array) {
  return [slice_default(0, index2, array), slice_default(index2, length_default(array), array)];
});

// node_modules/ramda/es/splitEvery.js
var splitEvery = _curry2(function splitEvery2(n, list) {
  if (n <= 0) {
    throw new Error("First argument to splitEvery must be a positive integer");
  }
  var result = [];
  var idx = 0;
  while (idx < list.length) {
    result.push(slice_default(idx, idx += n, list));
  }
  return result;
});

// node_modules/ramda/es/splitWhen.js
var splitWhen = _curry2(function splitWhen2(pred, list) {
  var idx = 0;
  var len = list.length;
  var prefix = [];
  while (idx < len && !pred(list[idx])) {
    prefix.push(list[idx]);
    idx += 1;
  }
  return [prefix, Array.prototype.slice.call(list, idx)];
});

// node_modules/ramda/es/startsWith.js
var startsWith = _curry2(function(prefix, list) {
  return equals_default(take_default(prefix.length, list), prefix);
});

// node_modules/ramda/es/subtract.js
var subtract = _curry2(function subtract2(a, b) {
  return Number(a) - Number(b);
});

// node_modules/ramda/es/symmetricDifference.js
var symmetricDifference = _curry2(function symmetricDifference2(list1, list2) {
  return concat_default(difference_default(list1, list2), difference_default(list2, list1));
});

// node_modules/ramda/es/symmetricDifferenceWith.js
var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith2(pred, list1, list2) {
  return concat_default(differenceWith_default(pred, list1, list2), differenceWith_default(pred, list2, list1));
});

// node_modules/ramda/es/takeLastWhile.js
var takeLastWhile = _curry2(function takeLastWhile2(fn, xs) {
  var idx = xs.length - 1;
  while (idx >= 0 && fn(xs[idx])) {
    idx -= 1;
  }
  return slice_default(idx + 1, Infinity, xs);
});

// node_modules/ramda/es/internal/_xtakeWhile.js
var XTakeWhile = function() {
  function XTakeWhile2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XTakeWhile2.prototype["@@transducer/init"] = xfBase_default.init;
  XTakeWhile2.prototype["@@transducer/result"] = xfBase_default.result;
  XTakeWhile2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.xf["@@transducer/step"](result, input) : _reduced(result);
  };
  return XTakeWhile2;
}();
var _xtakeWhile = _curry2(function _xtakeWhile2(f2, xf) {
  return new XTakeWhile(f2, xf);
});
var xtakeWhile_default = _xtakeWhile;

// node_modules/ramda/es/takeWhile.js
var takeWhile = _curry2(
  _dispatchable(["takeWhile"], xtakeWhile_default, function takeWhile2(fn, xs) {
    var idx = 0;
    var len = xs.length;
    while (idx < len && fn(xs[idx])) {
      idx += 1;
    }
    return slice_default(0, idx, xs);
  })
);

// node_modules/ramda/es/internal/_xtap.js
var XTap = function() {
  function XTap2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XTap2.prototype["@@transducer/init"] = xfBase_default.init;
  XTap2.prototype["@@transducer/result"] = xfBase_default.result;
  XTap2.prototype["@@transducer/step"] = function(result, input) {
    this.f(input);
    return this.xf["@@transducer/step"](result, input);
  };
  return XTap2;
}();
var _xtap = _curry2(function _xtap2(f2, xf) {
  return new XTap(f2, xf);
});
var xtap_default = _xtap;

// node_modules/ramda/es/tap.js
var tap = _curry2(
  _dispatchable([], xtap_default, function tap2(fn, x) {
    fn(x);
    return x;
  })
);

// node_modules/ramda/es/internal/_isRegExp.js
function _isRegExp(x) {
  return Object.prototype.toString.call(x) === "[object RegExp]";
}

// node_modules/ramda/es/test.js
var test = _curry2(function test2(pattern, str) {
  if (!_isRegExp(pattern)) {
    throw new TypeError("test requires a value of type RegExp as its first argument; received " + toString_default(pattern));
  }
  return _cloneRegExp(pattern).test(str);
});

// node_modules/ramda/es/andThen.js
var andThen = _curry2(function andThen2(f2, p) {
  _assertPromise("andThen", p);
  return p.then(f2);
});

// node_modules/ramda/es/toLower.js
var toLower = invoker_default(0, "toLowerCase");

// node_modules/ramda/es/toPairs.js
var toPairs = _curry1(function toPairs2(obj) {
  var pairs = [];
  for (var prop3 in obj) {
    if (_has(prop3, obj)) {
      pairs[pairs.length] = [prop3, obj[prop3]];
    }
  }
  return pairs;
});
var toPairs_default = toPairs;

// node_modules/ramda/es/toPairsIn.js
var toPairsIn = _curry1(function toPairsIn2(obj) {
  var pairs = [];
  for (var prop3 in obj) {
    pairs[pairs.length] = [prop3, obj[prop3]];
  }
  return pairs;
});

// node_modules/ramda/es/toUpper.js
var toUpper = invoker_default(0, "toUpperCase");

// node_modules/ramda/es/transduce.js
var transduce = curryN_default(4, function transduce2(xf, fn, acc, list) {
  return _reduce(xf(typeof fn === "function" ? _xwrap(fn) : fn), acc, list);
});

// node_modules/ramda/es/transpose.js
var transpose = _curry1(function transpose2(outerlist) {
  var i = 0;
  var result = [];
  while (i < outerlist.length) {
    var innerlist = outerlist[i];
    var j = 0;
    while (j < innerlist.length) {
      if (typeof result[j] === "undefined") {
        result[j] = [];
      }
      result[j].push(innerlist[j]);
      j += 1;
    }
    i += 1;
  }
  return result;
});

// node_modules/ramda/es/traverse.js
var traverse = _curry3(function traverse2(of2, f2, traversable) {
  return typeof traversable["fantasy-land/traverse"] === "function" ? traversable["fantasy-land/traverse"](f2, of2) : sequence_default(of2, map_default(f2, traversable));
});

// node_modules/ramda/es/trim.js
var ws = "	\n\v\f\r \u2028\u2029\uFEFF";
var zeroWidth = "";
var hasProtoTrim = typeof String.prototype.trim === "function";
var trim = !hasProtoTrim || ws.trim() || !zeroWidth.trim() ? _curry1(function trim2(str) {
  var beginRx = new RegExp("^[" + ws + "][" + ws + "]*");
  var endRx = new RegExp("[" + ws + "][" + ws + "]*$");
  return str.replace(beginRx, "").replace(endRx, "");
}) : _curry1(function trim3(str) {
  return str.trim();
});

// node_modules/ramda/es/tryCatch.js
var tryCatch = _curry2(function _tryCatch(tryer, catcher) {
  return _arity(tryer.length, function() {
    try {
      return tryer.apply(this, arguments);
    } catch (e) {
      return catcher.apply(this, _concat([e], arguments));
    }
  });
});

// node_modules/ramda/es/unapply.js
var unapply = _curry1(function unapply2(fn) {
  return function() {
    return fn(Array.prototype.slice.call(arguments, 0));
  };
});

// node_modules/ramda/es/unary.js
var unary = _curry1(function unary2(fn) {
  return nAry_default(1, fn);
});

// node_modules/ramda/es/uncurryN.js
var uncurryN = _curry2(function uncurryN2(depth, fn) {
  return curryN_default(depth, function() {
    var currentDepth = 1;
    var value = fn;
    var idx = 0;
    var endIdx;
    while (currentDepth <= depth && typeof value === "function") {
      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
      currentDepth += 1;
      idx = endIdx;
    }
    return value;
  });
});

// node_modules/ramda/es/unfold.js
var unfold = _curry2(function unfold2(fn, seed) {
  var pair3 = fn(seed);
  var result = [];
  while (pair3 && pair3.length) {
    result[result.length] = pair3[0];
    pair3 = fn(pair3[1]);
  }
  return result;
});

// node_modules/ramda/es/union.js
var union = _curry2(
  compose(uniq_default, _concat)
);

// node_modules/ramda/es/uniqWith.js
var uniqWith = _curry2(function uniqWith2(pred, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var item;
  while (idx < len) {
    item = list[idx];
    if (!_includesWith(pred, item, result)) {
      result[result.length] = item;
    }
    idx += 1;
  }
  return result;
});
var uniqWith_default = uniqWith;

// node_modules/ramda/es/unionWith.js
var unionWith = _curry3(function unionWith2(pred, list1, list2) {
  return uniqWith_default(pred, _concat(list1, list2));
});

// node_modules/ramda/es/unless.js
var unless = _curry3(function unless2(pred, whenFalseFn, x) {
  return pred(x) ? x : whenFalseFn(x);
});

// node_modules/ramda/es/unnest.js
var unnest = chain_default(_identity);
var unnest_default = unnest;

// node_modules/ramda/es/until.js
var until = _curry3(function until2(pred, fn, init2) {
  var val = init2;
  while (!pred(val)) {
    val = fn(val);
  }
  return val;
});

// node_modules/ramda/es/valuesIn.js
var valuesIn = _curry1(function valuesIn2(obj) {
  var prop3;
  var vs = [];
  for (prop3 in obj) {
    vs[vs.length] = obj[prop3];
  }
  return vs;
});

// node_modules/ramda/es/view.js
var Const = function(x) {
  return {
    value: x,
    "fantasy-land/map": function() {
      return this;
    }
  };
};
var view = _curry2(function view2(lens3, x) {
  return lens3(Const)(x).value;
});

// node_modules/ramda/es/when.js
var when = _curry3(function when2(pred, whenTrueFn, x) {
  return pred(x) ? whenTrueFn(x) : x;
});

// node_modules/ramda/es/where.js
var where = _curry2(function where2(spec, testObj) {
  for (var prop3 in spec) {
    if (_has(prop3, spec) && !spec[prop3](testObj[prop3])) {
      return false;
    }
  }
  return true;
});
var where_default = where;

// node_modules/ramda/es/whereEq.js
var whereEq = _curry2(function whereEq2(spec, testObj) {
  return where_default(map_default(equals_default, spec), testObj);
});

// node_modules/ramda/es/without.js
var without = _curry2(function(xs, list) {
  return reject_default(flip_default(_includes)(xs), list);
});

// node_modules/ramda/es/xor.js
var xor = _curry2(function xor2(a, b) {
  return Boolean(!a ^ !b);
});

// node_modules/ramda/es/xprod.js
var xprod = _curry2(function xprod2(a, b) {
  var idx = 0;
  var ilen = a.length;
  var j;
  var jlen = b.length;
  var result = [];
  while (idx < ilen) {
    j = 0;
    while (j < jlen) {
      result[result.length] = [a[idx], b[j]];
      j += 1;
    }
    idx += 1;
  }
  return result;
});

// node_modules/ramda/es/zip.js
var zip = _curry2(function zip2(a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = [a[idx], b[idx]];
    idx += 1;
  }
  return rv;
});

// node_modules/ramda/es/zipObj.js
var zipObj = _curry2(function zipObj2(keys4, values3) {
  var idx = 0;
  var len = Math.min(keys4.length, values3.length);
  var out = {};
  while (idx < len) {
    out[keys4[idx]] = values3[idx];
    idx += 1;
  }
  return out;
});

// node_modules/ramda/es/zipWith.js
var zipWith = _curry3(function zipWith2(fn, a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = fn(a[idx], b[idx]);
    idx += 1;
  }
  return rv;
});

// node_modules/ramda/es/thunkify.js
var thunkify = _curry1(function thunkify2(fn) {
  return curryN_default(fn.length, function createThunk() {
    var fnArgs = arguments;
    return function invokeThunk() {
      return fn.apply(this, fnArgs);
    };
  });
});

// node_modules/@cubejs-client/core/dist/cubejs-client-core.esm.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_url_search_params_polyfill = __toESM(require_url_search_params_polyfill());
var DEFAULT_GRANULARITY = "day";
var GRANULARITIES = [{
  name: void 0,
  title: "w/o grouping"
}, {
  name: "second",
  title: "Second"
}, {
  name: "minute",
  title: "Minute"
}, {
  name: "hour",
  title: "Hour"
}, {
  name: "day",
  title: "Day"
}, {
  name: "week",
  title: "Week"
}, {
  name: "month",
  title: "Month"
}, {
  name: "quarter",
  title: "Quarter"
}, {
  name: "year",
  title: "Year"
}];
function removeEmptyQueryFields(_query) {
  const query = _query || {};
  return fromPairs_default(toPairs_default(query).map(([key, value]) => {
    if (["measures", "dimensions", "segments", "timeDimensions", "filters"].includes(key)) {
      if (Array.isArray(value) && value.length === 0) {
        return null;
      }
    }
    if (key === "order" && value) {
      if (Array.isArray(value) && !value.length) {
        return null;
      } else if (!Object.keys(value).length) {
        return null;
      }
    }
    return [key, value];
  }).filter(Boolean));
}
function validateQuery(_query) {
  const query = _query || {};
  return removeEmptyQueryFields({
    ...query,
    filters: (query.filters || []).filter((f2) => f2.operator),
    timeDimensions: (query.timeDimensions || []).filter((td) => !(!td.dateRange && !td.granularity))
  });
}
function areQueriesEqual(query1 = {}, query2 = {}) {
  return equals_default(Object.entries(query1 && query1.order || {}), Object.entries(query2 && query2.order || {})) && equals_default(query1, query2);
}
function defaultOrder(query) {
  const granularity = (query.timeDimensions || []).find((d) => d.granularity);
  if (granularity) {
    return {
      [granularity.dimension]: "asc"
    };
  } else if ((query.measures || []).length > 0 && (query.dimensions || []).length > 0) {
    return {
      [query.measures[0]]: "desc"
    };
  } else if ((query.dimensions || []).length > 0) {
    return {
      [query.dimensions[0]]: "asc"
    };
  }
  return {};
}
function defaultHeuristics(newState, oldQuery = {}, options) {
  const {
    query,
    ...props3
  } = clone_default(newState);
  const {
    meta,
    sessionGranularity
  } = options;
  const granularity = sessionGranularity || DEFAULT_GRANULARITY;
  let state = {
    query,
    ...props3
  };
  let newQuery = null;
  if (!areQueriesEqual(query, oldQuery)) {
    newQuery = query;
  }
  if (Array.isArray(newQuery) || Array.isArray(oldQuery)) {
    return newState;
  }
  if (newQuery) {
    if ((oldQuery.timeDimensions || []).length === 1 && (newQuery.timeDimensions || []).length === 1 && newQuery.timeDimensions[0].granularity && oldQuery.timeDimensions[0].granularity !== newQuery.timeDimensions[0].granularity) {
      state = {
        ...state,
        sessionGranularity: newQuery.timeDimensions[0].granularity
      };
    }
    if ((oldQuery.measures || []).length === 0 && (newQuery.measures || []).length > 0 || (oldQuery.measures || []).length === 1 && (newQuery.measures || []).length === 1 && oldQuery.measures[0] !== newQuery.measures[0]) {
      const [td] = newQuery.timeDimensions || [];
      const defaultTimeDimension = meta.defaultTimeDimensionNameFor(newQuery.measures[0]);
      newQuery = {
        ...newQuery,
        timeDimensions: defaultTimeDimension ? [{
          dimension: defaultTimeDimension,
          granularity: td && td.granularity || granularity,
          dateRange: td && td.dateRange
        }] : []
      };
      return {
        ...state,
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: newQuery,
        chartType: defaultTimeDimension ? "line" : "number"
      };
    }
    if ((oldQuery.dimensions || []).length === 0 && (newQuery.dimensions || []).length > 0) {
      newQuery = {
        ...newQuery,
        timeDimensions: (newQuery.timeDimensions || []).map((td) => ({
          ...td,
          granularity: void 0
        }))
      };
      return {
        ...state,
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: newQuery,
        chartType: "table"
      };
    }
    if ((oldQuery.dimensions || []).length > 0 && (newQuery.dimensions || []).length === 0) {
      newQuery = {
        ...newQuery,
        timeDimensions: (newQuery.timeDimensions || []).map((td) => ({
          ...td,
          granularity: td.granularity || granularity
        }))
      };
      return {
        ...state,
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: newQuery,
        chartType: (newQuery.timeDimensions || []).length ? "line" : "number"
      };
    }
    if (((oldQuery.dimensions || []).length > 0 || (oldQuery.measures || []).length > 0) && (newQuery.dimensions || []).length === 0 && (newQuery.measures || []).length === 0) {
      newQuery = {
        ...newQuery,
        timeDimensions: [],
        filters: []
      };
      return {
        ...state,
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: newQuery,
        sessionGranularity: null
      };
    }
    return state;
  }
  if (state.chartType) {
    const newChartType = state.chartType;
    if ((newChartType === "line" || newChartType === "area") && (oldQuery.timeDimensions || []).length === 1 && !oldQuery.timeDimensions[0].granularity) {
      const [td] = oldQuery.timeDimensions;
      return {
        ...state,
        pivotConfig: null,
        query: {
          ...oldQuery,
          timeDimensions: [{
            ...td,
            granularity
          }]
        }
      };
    }
    if ((newChartType === "pie" || newChartType === "table" || newChartType === "number") && (oldQuery.timeDimensions || []).length === 1 && oldQuery.timeDimensions[0].granularity) {
      const [td] = oldQuery.timeDimensions;
      return {
        ...state,
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: {
          ...oldQuery,
          timeDimensions: [{
            ...td,
            granularity: void 0
          }]
        }
      };
    }
  }
  return state;
}
function isQueryPresent(query) {
  if (!query) {
    return false;
  }
  return (Array.isArray(query) ? query : [query]).every((q) => q.measures && q.measures.length || q.dimensions && q.dimensions.length || q.timeDimensions && q.timeDimensions.length);
}
function movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis) {
  const nextPivotConfig = {
    ...pivotConfig,
    x: [...pivotConfig.x],
    y: [...pivotConfig.y]
  };
  const id = pivotConfig[sourceAxis][sourceIndex];
  const lastIndex = nextPivotConfig[destinationAxis].length - 1;
  if (id === "measures") {
    destinationIndex = lastIndex + 1;
  } else if (destinationIndex >= lastIndex && nextPivotConfig[destinationAxis][lastIndex] === "measures") {
    destinationIndex = lastIndex - 1;
  }
  nextPivotConfig[sourceAxis].splice(sourceIndex, 1);
  nextPivotConfig[destinationAxis].splice(destinationIndex, 0, id);
  return nextPivotConfig;
}
function moveItemInArray(list, sourceIndex, destinationIndex) {
  const result = [...list];
  const [removed] = result.splice(sourceIndex, 1);
  result.splice(destinationIndex, 0, removed);
  return result;
}
function flattenFilters(filters = []) {
  return filters.reduce((memo, filter2) => {
    if (filter2.or || filter2.and) {
      return [...memo, ...flattenFilters(filter2.or || filter2.and)];
    }
    return [...memo, filter2];
  }, []);
}
function getQueryMembers(query = {}) {
  const keys4 = ["measures", "dimensions", "segments"];
  const members = /* @__PURE__ */ new Set();
  keys4.forEach((key) => (query[key] || []).forEach((member) => members.add(member)));
  (query.timeDimensions || []).forEach((td) => members.add(td.dimension));
  flattenFilters(query.filters).forEach((filter2) => members.add(filter2.dimension || filter2.member));
  return [...members];
}
function getOrderMembersFromOrder(orderMembers, order) {
  const ids = /* @__PURE__ */ new Set();
  const indexedOrderMembers = indexBy_default(prop_default("id"), orderMembers);
  const entries = Array.isArray(order) ? order : Object.entries(order || {});
  const nextOrderMembers = [];
  entries.forEach(([memberId, currentOrder]) => {
    if (currentOrder !== "none" && indexedOrderMembers[memberId]) {
      ids.add(memberId);
      nextOrderMembers.push({
        ...indexedOrderMembers[memberId],
        order: currentOrder
      });
    }
  });
  orderMembers.forEach((member) => {
    if (!ids.has(member.id)) {
      nextOrderMembers.push({
        ...member,
        order: member.order || "none"
      });
    }
  });
  return nextOrderMembers;
}
function aliasSeries(values3, index2, pivotConfig, duplicateMeasures) {
  const nonNullValues = values3.filter((value) => value != null);
  if (pivotConfig && pivotConfig.aliasSeries && pivotConfig.aliasSeries[index2]) {
    return [pivotConfig.aliasSeries[index2], ...nonNullValues];
  } else if (duplicateMeasures.has(nonNullValues[0])) {
    return [index2, ...nonNullValues];
  }
  return nonNullValues;
}
import_dayjs.default.extend(import_quarterOfYear.default);
var internalDayjs = (...args) => (0, import_dayjs.default)(...args).locale({
  ...import_en.default,
  weekStart: 1
});
var TIME_SERIES = {
  day: (range3) => range3.by("d").map((d) => d.format("YYYY-MM-DDT00:00:00.000")),
  month: (range3) => range3.snapTo("month").by("M").map((d) => d.format("YYYY-MM-01T00:00:00.000")),
  year: (range3) => range3.snapTo("year").by("y").map((d) => d.format("YYYY-01-01T00:00:00.000")),
  hour: (range3) => range3.by("h").map((d) => d.format("YYYY-MM-DDTHH:00:00.000")),
  minute: (range3) => range3.by("m").map((d) => d.format("YYYY-MM-DDTHH:mm:00.000")),
  second: (range3) => range3.by("s").map((d) => d.format("YYYY-MM-DDTHH:mm:ss.000")),
  week: (range3) => range3.snapTo("week").by("w").map((d) => d.startOf("week").format("YYYY-MM-DDT00:00:00.000")),
  quarter: (range3) => range3.snapTo("quarter").by("quarter").map((d) => d.startOf("quarter").format("YYYY-MM-DDT00:00:00.000"))
};
var DateRegex = /^\d\d\d\d-\d\d-\d\d$/;
var LocalDateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z?$/;
var groupByToPairs = (keyFn) => {
  const acc = /* @__PURE__ */ new Map();
  return (data) => {
    data.forEach((row) => {
      const key = keyFn(row);
      if (!acc.has(key)) {
        acc.set(key, []);
      }
      acc.get(key).push(row);
    });
    return Array.from(acc.entries());
  };
};
var unnest2 = (arr) => {
  const res = [];
  arr.forEach((subArr) => {
    subArr.forEach((element) => res.push(element));
  });
  return res;
};
var dayRange = (from, to) => ({
  by: (value) => {
    const results = [];
    let start = internalDayjs(from);
    const end = internalDayjs(to);
    while (start.isBefore(end) || start.isSame(end)) {
      results.push(start);
      start = start.add(1, value);
    }
    return results;
  },
  snapTo: (value) => dayRange(internalDayjs(from).startOf(value), internalDayjs(to).endOf(value)),
  start: internalDayjs(from),
  end: internalDayjs(to)
});
var QUERY_TYPE = {
  REGULAR_QUERY: "regularQuery",
  COMPARE_DATE_RANGE_QUERY: "compareDateRangeQuery",
  BLENDING_QUERY: "blendingQuery"
};
var ResultSet = class _ResultSet {
  static measureFromAxis(axisValues) {
    return axisValues[axisValues.length - 1];
  }
  static timeDimensionMember(td) {
    return `${td.dimension}.${td.granularity}`;
  }
  static deserialize(data, options = {}) {
    return new _ResultSet(data.loadResponse, options);
  }
  constructor(loadResponse, options = {}) {
    this.loadResponse = loadResponse;
    if (this.loadResponse.queryType != null) {
      this.queryType = loadResponse.queryType;
      this.loadResponses = loadResponse.results;
    } else {
      this.queryType = QUERY_TYPE.REGULAR_QUERY;
      this.loadResponse.pivotQuery = {
        ...loadResponse.query,
        queryType: this.queryType
      };
      this.loadResponses = [loadResponse];
    }
    if (!Object.values(QUERY_TYPE).includes(this.queryType)) {
      throw new Error("Unknown query type");
    }
    this.parseDateMeasures = options.parseDateMeasures;
    this.options = options;
    this.backwardCompatibleData = [];
  }
  drillDown(drillDownLocator, pivotConfig) {
    if (this.queryType === QUERY_TYPE.COMPARE_DATE_RANGE_QUERY) {
      throw new Error("compareDateRange drillDown query is not currently supported");
    }
    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {
      throw new Error("Data blending drillDown query is not currently supported");
    }
    const {
      xValues = [],
      yValues = []
    } = drillDownLocator;
    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);
    const values3 = [];
    normalizedPivotConfig.x.forEach((member, currentIndex) => values3.push([member, xValues[currentIndex]]));
    normalizedPivotConfig.y.forEach((member, currentIndex) => values3.push([member, yValues[currentIndex]]));
    const {
      filters: parentFilters = [],
      segments = []
    } = this.query();
    const {
      measures
    } = this.loadResponses[0].annotation;
    let [, measureName] = values3.find(([member]) => member === "measures") || [];
    if (measureName === void 0) {
      [measureName] = Object.keys(measures);
    }
    if (!(measures[measureName] && measures[measureName].drillMembers || []).length) {
      return null;
    }
    const filters = [{
      member: measureName,
      operator: "measureFilter"
    }, ...parentFilters];
    const timeDimensions = [];
    values3.filter(([member]) => member !== "measures").forEach(([member, value]) => {
      const [cubeName, dimension, granularity] = member.split(".");
      if (granularity !== void 0) {
        const range3 = dayRange(value, value).snapTo(granularity);
        timeDimensions.push({
          dimension: [cubeName, dimension].join("."),
          dateRange: [range3.start, range3.end].map((dt) => dt.format("YYYY-MM-DDTHH:mm:ss.SSS"))
        });
      } else if (value == null) {
        filters.push({
          member,
          operator: "notSet"
        });
      } else {
        filters.push({
          member,
          operator: "equals",
          values: [value.toString()]
        });
      }
    });
    const {
      query
    } = this.loadResponses[0];
    if (timeDimensions.length === 0 && query.timeDimensions.length > 0 && query.timeDimensions[0].granularity == null) {
      timeDimensions.push(query.timeDimensions[0]);
    }
    return {
      ...measures[measureName].drillMembersGrouped,
      filters,
      ...segments.length > 0 ? {
        segments
      } : {},
      timeDimensions,
      segments,
      timezone: query.timezone
    };
  }
  series(pivotConfig) {
    return this.seriesNames(pivotConfig).map(({
      title,
      shortTitle,
      key
    }) => ({
      title,
      shortTitle,
      key,
      series: this.chartPivot(pivotConfig).map(({
        x,
        ...obj
      }) => ({
        value: obj[key],
        x
      }))
    }));
  }
  axisValues(axis, resultIndex = 0) {
    const {
      query
    } = this.loadResponses[resultIndex];
    return (row) => {
      const value = (measure) => axis.filter((d) => d !== "measures").map((d) => row[d] != null ? row[d] : null).concat(measure ? [measure] : []);
      if (axis.find((d) => d === "measures") && (query.measures || []).length) {
        return query.measures.map(value);
      }
      return [value()];
    };
  }
  axisValuesString(axisValues, delimiter) {
    const formatValue = (v) => {
      if (v == null) {
        return "";
      } else if (v === "") {
        return "[Empty string]";
      } else {
        return v;
      }
    };
    return axisValues.map(formatValue).join(delimiter || ", ");
  }
  static getNormalizedPivotConfig(query = {}, pivotConfig = null) {
    const defaultPivotConfig = {
      x: [],
      y: [],
      fillMissingDates: true,
      joinDateRange: false
    };
    const {
      measures = [],
      dimensions = []
    } = query;
    const timeDimensions = (query.timeDimensions || []).filter((td) => !!td.granularity);
    pivotConfig = pivotConfig || (timeDimensions.length ? {
      x: timeDimensions.map((td) => _ResultSet.timeDimensionMember(td)),
      y: dimensions
    } : {
      x: dimensions,
      y: []
    });
    pivotConfig = mergeDeepLeft_default(pivotConfig, defaultPivotConfig);
    const substituteTimeDimensionMembers = (axis) => axis.map((subDim) => timeDimensions.find((td) => td.dimension === subDim) && !dimensions.find((d) => d === subDim) ? _ResultSet.timeDimensionMember(query.timeDimensions.find((td) => td.dimension === subDim)) : subDim);
    pivotConfig.x = substituteTimeDimensionMembers(pivotConfig.x);
    pivotConfig.y = substituteTimeDimensionMembers(pivotConfig.y);
    const allIncludedDimensions = pivotConfig.x.concat(pivotConfig.y);
    const allDimensions = timeDimensions.map((td) => _ResultSet.timeDimensionMember(td)).concat(dimensions);
    const dimensionFilter = (key) => allDimensions.includes(key) || key === "measures";
    pivotConfig.x = pivotConfig.x.concat(allDimensions.filter((d) => !allIncludedDimensions.includes(d) && d !== "compareDateRange")).filter(dimensionFilter);
    pivotConfig.y = pivotConfig.y.filter(dimensionFilter);
    if (!pivotConfig.x.concat(pivotConfig.y).find((d) => d === "measures")) {
      pivotConfig.y.push("measures");
    }
    if (dimensions.includes("compareDateRange") && !pivotConfig.y.concat(pivotConfig.x).includes("compareDateRange")) {
      pivotConfig.y.unshift("compareDateRange");
    }
    if (!measures.length) {
      pivotConfig.x = pivotConfig.x.filter((d) => d !== "measures");
      pivotConfig.y = pivotConfig.y.filter((d) => d !== "measures");
    }
    return pivotConfig;
  }
  normalizePivotConfig(pivotConfig) {
    return _ResultSet.getNormalizedPivotConfig(this.loadResponse.pivotQuery, pivotConfig);
  }
  timeSeries(timeDimension, resultIndex) {
    if (!timeDimension.granularity) {
      return null;
    }
    let {
      dateRange
    } = timeDimension;
    if (!dateRange) {
      const member = _ResultSet.timeDimensionMember(timeDimension);
      const dates = pipe(map_default((row) => row[member] && internalDayjs(row[member])), filter_default(Boolean))(this.timeDimensionBackwardCompatibleData(resultIndex));
      dateRange = dates.length && [reduce_default(minBy_default((d) => d.toDate()), dates[0], dates), reduce_default(maxBy_default((d) => d.toDate()), dates[0], dates)] || null;
    }
    if (!dateRange) {
      return null;
    }
    const padToDay = timeDimension.dateRange ? timeDimension.dateRange.find((d) => d.match(DateRegex)) : !["hour", "minute", "second"].includes(timeDimension.granularity);
    const [start, end] = dateRange;
    const range3 = dayRange(start, end);
    if (!TIME_SERIES[timeDimension.granularity]) {
      throw new Error(`Unsupported time granularity: ${timeDimension.granularity}`);
    }
    return TIME_SERIES[timeDimension.granularity](padToDay ? range3.snapTo("d") : range3);
  }
  pivot(pivotConfig) {
    pivotConfig = this.normalizePivotConfig(pivotConfig);
    const {
      pivotQuery: query
    } = this.loadResponse;
    const pivotImpl = (resultIndex = 0) => {
      let groupByXAxis = groupByToPairs(({
        xValues
      }) => this.axisValuesString(xValues));
      const measureValue = (row, measure) => row[measure] || 0;
      if (pivotConfig.fillMissingDates && pivotConfig.x.length === 1 && equals_default(pivotConfig.x, (query.timeDimensions || []).filter((td) => Boolean(td.granularity)).map((td) => _ResultSet.timeDimensionMember(td)))) {
        const series = this.loadResponses.map((loadResponse) => this.timeSeries(loadResponse.query.timeDimensions[0], resultIndex));
        if (series[0]) {
          groupByXAxis = (rows) => {
            const byXValues = groupBy_default(({
              xValues
            }) => xValues[0], rows);
            return series[resultIndex].map((d) => [d, byXValues[d] || [{
              xValues: [d],
              row: {}
            }]]);
          };
        }
      }
      const xGrouped = pipe(map_default((row) => this.axisValues(pivotConfig.x, resultIndex)(row).map((xValues) => ({
        xValues,
        row
      }))), unnest2, groupByXAxis)(this.timeDimensionBackwardCompatibleData(resultIndex));
      const yValuesMap = {};
      xGrouped.forEach(([, rows]) => {
        rows.forEach(({
          row
        }) => {
          this.axisValues(pivotConfig.y, resultIndex)(row).forEach((values3) => {
            if (Object.keys(row).length > 0) {
              yValuesMap[values3.join()] = values3;
            }
          });
        });
      });
      const allYValues = Object.values(yValuesMap);
      const measureOnX = Boolean(pivotConfig.x.find((d) => d === "measures"));
      return xGrouped.map(([, rows]) => {
        const {
          xValues
        } = rows[0];
        const yGrouped = {};
        rows.forEach(({
          row
        }) => {
          const arr = this.axisValues(pivotConfig.y, resultIndex)(row).map((yValues) => ({
            yValues,
            row
          }));
          arr.forEach((res) => {
            yGrouped[this.axisValuesString(res.yValues)] = res;
          });
        });
        return {
          xValues,
          yValuesArray: unnest2(allYValues.map((yValues) => {
            const measure = measureOnX ? _ResultSet.measureFromAxis(xValues) : _ResultSet.measureFromAxis(yValues);
            return [[yValues, measureValue((yGrouped[this.axisValuesString(yValues)] || {
              row: {}
            }).row, measure)]];
          }))
        };
      });
    };
    const pivots = this.loadResponses.length > 1 ? this.loadResponses.map((_, index2) => pivotImpl(index2)) : [];
    return pivots.length ? this.mergePivots(pivots, pivotConfig.joinDateRange) : pivotImpl();
  }
  mergePivots(pivots, joinDateRange) {
    const minLengthPivot = pivots.reduce((memo, current) => memo != null && current.length >= memo.length ? memo : current, null);
    return minLengthPivot.map((_, index2) => {
      const xValues = joinDateRange ? [pivots.map((pivot) => pivot[index2] && pivot[index2].xValues || []).join(", ")] : minLengthPivot[index2].xValues;
      return {
        xValues,
        yValuesArray: unnest2(pivots.map((pivot) => pivot[index2].yValuesArray))
      };
    });
  }
  pivotedRows(pivotConfig) {
    return this.chartPivot(pivotConfig);
  }
  chartPivot(pivotConfig) {
    const validate2 = (value) => {
      if (this.parseDateMeasures && LocalDateRegex.test(value)) {
        return new Date(value);
      } else if (!Number.isNaN(Number.parseFloat(value))) {
        return Number.parseFloat(value);
      }
      return value;
    };
    const duplicateMeasures = /* @__PURE__ */ new Set();
    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {
      const allMeasures = flatten_default(this.loadResponses.map(({
        query
      }) => query.measures));
      allMeasures.filter((e, i, a) => a.indexOf(e) !== i).forEach((m) => duplicateMeasures.add(m));
    }
    return this.pivot(pivotConfig).map(({
      xValues,
      yValuesArray
    }) => {
      const yValuesMap = {};
      yValuesArray.forEach(([yValues, m], i) => {
        yValuesMap[this.axisValuesString(aliasSeries(yValues, i, pivotConfig, duplicateMeasures), ",")] = m && validate2(m);
      });
      return {
        x: this.axisValuesString(xValues, ","),
        xValues,
        ...yValuesMap
      };
    });
  }
  tablePivot(pivotConfig) {
    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});
    const isMeasuresPresent = normalizedPivotConfig.x.concat(normalizedPivotConfig.y).includes("measures");
    return this.pivot(normalizedPivotConfig).map(({
      xValues,
      yValuesArray
    }) => fromPairs_default(normalizedPivotConfig.x.map((key, index2) => [key, xValues[index2]]).concat(isMeasuresPresent ? yValuesArray.map(([yValues, measure]) => [yValues.length ? yValues.join() : "value", measure]) : [])));
  }
  tableColumns(pivotConfig) {
    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});
    const annotations = pipe(pluck_default("annotation"), reduce_default(mergeDeepLeft_default(), {}))(this.loadResponses);
    const flatMeta = Object.values(annotations).reduce((a, b) => ({
      ...a,
      ...b
    }), {});
    const schema = {};
    const extractFields = (key) => {
      const {
        title,
        shortTitle,
        type: type3,
        format,
        meta
      } = flatMeta[key] || {};
      return {
        key,
        title,
        shortTitle,
        type: type3,
        format,
        meta
      };
    };
    const pivot = this.pivot(normalizedPivotConfig);
    (pivot[0] && pivot[0].yValuesArray || []).forEach(([yValues]) => {
      if (yValues.length > 0) {
        let currentItem = schema;
        yValues.forEach((value, index2) => {
          currentItem[`_${value}`] = {
            key: value,
            memberId: normalizedPivotConfig.y[index2] === "measures" ? value : normalizedPivotConfig.y[index2],
            children: currentItem[`_${value}`] && currentItem[`_${value}`].children || {}
          };
          currentItem = currentItem[`_${value}`].children;
        });
      }
    });
    const toColumns = (item = {}, path3 = []) => {
      if (Object.keys(item).length === 0) {
        return [];
      }
      return Object.values(item).map(({
        key,
        ...currentItem
      }) => {
        const children = toColumns(currentItem.children, [...path3, key]);
        const {
          title,
          shortTitle,
          ...fields
        } = extractFields(currentItem.memberId);
        const dimensionValue = key !== currentItem.memberId || title == null ? key : "";
        if (!children.length) {
          return {
            ...fields,
            key,
            dataIndex: [...path3, key].join(),
            title: [title, dimensionValue].join(" ").trim(),
            shortTitle: dimensionValue || shortTitle
          };
        }
        return {
          ...fields,
          key,
          title: [title, dimensionValue].join(" ").trim(),
          shortTitle: dimensionValue || shortTitle,
          children
        };
      });
    };
    let otherColumns = [];
    if (!pivot.length && normalizedPivotConfig.y.includes("measures")) {
      otherColumns = (this.loadResponses[0].query.measures || []).map((key) => ({
        ...extractFields(key),
        dataIndex: key
      }));
    }
    if (!normalizedPivotConfig.y.length && normalizedPivotConfig.x.includes("measures")) {
      otherColumns.push({
        key: "value",
        dataIndex: "value",
        title: "Value",
        shortTitle: "Value",
        type: "string"
      });
    }
    return normalizedPivotConfig.x.map((key) => {
      if (key === "measures") {
        return {
          key: "measures",
          dataIndex: "measures",
          title: "Measures",
          shortTitle: "Measures",
          type: "string"
        };
      }
      return {
        ...extractFields(key),
        dataIndex: key
      };
    }).concat(toColumns(schema)).concat(otherColumns);
  }
  totalRow(pivotConfig) {
    return this.chartPivot(pivotConfig)[0];
  }
  categories(pivotConfig) {
    return this.chartPivot(pivotConfig);
  }
  seriesNames(pivotConfig) {
    pivotConfig = this.normalizePivotConfig(pivotConfig);
    const measures = pipe(pluck_default("annotation"), pluck_default("measures"), mergeAll_default)(this.loadResponses);
    const seriesNames = unnest2(this.loadResponses.map((_, index2) => pipe(map_default(this.axisValues(pivotConfig.y, index2)), unnest2, uniq_default)(this.timeDimensionBackwardCompatibleData(index2))));
    const duplicateMeasures = /* @__PURE__ */ new Set();
    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {
      const allMeasures = flatten_default(this.loadResponses.map(({
        query
      }) => query.measures));
      allMeasures.filter((e, i, a) => a.indexOf(e) !== i).forEach((m) => duplicateMeasures.add(m));
    }
    return seriesNames.map((axisValues, i) => {
      const aliasedAxis = aliasSeries(axisValues, i, pivotConfig, duplicateMeasures);
      return {
        title: this.axisValuesString(pivotConfig.y.find((d) => d === "measures") ? dropLast_default(1, aliasedAxis).concat(measures[_ResultSet.measureFromAxis(axisValues)].title) : aliasedAxis, ", "),
        shortTitle: this.axisValuesString(pivotConfig.y.find((d) => d === "measures") ? dropLast_default(1, aliasedAxis).concat(measures[_ResultSet.measureFromAxis(axisValues)].shortTitle) : aliasedAxis, ", "),
        key: this.axisValuesString(aliasedAxis, ","),
        yValues: axisValues
      };
    });
  }
  query() {
    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {
      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);
    }
    return this.loadResponses[0].query;
  }
  pivotQuery() {
    return this.loadResponse.pivotQuery || null;
  }
  rawData() {
    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {
      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);
    }
    return this.loadResponses[0].data;
  }
  annotation() {
    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {
      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);
    }
    return this.loadResponses[0].annotation;
  }
  timeDimensionBackwardCompatibleData(resultIndex) {
    if (resultIndex === void 0) {
      throw new Error("resultIndex is required");
    }
    if (!this.backwardCompatibleData[resultIndex]) {
      const {
        data,
        query
      } = this.loadResponses[resultIndex];
      const timeDimensions = (query.timeDimensions || []).filter((td) => Boolean(td.granularity));
      this.backwardCompatibleData[resultIndex] = data.map((row) => ({
        ...row,
        ...fromPairs_default(Object.keys(row).filter((field) => timeDimensions.find((d) => d.dimension === field) && !row[_ResultSet.timeDimensionMember(timeDimensions.find((d) => d.dimension === field))]).map((field) => [_ResultSet.timeDimensionMember(timeDimensions.find((d) => d.dimension === field)), row[field]]))
      }));
    }
    return this.backwardCompatibleData[resultIndex];
  }
  decompose() {
    return this.loadResponses.map((result) => new _ResultSet({
      queryType: QUERY_TYPE.REGULAR_QUERY,
      pivotQuery: {
        ...result.query,
        queryType: QUERY_TYPE.REGULAR_QUERY
      },
      results: [result]
    }, this.options));
  }
  serialize() {
    return {
      loadResponse: clone_default(this.loadResponse)
    };
  }
};
var SqlQuery = class {
  constructor(sqlQuery) {
    this.sqlQuery = sqlQuery;
  }
  rawQuery() {
    return this.sqlQuery.sql;
  }
  sql() {
    return this.rawQuery().sql[0];
  }
};
var memberMap = (memberArray) => fromPairs_default(memberArray.map((m) => [m.name, m]));
var operators = {
  string: [{
    name: "contains",
    title: "contains"
  }, {
    name: "notContains",
    title: "does not contain"
  }, {
    name: "equals",
    title: "equals"
  }, {
    name: "notEquals",
    title: "does not equal"
  }, {
    name: "set",
    title: "is set"
  }, {
    name: "notSet",
    title: "is not set"
  }, {
    name: "startsWith",
    title: "starts with"
  }, {
    name: "notStartsWith",
    title: "does not start with"
  }, {
    name: "endsWith",
    title: "ends with"
  }, {
    name: "notEndsWith",
    title: "does not end with"
  }],
  number: [{
    name: "equals",
    title: "equals"
  }, {
    name: "notEquals",
    title: "does not equal"
  }, {
    name: "set",
    title: "is set"
  }, {
    name: "notSet",
    title: "is not set"
  }, {
    name: "gt",
    title: ">"
  }, {
    name: "gte",
    title: ">="
  }, {
    name: "lt",
    title: "<"
  }, {
    name: "lte",
    title: "<="
  }],
  time: [{
    name: "equals",
    title: "equals"
  }, {
    name: "notEquals",
    title: "does not equal"
  }, {
    name: "inDateRange",
    title: "in date range"
  }, {
    name: "notInDateRange",
    title: "not in date range"
  }, {
    name: "afterDate",
    title: "after date"
  }, {
    name: "beforeDate",
    title: "before date"
  }]
};
var Meta = class {
  constructor(metaResponse) {
    this.meta = metaResponse;
    const {
      cubes
    } = this.meta;
    this.cubes = cubes;
    this.cubesMap = fromPairs_default(cubes.map((c) => [c.name, {
      measures: memberMap(c.measures),
      dimensions: memberMap(c.dimensions),
      segments: memberMap(c.segments)
    }]));
  }
  membersForQuery(query, memberType) {
    return unnest_default(this.cubes.map((c) => c[memberType])).sort((a, b) => a.title > b.title ? 1 : -1);
  }
  membersGroupedByCube() {
    const memberKeys = ["measures", "dimensions", "segments", "timeDimensions"];
    return this.cubes.reduce((memo, cube) => {
      memberKeys.forEach((key) => {
        let members = cube[key];
        if (key === "timeDimensions") {
          members = cube.dimensions.filter((m) => m.type === "time");
        }
        memo[key] = [...memo[key], {
          cubeName: cube.name,
          cubeTitle: cube.title,
          type: cube.type,
          public: cube.public,
          members
        }];
      });
      return memo;
    }, {
      measures: [],
      dimensions: [],
      segments: [],
      timeDimensions: []
    });
  }
  resolveMember(memberName, memberType) {
    const [cube] = memberName.split(".");
    if (!this.cubesMap[cube]) {
      return {
        title: memberName,
        error: `Cube not found ${cube} for path '${memberName}'`
      };
    }
    const memberTypes = Array.isArray(memberType) ? memberType : [memberType];
    const member = memberTypes.map((type3) => this.cubesMap[cube][type3] && this.cubesMap[cube][type3][memberName]).find((m) => m);
    if (!member) {
      return {
        title: memberName,
        error: `Path not found '${memberName}'`
      };
    }
    return member;
  }
  defaultTimeDimensionNameFor(memberName) {
    const [cube] = memberName.split(".");
    if (!this.cubesMap[cube]) {
      return null;
    }
    return Object.keys(this.cubesMap[cube].dimensions || {}).find((d) => this.cubesMap[cube].dimensions[d].type === "time");
  }
  filterOperatorsForMember(memberName, memberType) {
    const member = this.resolveMember(memberName, memberType);
    return operators[member.type] || operators.string;
  }
};
var ProgressResult = class {
  constructor(progressResponse) {
    this.progressResponse = progressResponse;
  }
  stage() {
    return this.progressResponse.stage;
  }
  timeElapsed() {
    return this.progressResponse.timeElapsed;
  }
};
var HttpTransport = class {
  constructor({
    authorization,
    apiUrl,
    method,
    headers = {},
    credentials
  }) {
    this.authorization = authorization;
    this.apiUrl = apiUrl;
    this.method = method;
    this.headers = headers;
    this.credentials = credentials;
  }
  request(method, {
    baseRequestId,
    ...params
  }) {
    let spanCounter = 1;
    const searchParams = new URLSearchParams(params && Object.keys(params).map((k) => ({
      [k]: typeof params[k] === "object" ? JSON.stringify(params[k]) : params[k]
    })).reduce((a, b) => ({
      ...a,
      ...b
    }), {}));
    let url = `${this.apiUrl}/${method}${searchParams.toString().length ? `?${searchParams}` : ""}`;
    const requestMethod = this.method || (url.length < 2e3 ? "GET" : "POST");
    if (requestMethod === "POST") {
      url = `${this.apiUrl}/${method}`;
      this.headers["Content-Type"] = "application/json";
    }
    const runRequest = () => (0, import_cross_fetch.default)(url, {
      method: requestMethod,
      headers: {
        Authorization: this.authorization,
        "x-request-id": baseRequestId && `${baseRequestId}-span-${spanCounter++}`,
        ...this.headers
      },
      credentials: this.credentials,
      body: requestMethod === "POST" ? JSON.stringify(params) : null
    });
    return {
      /* eslint no-unsafe-finally: off */
      async subscribe(callback) {
        let result = {
          error: "network Error"
          // add default error message
        };
        try {
          result = await runRequest();
        } finally {
          return callback(result, () => this.subscribe(callback));
        }
      }
    };
  }
};
var RequestError = class extends Error {
  constructor(message, response, status) {
    super(message);
    this.response = response;
    this.status = status;
  }
};
var mutexCounter = 0;
var MUTEX_ERROR = "Mutex has been changed";
var ResultType = {
  DEFAULT: "default",
  COMPACT: "compact"
};
function mutexPromise(promise) {
  return new Promise(async (resolve, reject3) => {
    try {
      resolve(await promise);
    } catch (error) {
      if (error !== MUTEX_ERROR) {
        reject3(error);
      }
    }
  });
}
var CubejsApi = class {
  constructor(apiToken, options) {
    if (apiToken !== null && !Array.isArray(apiToken) && typeof apiToken === "object") {
      options = apiToken;
      apiToken = void 0;
    }
    options = options || {};
    if (!options.transport && !options.apiUrl) {
      throw new Error("The `apiUrl` option is required");
    }
    this.apiToken = apiToken;
    this.apiUrl = options.apiUrl;
    this.method = options.method;
    this.headers = options.headers || {};
    this.credentials = options.credentials;
    this.transport = options.transport || new HttpTransport({
      authorization: typeof apiToken === "function" ? void 0 : apiToken,
      apiUrl: this.apiUrl,
      method: this.method,
      headers: this.headers,
      credentials: this.credentials
    });
    this.pollInterval = options.pollInterval || 5;
    this.parseDateMeasures = options.parseDateMeasures;
    this.updateAuthorizationPromise = null;
  }
  request(method, params) {
    return this.transport.request(method, {
      baseRequestId: v4_default(),
      ...params
    });
  }
  loadMethod(request, toResult, options, callback) {
    const mutexValue = ++mutexCounter;
    if (typeof options === "function" && !callback) {
      callback = options;
      options = void 0;
    }
    options = options || {};
    const mutexKey = options.mutexKey || "default";
    if (options.mutexObj) {
      options.mutexObj[mutexKey] = mutexValue;
    }
    const requestPromise = this.updateTransportAuthorization().then(() => request());
    let skipAuthorizationUpdate = true;
    let unsubscribed = false;
    const checkMutex = async () => {
      const requestInstance = await requestPromise;
      if (options.mutexObj && options.mutexObj[mutexKey] !== mutexValue) {
        unsubscribed = true;
        if (requestInstance.unsubscribe) {
          await requestInstance.unsubscribe();
        }
        throw MUTEX_ERROR;
      }
    };
    const loadImpl = async (response, next) => {
      const requestInstance = await requestPromise;
      const subscribeNext = async () => {
        if (options.subscribe && !unsubscribed) {
          if (requestInstance.unsubscribe) {
            return next();
          } else {
            await new Promise((resolve) => setTimeout(() => resolve(), this.pollInterval * 1e3));
            return next();
          }
        }
        return null;
      };
      const continueWait = async (wait) => {
        if (!unsubscribed) {
          if (wait) {
            await new Promise((resolve) => setTimeout(() => resolve(), this.pollInterval * 1e3));
          }
          return next();
        }
        return null;
      };
      if (options.subscribe && !skipAuthorizationUpdate) {
        await this.updateTransportAuthorization();
      }
      skipAuthorizationUpdate = false;
      if (response.status === 502) {
        await checkMutex();
        return continueWait(true);
      }
      let body = {};
      let text = "";
      try {
        text = await response.text();
        body = JSON.parse(text);
      } catch (_) {
        body.error = text;
      }
      if (body.error === "Continue wait") {
        await checkMutex();
        if (options.progressCallback) {
          options.progressCallback(new ProgressResult(body));
        }
        return continueWait();
      }
      if (response.status !== 200) {
        await checkMutex();
        if (!options.subscribe && requestInstance.unsubscribe) {
          await requestInstance.unsubscribe();
        }
        const error = new RequestError(body.error, body, response.status);
        if (callback) {
          callback(error);
        } else {
          throw error;
        }
        return subscribeNext();
      }
      await checkMutex();
      if (!options.subscribe && requestInstance.unsubscribe) {
        await requestInstance.unsubscribe();
      }
      const result = toResult(body);
      if (callback) {
        callback(null, result);
      } else {
        return result;
      }
      return subscribeNext();
    };
    const promise = requestPromise.then((requestInstance) => mutexPromise(requestInstance.subscribe(loadImpl)));
    if (callback) {
      return {
        unsubscribe: async () => {
          const requestInstance = await requestPromise;
          unsubscribed = true;
          if (requestInstance.unsubscribe) {
            return requestInstance.unsubscribe();
          }
          return null;
        }
      };
    } else {
      return promise;
    }
  }
  async updateTransportAuthorization() {
    if (this.updateAuthorizationPromise) {
      await this.updateAuthorizationPromise;
      return;
    }
    if (typeof this.apiToken === "function") {
      this.updateAuthorizationPromise = new Promise(async (resolve, reject3) => {
        try {
          const token = await this.apiToken();
          if (this.transport.authorization !== token) {
            this.transport.authorization = token;
          }
          resolve();
        } catch (error) {
          reject3(error);
        } finally {
          this.updateAuthorizationPromise = null;
        }
      });
      await this.updateAuthorizationPromise;
    }
  }
  /**
   * Add system properties to a query object.
   * @param {Query} query
   * @param {string} responseFormat
   * @returns {void}
   * @private
   */
  patchQueryInternal(query, responseFormat) {
    if (responseFormat === ResultType.COMPACT && query.responseFormat !== ResultType.COMPACT) {
      return {
        ...query,
        responseFormat: ResultType.COMPACT
      };
    } else {
      return query;
    }
  }
  /**
   * Process result fetched from the gateway#load method according
   * to the network protocol.
   * @param {*} response
   * @returns ResultSet
   * @private
   */
  loadResponseInternal(response) {
    if (response.results.length && response.results[0].query.responseFormat && response.results[0].query.responseFormat === ResultType.COMPACT) {
      response.results.forEach((result, j) => {
        const data = [];
        result.data.dataset.forEach((r) => {
          const row = {};
          result.data.members.forEach((m, i) => {
            row[m] = r[i];
          });
          data.push(row);
        });
        response.results[j].data = data;
      });
    }
    return new ResultSet(response, {
      parseDateMeasures: this.parseDateMeasures
    });
  }
  load(query, options, callback, responseFormat = ResultType.DEFAULT) {
    if (responseFormat === ResultType.COMPACT) {
      if (Array.isArray(query)) {
        query = query.map((q) => this.patchQueryInternal(q, ResultType.COMPACT));
      } else {
        query = this.patchQueryInternal(query, ResultType.COMPACT);
      }
    }
    return this.loadMethod(() => this.request("load", {
      query,
      queryType: "multi"
    }), this.loadResponseInternal.bind(this), options, callback);
  }
  subscribe(query, options, callback, responseFormat = ResultType.DEFAULT) {
    if (responseFormat === ResultType.COMPACT) {
      if (Array.isArray(query)) {
        query = query.map((q) => this.patchQueryInternal(q, ResultType.COMPACT));
      } else {
        query = this.patchQueryInternal(query, ResultType.COMPACT);
      }
    }
    return this.loadMethod(() => this.request("subscribe", {
      query,
      queryType: "multi"
    }), this.loadResponseInternal.bind(this), {
      ...options,
      subscribe: true
    }, callback);
  }
  sql(query, options, callback) {
    return this.loadMethod(() => this.request("sql", {
      query
    }), (response) => Array.isArray(response) ? response.map((body) => new SqlQuery(body)) : new SqlQuery(response), options, callback);
  }
  meta(options, callback) {
    return this.loadMethod(() => this.request("meta"), (body) => new Meta(body), options, callback);
  }
  dryRun(query, options, callback) {
    return this.loadMethod(() => this.request("dry-run", {
      query
    }), (response) => response, options, callback);
  }
};
var index = (apiToken, options) => new CubejsApi(apiToken, options);
var cubejs_client_core_esm_default = index;

export {
  clone_default,
  equals_default,
  fromPairs_default,
  toPairs_default,
  DEFAULT_GRANULARITY,
  GRANULARITIES,
  removeEmptyQueryFields,
  validateQuery,
  areQueriesEqual,
  defaultOrder,
  defaultHeuristics,
  isQueryPresent,
  movePivotItem,
  moveItemInArray,
  flattenFilters,
  getQueryMembers,
  getOrderMembersFromOrder,
  aliasSeries,
  ResultSet,
  HttpTransport,
  RequestError,
  CubejsApi,
  cubejs_client_core_esm_default
};
//# sourceMappingURL=chunk-M5S5J3E5.js.map
