import {
  GRANULARITIES,
  ResultSet,
  areQueriesEqual,
  clone_default,
  defaultHeuristics,
  defaultOrder,
  equals_default,
  fromPairs_default,
  getOrderMembersFromOrder,
  isQueryPresent,
  moveItemInArray,
  movePivotItem,
  toPairs_default
} from "./chunk-M5S5J3E5.js";
import {
  h
} from "./chunk-P4JRBGFP.js";
import "./chunk-LK32TJAX.js";

// node_modules/@cubejs-client/vue3/dist/cubejs-client-vue3.esm.js
var QueryRenderer = {
  props: {
    query: {
      type: [Object, Array],
      default: () => ({})
    },
    // TODO: validate with current react implementation
    queries: {
      type: Object
    },
    loadSql: {
      required: false
    },
    cubejsApi: {
      type: Object,
      required: true
    },
    builderProps: {
      type: Object,
      required: false,
      default: () => ({})
    },
    chartType: {
      type: String,
      required: false
    }
  },
  data() {
    return {
      mutexObj: {},
      error: void 0,
      resultSet: void 0,
      loading: false,
      sqlQuery: void 0
    };
  },
  async mounted() {
    const {
      query,
      queries
    } = this;
    if (isQueryPresent(query)) {
      await this.load();
    } else if (isQueryPresent(queries)) {
      await this.loadQueries(queries);
    }
  },
  render() {
    const {
      $slots,
      resultSet,
      error,
      loading,
      sqlQuery
    } = this;
    const empty = h("div", {});
    let slot = this.$slots.empty ? this.$slots.empty() : empty;
    let controls = h("div", {});
    const onlyDefault = !("empty" in this.$slots) && !("error" in this.$slots);
    if ($slots.builder && this.builderProps.measures) {
      controls = $slots.builder({
        ...this.builderProps
      });
    }
    if (!loading && resultSet && !error || onlyDefault) {
      let slotProps = {
        resultSet,
        sqlQuery,
        query: this.builderProps.query || this.query
      };
      if (onlyDefault) {
        slotProps = {
          loading,
          error,
          refetch: this.load,
          ...this.builderProps,
          ...slotProps
        };
      }
      slot = $slots.default ? $slots.default(slotProps) : slot;
    } else if (error) {
      slot = $slots.error ? $slots.error({
        error,
        sqlQuery
      }) : slot;
    }
    return h("div", {}, [controls, slot]);
  },
  methods: {
    async load() {
      const {
        query
      } = this;
      if (!isQueryPresent(query)) {
        return;
      }
      try {
        this.loading = true;
        this.error = null;
        this.resultSet = null;
        if (this.loadSql === "only") {
          this.sqlQuery = await this.cubejsApi.sql(query, {
            mutexObj: this.mutexObj,
            mutexKey: "sql"
          });
        } else if (this.loadSql) {
          this.sqlQuery = await this.cubejsApi.sql(query, {
            mutexObj: this.mutexObj,
            mutexKey: "sql"
          });
          this.resultSet = await this.cubejsApi.load(query, {
            mutexObj: this.mutexObj,
            mutexKey: "query"
          });
        } else {
          this.resultSet = await this.cubejsApi.load(query, {
            mutexObj: this.mutexObj,
            mutexKey: "query"
          });
        }
        this.loading = false;
      } catch (error) {
        this.error = error;
        this.resultSet = void 0;
        this.loading = false;
      }
    },
    async loadQueries() {
      const {
        queries
      } = this;
      try {
        this.error = void 0;
        this.loading = true;
        const resultPromises = Promise.all(toPairs_default(queries).map(([name, query]) => this.cubejsApi.load(query, {
          mutexObj: this.mutexObj,
          mutexKey: name
        }).then((r) => [name, r])));
        this.resultSet = fromPairs_default(await resultPromises);
        this.loading = false;
      } catch (error) {
        this.error = error;
        this.loading = false;
      }
    }
  },
  watch: {
    loading(loading) {
      if (loading === false) {
        this.$emit("queryStatus", {
          isLoading: false,
          error: this.error,
          resultSet: this.resultSet
        });
      } else {
        this.$emit("queryStatus", {
          isLoading: true
        });
      }
    },
    cubejsApi() {
      this.load();
    },
    chartType() {
      this.load();
    },
    query: {
      deep: true,
      handler(query, prevQuery) {
        if (!areQueriesEqual(query, prevQuery)) {
          this.load();
        }
      }
    },
    queries: {
      handler(val) {
        if (val) {
          this.loadQueries();
        }
      },
      deep: true
    }
  }
};
var QUERY_ELEMENTS = ["measures", "dimensions", "segments", "timeDimensions", "filters"];
var toOrderMember = (member) => ({
  id: member.name,
  title: member.title
});
var reduceOrderMembers = (array) => array.reduce((acc, {
  id,
  order
}) => order !== "none" ? [...acc, [id, order]] : acc, []);
var operators = ["and", "or"];
var validateFilters = (filters) => filters.reduce((acc, raw) => {
  if (raw.operator) {
    return [...acc, raw];
  }
  const validBooleanFilter = operators.reduce((acc2, operator) => {
    const filters2 = raw[operator];
    const booleanFilters = validateFilters(filters2 || []);
    if (booleanFilters.length) {
      return {
        ...acc2,
        [operator]: booleanFilters
      };
    }
    return acc2;
  }, {});
  if (operators.some((operator) => validBooleanFilter[operator])) {
    return [...acc, validBooleanFilter];
  }
  return acc;
}, []);
var getDimensionOrMeasure = (meta, m) => {
  const memberName = m.member || m.dimension;
  return memberName && meta.resolveMember(memberName, ["dimensions", "measures"]);
};
var resolveMembers = (meta, arr) => arr && arr.map((e, index2) => {
  return {
    ...e,
    member: getDimensionOrMeasure(meta, e),
    index: index2,
    and: resolveMembers(meta, e.and),
    or: resolveMembers(meta, e.or)
  };
});
var QueryBuilder = {
  components: {
    QueryRenderer
  },
  props: {
    query: {
      type: Object,
      default: () => ({})
    },
    cubejsApi: {
      type: Object,
      required: true
    },
    initialChartType: {
      type: String,
      default: () => "line"
    },
    disableHeuristics: {
      type: Boolean
    },
    stateChangeHeuristics: {
      type: Function
    },
    initialVizState: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    const {
      query = this.query,
      chartType = this.initialChartType,
      pivotConfig
    } = this.initialVizState;
    return {
      initialQuery: query,
      skipHeuristics: true,
      meta: void 0,
      mutex: {},
      chartType,
      measures: [],
      dimensions: [],
      segments: [],
      timeDimensions: [],
      filters: [],
      availableMeasures: [],
      availableDimensions: [],
      availableTimeDimensions: [],
      availableSegments: [],
      limit: null,
      offset: null,
      renewQuery: false,
      order: null,
      prevValidatedQuery: null,
      granularities: GRANULARITIES,
      pivotConfig: ResultSet.getNormalizedPivotConfig(query || {}, pivotConfig)
    };
  },
  render() {
    const {
      chartType,
      cubejsApi,
      dimensions,
      filters,
      measures,
      meta,
      query,
      segments,
      timeDimensions,
      validatedQuery,
      isQueryPresent: isQueryPresent2,
      availableSegments,
      availableTimeDimensions,
      availableDimensions,
      availableMeasures,
      limit,
      offset,
      setLimit,
      removeLimit,
      setOffset,
      removeOffset,
      renewQuery,
      order,
      orderMembers
    } = this;
    let builderProps = {};
    if (meta) {
      builderProps = {
        query,
        validatedQuery,
        isQueryPresent: isQueryPresent2,
        chartType,
        measures,
        dimensions,
        segments,
        timeDimensions,
        filters,
        availableSegments,
        availableTimeDimensions,
        availableDimensions,
        availableMeasures,
        updateChartType: this.updateChart,
        limit,
        offset,
        setLimit,
        removeLimit,
        setOffset,
        removeOffset,
        renewQuery,
        order,
        orderMembers,
        setOrder: this.setOrder,
        pivotConfig: this.pivotConfig,
        updateOrder: {
          set: (memberId, newOrder) => {
            this.order = reduceOrderMembers(orderMembers.map((orderMember) => ({
              ...orderMember,
              order: orderMember.id === memberId ? newOrder : orderMember.order
            })));
          },
          update: (newOrder) => {
            this.order = newOrder;
          },
          reorder: (sourceIndex, destinationIndex) => {
            this.order = reduceOrderMembers(moveItemInArray(orderMembers, sourceIndex, destinationIndex));
          }
        },
        updatePivotConfig: {
          moveItem: ({
            sourceIndex,
            destinationIndex,
            sourceAxis,
            destinationAxis
          }) => {
            this.pivotConfig = movePivotItem(this.pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis);
          },
          update: (pivotConfig) => {
            this.pivotConfig = {
              x: pivotConfig.x || this.pivotConfig.x,
              y: pivotConfig.y || this.pivotConfig.y
            };
          }
        }
      };
      QUERY_ELEMENTS.forEach((elementName) => {
        const name = elementName.charAt(0).toUpperCase() + elementName.slice(1);
        builderProps[`add${name}`] = (member) => {
          this.addMember(elementName, member);
        };
        builderProps[`update${name}`] = (member, updateWith) => {
          this.updateMember(elementName, member, updateWith);
        };
        builderProps[`remove${name}`] = (member) => {
          this.removeMember(elementName, member);
        };
        builderProps[`set${name}`] = (members) => {
          this.setMembers(elementName, members);
        };
      });
    }
    return h(QueryRenderer, {
      query: this.validatedQuery,
      cubejsApi,
      builderProps,
      slots: this.$slots,
      on: {
        queryStatus: (event) => {
          this.$emit("queryStatus", event);
        }
      }
    }, this.$slots);
  },
  computed: {
    isQueryPresent() {
      const {
        validatedQuery
      } = this;
      return isQueryPresent(validatedQuery);
    },
    orderMembers() {
      return getOrderMembersFromOrder([...this.measures, ...this.dimensions, ...this.timeDimensions.map(({
        dimension
      }) => toOrderMember(dimension))].map((member, index2) => {
        const id = member.name || member.id;
        if (!id) {
          return false;
        }
        return {
          index: index2,
          id,
          title: member.title
        };
      }).filter(Boolean), this.order);
    },
    vizState() {
      return {
        query: this.validatedQuery,
        chartType: this.chartType,
        pivotConfig: this.pivotConfig
      };
    },
    validatedQuery() {
      var _a, _b;
      let validatedQuery = {};
      let toQuery = (member) => member.name;
      let hasElements = false;
      QUERY_ELEMENTS.forEach((element) => {
        if (element === "timeDimensions") {
          toQuery = (member) => ({
            dimension: member.dimension.name,
            granularity: member.granularity,
            dateRange: member.dateRange
          });
        } else if (element === "filters") {
          toQuery = (member) => ({
            member: member.member && member.member.name,
            operator: member.operator,
            values: member.values,
            and: member.and && member.and.map(toQuery),
            or: member.or && member.or.map(toQuery)
          });
        }
        if (this[element].length > 0) {
          validatedQuery[element] = this[element].map((x) => toQuery(x));
          hasElements = true;
        }
      });
      if (validatedQuery.filters) {
        validatedQuery.filters = validateFilters(validatedQuery.filters);
      }
      if (hasElements) {
        if (this.limit) {
          validatedQuery.limit = this.limit;
        }
        if (this.offset) {
          validatedQuery.offset = this.offset;
        }
        if (this.order) {
          validatedQuery.order = this.order;
        }
        if (this.renewQuery) {
          validatedQuery.renewQuery = this.renewQuery;
        }
      }
      if (!this.skipHeuristics && !this.disableHeuristics && isQueryPresent(validatedQuery) && this.meta) {
        const heuristicsFn = this.stateChangeHeuristics || defaultHeuristics;
        const {
          query,
          chartType,
          shouldApplyHeuristicOrder,
          pivotConfig
        } = heuristicsFn({
          query: validatedQuery,
          chartType: this.chartType
        }, this.prevValidatedQuery, {
          meta: this.meta,
          sessionGranularity: (_b = (_a = validatedQuery == null ? void 0 : validatedQuery.timeDimensions) == null ? void 0 : _a[0]) == null ? void 0 : _b.granularity
        });
        validatedQuery = {
          ...validatedQuery,
          ...query,
          ...shouldApplyHeuristicOrder ? {
            order: defaultOrder(query)
          } : null
        };
        this.chartType = chartType || this.chartType;
        this.pivotConfig = ResultSet.getNormalizedPivotConfig(validatedQuery, pivotConfig || this.pivotConfig);
        this.copyQueryFromProps(validatedQuery);
      }
      if (this.prevValidatedQuery !== null) {
        this.skipHeuristics = false;
      }
      this.prevValidatedQuery = validatedQuery;
      return validatedQuery;
    }
  },
  async mounted() {
    this.meta = await this.cubejsApi.meta();
    this.copyQueryFromProps();
    if (isQueryPresent(this.initialQuery)) {
      const dryRunResponse = await this.cubejsApi.dryRun(this.initialQuery);
      this.pivotConfig = ResultSet.getNormalizedPivotConfig((dryRunResponse == null ? void 0 : dryRunResponse.pivotQuery) || {}, this.pivotConfig);
    }
  },
  methods: {
    copyQueryFromProps(query) {
      const {
        measures = [],
        dimensions = [],
        segments = [],
        timeDimensions = [],
        filters = [],
        limit,
        offset,
        renewQuery,
        order
      } = query || this.initialQuery;
      this.measures = measures.map((m, index2) => ({
        index: index2,
        ...this.meta.resolveMember(m, "measures")
      }));
      this.dimensions = dimensions.map((m, index2) => ({
        index: index2,
        ...this.meta.resolveMember(m, "dimensions")
      }));
      this.segments = segments.map((m, index2) => ({
        index: index2,
        ...this.meta.resolveMember(m, "segments")
      }));
      this.timeDimensions = timeDimensions.map((m, index2) => ({
        ...m,
        dimension: {
          ...this.meta.resolveMember(m.dimension, "dimensions"),
          granularities: this.granularities
        },
        index: index2
      }));
      const memberTypes = ["dimensions", "measures"];
      this.filters = filters.map((m, index2) => {
        const memberName = m.member || m.dimension;
        return {
          ...m,
          member: memberName && this.meta.resolveMember(memberName, memberTypes),
          operators: memberName && this.meta.filterOperatorsForMember(memberName, memberTypes),
          and: resolveMembers(this.meta, m.and),
          or: resolveMembers(this.meta, m.or),
          index: index2
        };
      });
      this.availableMeasures = this.meta.membersForQuery({}, "measures") || [];
      this.availableDimensions = this.meta.membersForQuery({}, "dimensions") || [];
      this.availableTimeDimensions = (this.meta.membersForQuery({}, "dimensions") || []).filter((m) => m.type === "time");
      this.availableSegments = this.meta.membersForQuery({}, "segments") || [];
      this.limit = limit || 1e4;
      this.offset = offset || null;
      this.renewQuery = renewQuery || false;
      this.order = order || null;
    },
    addMember(element, member) {
      const name = element.charAt(0).toUpperCase() + element.slice(1);
      let mem;
      if (element === "timeDimensions") {
        mem = this[`available${name}`].find((m) => m.name === member.dimension);
        if (mem) {
          const dimension = {
            ...this.meta.resolveMember(mem.name, "dimensions"),
            granularities: this.granularities
          };
          mem = {
            ...mem,
            granularity: member.granularity,
            dateRange: member.dateRange,
            dimension,
            index: this[element].length
          };
        }
      } else if (element === "filters") {
        mem = {
          ...member,
          and: resolveMembers(this.meta, member.and),
          or: resolveMembers(this.meta, member.or),
          member: getDimensionOrMeasure(this.meta, member)
        };
      } else {
        mem = this[`available${name}`].find((m) => m.name === member);
      }
      if (mem) {
        this[element].push(mem);
      }
    },
    removeMember(element, member) {
      const name = element.charAt(0).toUpperCase() + element.slice(1);
      let mem;
      if (element === "timeDimensions") {
        mem = this[`available${name}`].find((x) => x.name === member);
      } else if (element === "filters") {
        mem = member;
      } else {
        mem = this[`available${name}`].find((m) => m.name === member);
      }
      if (mem) {
        const index2 = this[element].findIndex((x) => x.name === mem);
        this[element].splice(index2, 1);
      }
    },
    updateMember(element, old, member) {
      const name = element.charAt(0).toUpperCase() + element.slice(1);
      let mem;
      let index2;
      if (element === "timeDimensions") {
        index2 = this[element].findIndex((x) => x.dimension.name === old.dimension);
        mem = this[`available${name}`].find((m) => m.name === member.dimension);
        if (mem) {
          const dimension = {
            ...this.meta.resolveMember(mem.name, "dimensions"),
            granularities: this.granularities
          };
          mem = {
            ...mem,
            dimension,
            granularity: member.granularity,
            dateRange: member.dateRange,
            index: index2
          };
        }
      } else if (element === "filters") {
        index2 = this[element].findIndex((x) => x.dimension === old);
        mem = {
          ...member,
          and: resolveMembers(this.meta, member.and),
          or: resolveMembers(this.meta, member.or),
          member: getDimensionOrMeasure(this.meta, member)
        };
      } else {
        index2 = this[element].findIndex((x) => x.name === old);
        mem = this[`available${name}`].find((m) => m.name === member);
      }
      if (mem) {
        this[element].splice(index2, 1, mem);
      }
    },
    setMembers(element, members) {
      const name = element.charAt(0).toUpperCase() + element.slice(1);
      let mem;
      const elements = [];
      members.filter(Boolean).forEach((m) => {
        if (element === "timeDimensions") {
          mem = this[`available${name}`].find((x) => x.name === m.dimension);
          if (mem) {
            const dimension = {
              ...this.meta.resolveMember(mem.name, "dimensions"),
              granularities: this.granularities
            };
            mem = {
              ...mem,
              granularity: m.granularity,
              dateRange: m.dateRange,
              dimension,
              index: this[element].length
            };
          }
        } else if (element === "filters") {
          mem = {
            ...m,
            and: resolveMembers(this.meta, m.and),
            or: resolveMembers(this.meta, m.or),
            member: getDimensionOrMeasure(this.meta, m)
          };
        } else {
          mem = this[`available${name}`].find((x) => x.name === m);
        }
        if (mem) {
          elements.push(mem);
        }
      });
      this[element] = elements;
    },
    setLimit(limit) {
      this.limit = limit;
    },
    removeLimit() {
      this.limit = null;
    },
    setOffset(offset) {
      this.offset = offset;
    },
    removeOffset() {
      this.offset = null;
    },
    updateChart(chartType) {
      this.chartType = chartType;
    },
    setOrder(order = {}) {
      this.order = order;
    },
    emitVizStateChange(partialVizState) {
      this.$emit("vizStateChange", clone_default({
        ...this.vizState,
        ...partialVizState
      }));
    }
  },
  watch: {
    validatedQuery: {
      deep: true,
      handler(query, prevQuery) {
        const hasQueryChanged = !areQueriesEqual(query, prevQuery);
        if (hasQueryChanged) {
          this.emitVizStateChange({
            query
          });
        }
        if (isQueryPresent(query) && hasQueryChanged) {
          this.cubejsApi.dryRun(query, {
            mutexObj: this.mutex
          }).then(({
            pivotQuery
          }) => {
            const pivotConfig = ResultSet.getNormalizedPivotConfig(pivotQuery, this.pivotConfig);
            if (!equals_default(pivotConfig, this.pivotConfig)) {
              this.pivotConfig = pivotConfig;
            }
          }).catch((error) => console.error(error));
        }
      }
    },
    query: {
      deep: true,
      handler(query) {
        if (!this.meta) {
          return;
        }
        this.copyQueryFromProps(query);
      }
    },
    pivotConfig: {
      deep: true,
      handler(pivotConfig, prevPivotConfig) {
        if (!equals_default(pivotConfig, prevPivotConfig)) {
          this.emitVizStateChange({
            pivotConfig
          });
        }
      }
    },
    chartType(value) {
      this.emitVizStateChange({
        chartType: value
      });
    }
  }
};
var index = {};
var cubejs_client_vue3_esm_default = index;
export {
  GRANULARITIES,
  QueryBuilder,
  QueryRenderer,
  cubejs_client_vue3_esm_default as default
};
//# sourceMappingURL=@cubejs-client_vue3.js.map
