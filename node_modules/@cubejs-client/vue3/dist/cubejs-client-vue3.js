'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@cubejs-client/core');
require('core-js/modules/es.object.keys.js');
require('core-js/modules/es.symbol.js');
require('core-js/modules/es.array.filter.js');
require('core-js/modules/es.object.get-own-property-descriptor.js');
require('core-js/modules/es.array.for-each.js');
require('core-js/modules/web.dom-collections.for-each.js');
require('core-js/modules/es.object.get-own-property-descriptors.js');
require('core-js/modules/es.object.define-properties.js');
require('core-js/modules/es.object.define-property.js');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.promise.js');
require('core-js/modules/es.string.iterator.js');
require('core-js/modules/web.dom-collections.iterator.js');
require('core-js/modules/es.array.map.js');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var ramda = require('ramda');
var vue = require('vue');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
require('core-js/modules/es.function.name.js');
require('core-js/modules/es.array.reduce.js');
require('core-js/modules/es.array.concat.js');
require('core-js/modules/es.array.some.js');
require('core-js/modules/es.array.slice.js');
require('core-js/modules/es.array.find.js');
require('core-js/modules/es.array.find-index.js');
require('core-js/modules/es.array.splice.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var QueryRenderer = {
  props: {
    query: {
      type: [Object, Array],
      "default": function _default() {
        return {};
      }
    },
    // TODO: validate with current react implementation
    queries: {
      type: Object
    },
    loadSql: {
      required: false
    },
    cubejsApi: {
      type: Object,
      required: true
    },
    builderProps: {
      type: Object,
      required: false,
      "default": function _default() {
        return {};
      }
    },
    chartType: {
      type: String,
      required: false
    }
  },
  data: function data() {
    return {
      mutexObj: {},
      error: undefined,
      resultSet: undefined,
      loading: false,
      sqlQuery: undefined
    };
  },
  mounted: function mounted() {
    var _this = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
      var query, queries;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              query = _this.query, queries = _this.queries;

              if (!core.isQueryPresent(query)) {
                _context.next = 6;
                break;
              }

              _context.next = 4;
              return _this.load();

            case 4:
              _context.next = 9;
              break;

            case 6:
              if (!core.isQueryPresent(queries)) {
                _context.next = 9;
                break;
              }

              _context.next = 9;
              return _this.loadQueries(queries);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  render: function render() {
    var $slots = this.$slots,
        resultSet = this.resultSet,
        error = this.error,
        loading = this.loading,
        sqlQuery = this.sqlQuery;
    var empty = vue.h('div', {});
    var slot = this.$slots.empty ? this.$slots.empty() : empty;
    var controls = vue.h('div', {});
    var onlyDefault = !('empty' in this.$slots) && !('error' in this.$slots);

    if ($slots.builder && this.builderProps.measures) {
      controls = $slots.builder(_objectSpread$1({}, this.builderProps));
    }

    if (!loading && resultSet && !error || onlyDefault) {
      var slotProps = {
        resultSet: resultSet,
        sqlQuery: sqlQuery,
        query: this.builderProps.query || this.query
      };

      if (onlyDefault) {
        slotProps = _objectSpread$1(_objectSpread$1({
          loading: loading,
          error: error,
          refetch: this.load
        }, this.builderProps), slotProps);
      }

      slot = $slots["default"] ? $slots["default"](slotProps) : slot;
    } else if (error) {
      slot = $slots.error ? $slots.error({
        error: error,
        sqlQuery: sqlQuery
      }) : slot;
    }

    return vue.h('div', {}, [controls, slot]);
  },
  methods: {
    load: function load() {
      var _this2 = this;

      return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        var query;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                query = _this2.query;

                if (core.isQueryPresent(query)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                _context2.prev = 3;
                _this2.loading = true;
                _this2.error = null;
                _this2.resultSet = null;

                if (!(_this2.loadSql === 'only')) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 10;
                return _this2.cubejsApi.sql(query, {
                  mutexObj: _this2.mutexObj,
                  mutexKey: 'sql'
                });

              case 10:
                _this2.sqlQuery = _context2.sent;
                _context2.next = 25;
                break;

              case 13:
                if (!_this2.loadSql) {
                  _context2.next = 22;
                  break;
                }

                _context2.next = 16;
                return _this2.cubejsApi.sql(query, {
                  mutexObj: _this2.mutexObj,
                  mutexKey: 'sql'
                });

              case 16:
                _this2.sqlQuery = _context2.sent;
                _context2.next = 19;
                return _this2.cubejsApi.load(query, {
                  mutexObj: _this2.mutexObj,
                  mutexKey: 'query'
                });

              case 19:
                _this2.resultSet = _context2.sent;
                _context2.next = 25;
                break;

              case 22:
                _context2.next = 24;
                return _this2.cubejsApi.load(query, {
                  mutexObj: _this2.mutexObj,
                  mutexKey: 'query'
                });

              case 24:
                _this2.resultSet = _context2.sent;

              case 25:
                _this2.loading = false;
                _context2.next = 33;
                break;

              case 28:
                _context2.prev = 28;
                _context2.t0 = _context2["catch"](3);
                _this2.error = _context2.t0;
                _this2.resultSet = undefined;
                _this2.loading = false;

              case 33:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[3, 28]]);
      }))();
    },
    loadQueries: function loadQueries() {
      var _this3 = this;

      return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {
        var queries, resultPromises;
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                queries = _this3.queries;
                _context3.prev = 1;
                _this3.error = undefined;
                _this3.loading = true;
                resultPromises = Promise.all(ramda.toPairs(queries).map(function (_ref) {
                  var _ref2 = _slicedToArray__default['default'](_ref, 2),
                      name = _ref2[0],
                      query = _ref2[1];

                  return _this3.cubejsApi.load(query, {
                    mutexObj: _this3.mutexObj,
                    mutexKey: name
                  }).then(function (r) {
                    return [name, r];
                  });
                }));
                _context3.t0 = ramda.fromPairs;
                _context3.next = 8;
                return resultPromises;

              case 8:
                _context3.t1 = _context3.sent;
                _this3.resultSet = (0, _context3.t0)(_context3.t1);
                _this3.loading = false;
                _context3.next = 17;
                break;

              case 13:
                _context3.prev = 13;
                _context3.t2 = _context3["catch"](1);
                _this3.error = _context3.t2;
                _this3.loading = false;

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[1, 13]]);
      }))();
    }
  },
  watch: {
    loading: function loading(_loading) {
      if (_loading === false) {
        this.$emit('queryStatus', {
          isLoading: false,
          error: this.error,
          resultSet: this.resultSet
        });
      } else {
        this.$emit('queryStatus', {
          isLoading: true
        });
      }
    },
    cubejsApi: function cubejsApi() {
      this.load();
    },
    chartType: function chartType() {
      this.load();
    },
    query: {
      deep: true,
      handler: function handler(query, prevQuery) {
        if (!core.areQueriesEqual(query, prevQuery)) {
          this.load();
        }
      }
    },
    queries: {
      handler: function handler(val) {
        if (val) {
          this.loadQueries();
        }
      },
      deep: true
    }
  }
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var QUERY_ELEMENTS = ['measures', 'dimensions', 'segments', 'timeDimensions', 'filters'];

var toOrderMember = function toOrderMember(member) {
  return {
    id: member.name,
    title: member.title
  };
};

var reduceOrderMembers = function reduceOrderMembers(array) {
  return array.reduce(function (acc, _ref) {
    var id = _ref.id,
        order = _ref.order;
    return order !== 'none' ? [].concat(_toConsumableArray__default['default'](acc), [[id, order]]) : acc;
  }, []);
};

var operators = ['and', 'or'];

var validateFilters = function validateFilters(filters) {
  return filters.reduce(function (acc, raw) {
    if (raw.operator) {
      return [].concat(_toConsumableArray__default['default'](acc), [raw]);
    }

    var validBooleanFilter = operators.reduce(function (acc, operator) {
      var filters = raw[operator];
      var booleanFilters = validateFilters(filters || []);

      if (booleanFilters.length) {
        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty__default['default']({}, operator, booleanFilters));
      }

      return acc;
    }, {});

    if (operators.some(function (operator) {
      return validBooleanFilter[operator];
    })) {
      return [].concat(_toConsumableArray__default['default'](acc), [validBooleanFilter]);
    }

    return acc;
  }, []);
};

var getDimensionOrMeasure = function getDimensionOrMeasure(meta, m) {
  var memberName = m.member || m.dimension;
  return memberName && meta.resolveMember(memberName, ['dimensions', 'measures']);
};

var resolveMembers = function resolveMembers(meta, arr) {
  return arr && arr.map(function (e, index) {
    return _objectSpread(_objectSpread({}, e), {}, {
      member: getDimensionOrMeasure(meta, e),
      index: index,
      and: resolveMembers(meta, e.and),
      or: resolveMembers(meta, e.or)
    });
  });
};

var QueryBuilder = {
  components: {
    QueryRenderer: QueryRenderer
  },
  props: {
    query: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    cubejsApi: {
      type: Object,
      required: true
    },
    initialChartType: {
      type: String,
      "default": function _default() {
        return 'line';
      }
    },
    disableHeuristics: {
      type: Boolean
    },
    stateChangeHeuristics: {
      type: Function
    },
    initialVizState: {
      type: Object,
      "default": function _default() {
        return {};
      }
    }
  },
  data: function data() {
    var _this$initialVizState = this.initialVizState,
        _this$initialVizState2 = _this$initialVizState.query,
        query = _this$initialVizState2 === void 0 ? this.query : _this$initialVizState2,
        _this$initialVizState3 = _this$initialVizState.chartType,
        chartType = _this$initialVizState3 === void 0 ? this.initialChartType : _this$initialVizState3,
        pivotConfig = _this$initialVizState.pivotConfig;
    return {
      initialQuery: query,
      skipHeuristics: true,
      meta: undefined,
      mutex: {},
      chartType: chartType,
      measures: [],
      dimensions: [],
      segments: [],
      timeDimensions: [],
      filters: [],
      availableMeasures: [],
      availableDimensions: [],
      availableTimeDimensions: [],
      availableSegments: [],
      limit: null,
      offset: null,
      renewQuery: false,
      order: null,
      prevValidatedQuery: null,
      granularities: core.GRANULARITIES,
      pivotConfig: core.ResultSet.getNormalizedPivotConfig(query || {}, pivotConfig)
    };
  },
  render: function render() {
    var _this = this;

    var chartType = this.chartType,
        cubejsApi = this.cubejsApi,
        dimensions = this.dimensions,
        filters = this.filters,
        measures = this.measures,
        meta = this.meta,
        query = this.query,
        segments = this.segments,
        timeDimensions = this.timeDimensions,
        validatedQuery = this.validatedQuery,
        isQueryPresent = this.isQueryPresent,
        availableSegments = this.availableSegments,
        availableTimeDimensions = this.availableTimeDimensions,
        availableDimensions = this.availableDimensions,
        availableMeasures = this.availableMeasures,
        limit = this.limit,
        offset = this.offset,
        setLimit = this.setLimit,
        removeLimit = this.removeLimit,
        setOffset = this.setOffset,
        removeOffset = this.removeOffset,
        renewQuery = this.renewQuery,
        order = this.order,
        orderMembers = this.orderMembers;
    var builderProps = {};

    if (meta) {
      builderProps = {
        query: query,
        validatedQuery: validatedQuery,
        isQueryPresent: isQueryPresent,
        chartType: chartType,
        measures: measures,
        dimensions: dimensions,
        segments: segments,
        timeDimensions: timeDimensions,
        filters: filters,
        availableSegments: availableSegments,
        availableTimeDimensions: availableTimeDimensions,
        availableDimensions: availableDimensions,
        availableMeasures: availableMeasures,
        updateChartType: this.updateChart,
        limit: limit,
        offset: offset,
        setLimit: setLimit,
        removeLimit: removeLimit,
        setOffset: setOffset,
        removeOffset: removeOffset,
        renewQuery: renewQuery,
        order: order,
        orderMembers: orderMembers,
        setOrder: this.setOrder,
        pivotConfig: this.pivotConfig,
        updateOrder: {
          set: function set(memberId, newOrder) {
            _this.order = reduceOrderMembers(orderMembers.map(function (orderMember) {
              return _objectSpread(_objectSpread({}, orderMember), {}, {
                order: orderMember.id === memberId ? newOrder : orderMember.order
              });
            }));
          },
          update: function update(newOrder) {
            _this.order = newOrder;
          },
          reorder: function reorder(sourceIndex, destinationIndex) {
            _this.order = reduceOrderMembers(core.moveItemInArray(orderMembers, sourceIndex, destinationIndex));
          }
        },
        updatePivotConfig: {
          moveItem: function moveItem(_ref2) {
            var sourceIndex = _ref2.sourceIndex,
                destinationIndex = _ref2.destinationIndex,
                sourceAxis = _ref2.sourceAxis,
                destinationAxis = _ref2.destinationAxis;
            _this.pivotConfig = core.movePivotItem(_this.pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis);
          },
          update: function update(pivotConfig) {
            _this.pivotConfig = {
              x: pivotConfig.x || _this.pivotConfig.x,
              y: pivotConfig.y || _this.pivotConfig.y
            };
          }
        }
      };
      QUERY_ELEMENTS.forEach(function (elementName) {
        var name = elementName.charAt(0).toUpperCase() + elementName.slice(1);

        builderProps["add".concat(name)] = function (member) {
          _this.addMember(elementName, member);
        };

        builderProps["update".concat(name)] = function (member, updateWith) {
          _this.updateMember(elementName, member, updateWith);
        };

        builderProps["remove".concat(name)] = function (member) {
          _this.removeMember(elementName, member);
        };

        builderProps["set".concat(name)] = function (members) {
          _this.setMembers(elementName, members);
        };
      });
    }

    return vue.h(QueryRenderer, {
      query: this.validatedQuery,
      cubejsApi: cubejsApi,
      builderProps: builderProps,
      slots: this.$slots,
      on: {
        queryStatus: function queryStatus(event) {
          _this.$emit('queryStatus', event);
        }
      }
    }, this.$slots);
  },
  computed: {
    isQueryPresent: function isQueryPresent() {
      var validatedQuery = this.validatedQuery;
      return core.isQueryPresent(validatedQuery);
    },
    orderMembers: function orderMembers() {
      return core.getOrderMembersFromOrder([].concat(_toConsumableArray__default['default'](this.measures), _toConsumableArray__default['default'](this.dimensions), _toConsumableArray__default['default'](this.timeDimensions.map(function (_ref3) {
        var dimension = _ref3.dimension;
        return toOrderMember(dimension);
      }))).map(function (member, index) {
        var id = member.name || member.id;

        if (!id) {
          return false;
        }

        return {
          index: index,
          id: id,
          title: member.title
        };
      }).filter(Boolean), this.order);
    },
    vizState: function vizState() {
      return {
        query: this.validatedQuery,
        chartType: this.chartType,
        pivotConfig: this.pivotConfig
      };
    },
    validatedQuery: function validatedQuery() {
      var _this2 = this;

      var validatedQuery = {};

      var _toQuery = function toQuery(member) {
        return member.name;
      }; // TODO: implement timezone


      var hasElements = false;
      QUERY_ELEMENTS.forEach(function (element) {
        if (element === 'timeDimensions') {
          _toQuery = function toQuery(member) {
            return {
              dimension: member.dimension.name,
              granularity: member.granularity,
              dateRange: member.dateRange
            };
          };
        } else if (element === 'filters') {
          _toQuery = function toQuery(member) {
            return {
              member: member.member && member.member.name,
              operator: member.operator,
              values: member.values,
              and: member.and && member.and.map(_toQuery),
              or: member.or && member.or.map(_toQuery)
            };
          };
        }

        if (_this2[element].length > 0) {
          validatedQuery[element] = _this2[element].map(function (x) {
            return _toQuery(x);
          });
          hasElements = true;
        }
      });

      if (validatedQuery.filters) {
        validatedQuery.filters = validateFilters(validatedQuery.filters);
      } // only set limit and offset if there are elements otherwise an invalid request with just limit/offset
      // gets sent when the component is first mounted, but before the actual query is constructed.


      if (hasElements) {
        if (this.limit) {
          validatedQuery.limit = this.limit;
        }

        if (this.offset) {
          validatedQuery.offset = this.offset;
        }

        if (this.order) {
          validatedQuery.order = this.order;
        }

        if (this.renewQuery) {
          validatedQuery.renewQuery = this.renewQuery;
        }
      }

      if (!this.skipHeuristics && !this.disableHeuristics && core.isQueryPresent(validatedQuery) && this.meta) {
        var _validatedQuery, _validatedQuery$timeD, _validatedQuery$timeD2;

        var heuristicsFn = this.stateChangeHeuristics || core.defaultHeuristics;

        var _heuristicsFn = heuristicsFn({
          query: validatedQuery,
          chartType: this.chartType
        }, this.prevValidatedQuery, {
          meta: this.meta,
          sessionGranularity: (_validatedQuery = validatedQuery) === null || _validatedQuery === void 0 ? void 0 : (_validatedQuery$timeD = _validatedQuery.timeDimensions) === null || _validatedQuery$timeD === void 0 ? void 0 : (_validatedQuery$timeD2 = _validatedQuery$timeD[0]) === null || _validatedQuery$timeD2 === void 0 ? void 0 : _validatedQuery$timeD2.granularity
        }),
            query = _heuristicsFn.query,
            chartType = _heuristicsFn.chartType,
            shouldApplyHeuristicOrder = _heuristicsFn.shouldApplyHeuristicOrder,
            pivotConfig = _heuristicsFn.pivotConfig;

        validatedQuery = _objectSpread(_objectSpread(_objectSpread({}, validatedQuery), query), shouldApplyHeuristicOrder ? {
          order: core.defaultOrder(query)
        } : null);
        this.chartType = chartType || this.chartType;
        this.pivotConfig = core.ResultSet.getNormalizedPivotConfig(validatedQuery, pivotConfig || this.pivotConfig);
        this.copyQueryFromProps(validatedQuery);
      } // query heuristics should only apply on query change (not applied to the initial query)


      if (this.prevValidatedQuery !== null) {
        this.skipHeuristics = false;
      }

      this.prevValidatedQuery = validatedQuery;
      return validatedQuery;
    }
  },
  mounted: function mounted() {
    var _this3 = this;

    return _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
      var dryRunResponse;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this3.cubejsApi.meta();

            case 2:
              _this3.meta = _context.sent;

              _this3.copyQueryFromProps();

              if (!core.isQueryPresent(_this3.initialQuery)) {
                _context.next = 9;
                break;
              }

              _context.next = 7;
              return _this3.cubejsApi.dryRun(_this3.initialQuery);

            case 7:
              dryRunResponse = _context.sent;
              _this3.pivotConfig = core.ResultSet.getNormalizedPivotConfig((dryRunResponse === null || dryRunResponse === void 0 ? void 0 : dryRunResponse.pivotQuery) || {}, _this3.pivotConfig);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  methods: {
    copyQueryFromProps: function copyQueryFromProps(query) {
      var _this4 = this;

      var _ref4 = query || this.initialQuery,
          _ref4$measures = _ref4.measures,
          measures = _ref4$measures === void 0 ? [] : _ref4$measures,
          _ref4$dimensions = _ref4.dimensions,
          dimensions = _ref4$dimensions === void 0 ? [] : _ref4$dimensions,
          _ref4$segments = _ref4.segments,
          segments = _ref4$segments === void 0 ? [] : _ref4$segments,
          _ref4$timeDimensions = _ref4.timeDimensions,
          timeDimensions = _ref4$timeDimensions === void 0 ? [] : _ref4$timeDimensions,
          _ref4$filters = _ref4.filters,
          filters = _ref4$filters === void 0 ? [] : _ref4$filters,
          limit = _ref4.limit,
          offset = _ref4.offset,
          renewQuery = _ref4.renewQuery,
          order = _ref4.order;

      this.measures = measures.map(function (m, index) {
        return _objectSpread({
          index: index
        }, _this4.meta.resolveMember(m, 'measures'));
      });
      this.dimensions = dimensions.map(function (m, index) {
        return _objectSpread({
          index: index
        }, _this4.meta.resolveMember(m, 'dimensions'));
      });
      this.segments = segments.map(function (m, index) {
        return _objectSpread({
          index: index
        }, _this4.meta.resolveMember(m, 'segments'));
      });
      this.timeDimensions = timeDimensions.map(function (m, index) {
        return _objectSpread(_objectSpread({}, m), {}, {
          dimension: _objectSpread(_objectSpread({}, _this4.meta.resolveMember(m.dimension, 'dimensions')), {}, {
            granularities: _this4.granularities
          }),
          index: index
        });
      });
      var memberTypes = ['dimensions', 'measures'];
      this.filters = filters.map(function (m, index) {
        var memberName = m.member || m.dimension;
        return _objectSpread(_objectSpread({}, m), {}, {
          member: memberName && _this4.meta.resolveMember(memberName, memberTypes),
          operators: memberName && _this4.meta.filterOperatorsForMember(memberName, memberTypes),
          and: resolveMembers(_this4.meta, m.and),
          or: resolveMembers(_this4.meta, m.or),
          index: index
        });
      });
      this.availableMeasures = this.meta.membersForQuery({}, 'measures') || [];
      this.availableDimensions = this.meta.membersForQuery({}, 'dimensions') || [];
      this.availableTimeDimensions = (this.meta.membersForQuery({}, 'dimensions') || []).filter(function (m) {
        return m.type === 'time';
      });
      this.availableSegments = this.meta.membersForQuery({}, 'segments') || [];
      this.limit = limit || 10000;
      this.offset = offset || null;
      this.renewQuery = renewQuery || false;
      this.order = order || null;
    },
    addMember: function addMember(element, member) {
      var name = element.charAt(0).toUpperCase() + element.slice(1);
      var mem;

      if (element === 'timeDimensions') {
        mem = this["available".concat(name)].find(function (m) {
          return m.name === member.dimension;
        });

        if (mem) {
          var dimension = _objectSpread(_objectSpread({}, this.meta.resolveMember(mem.name, 'dimensions')), {}, {
            granularities: this.granularities
          });

          mem = _objectSpread(_objectSpread({}, mem), {}, {
            granularity: member.granularity,
            dateRange: member.dateRange,
            dimension: dimension,
            index: this[element].length
          });
        }
      } else if (element === 'filters') {
        mem = _objectSpread(_objectSpread({}, member), {}, {
          and: resolveMembers(this.meta, member.and),
          or: resolveMembers(this.meta, member.or),
          member: getDimensionOrMeasure(this.meta, member)
        });
      } else {
        mem = this["available".concat(name)].find(function (m) {
          return m.name === member;
        });
      }

      if (mem) {
        this[element].push(mem);
      }
    },
    removeMember: function removeMember(element, member) {
      var name = element.charAt(0).toUpperCase() + element.slice(1);
      var mem;

      if (element === 'timeDimensions') {
        mem = this["available".concat(name)].find(function (x) {
          return x.name === member;
        });
      } else if (element === 'filters') {
        mem = member;
      } else {
        mem = this["available".concat(name)].find(function (m) {
          return m.name === member;
        });
      }

      if (mem) {
        var index = this[element].findIndex(function (x) {
          return x.name === mem;
        });
        this[element].splice(index, 1);
      }
    },
    updateMember: function updateMember(element, old, member) {
      var name = element.charAt(0).toUpperCase() + element.slice(1);
      var mem;
      var index;

      if (element === 'timeDimensions') {
        index = this[element].findIndex(function (x) {
          return x.dimension.name === old.dimension;
        });
        mem = this["available".concat(name)].find(function (m) {
          return m.name === member.dimension;
        });

        if (mem) {
          var dimension = _objectSpread(_objectSpread({}, this.meta.resolveMember(mem.name, 'dimensions')), {}, {
            granularities: this.granularities
          });

          mem = _objectSpread(_objectSpread({}, mem), {}, {
            dimension: dimension,
            granularity: member.granularity,
            dateRange: member.dateRange,
            index: index
          });
        }
      } else if (element === 'filters') {
        index = this[element].findIndex(function (x) {
          return x.dimension === old;
        });
        mem = _objectSpread(_objectSpread({}, member), {}, {
          and: resolveMembers(this.meta, member.and),
          or: resolveMembers(this.meta, member.or),
          member: getDimensionOrMeasure(this.meta, member)
        });
      } else {
        index = this[element].findIndex(function (x) {
          return x.name === old;
        });
        mem = this["available".concat(name)].find(function (m) {
          return m.name === member;
        });
      }

      if (mem) {
        this[element].splice(index, 1, mem);
      }
    },
    setMembers: function setMembers(element, members) {
      var _this5 = this;

      var name = element.charAt(0).toUpperCase() + element.slice(1);
      var mem;
      var elements = [];
      members.filter(Boolean).forEach(function (m) {
        if (element === 'timeDimensions') {
          mem = _this5["available".concat(name)].find(function (x) {
            return x.name === m.dimension;
          });

          if (mem) {
            var dimension = _objectSpread(_objectSpread({}, _this5.meta.resolveMember(mem.name, 'dimensions')), {}, {
              granularities: _this5.granularities
            });

            mem = _objectSpread(_objectSpread({}, mem), {}, {
              granularity: m.granularity,
              dateRange: m.dateRange,
              dimension: dimension,
              index: _this5[element].length
            });
          }
        } else if (element === 'filters') {
          mem = _objectSpread(_objectSpread({}, m), {}, {
            and: resolveMembers(_this5.meta, m.and),
            or: resolveMembers(_this5.meta, m.or),
            member: getDimensionOrMeasure(_this5.meta, m)
          });
        } else {
          mem = _this5["available".concat(name)].find(function (x) {
            return x.name === m;
          });
        }

        if (mem) {
          elements.push(mem);
        }
      });
      this[element] = elements;
    },
    setLimit: function setLimit(limit) {
      this.limit = limit;
    },
    removeLimit: function removeLimit() {
      this.limit = null;
    },
    setOffset: function setOffset(offset) {
      this.offset = offset;
    },
    removeOffset: function removeOffset() {
      this.offset = null;
    },
    updateChart: function updateChart(chartType) {
      this.chartType = chartType;
    },
    setOrder: function setOrder() {
      var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.order = order;
    },
    emitVizStateChange: function emitVizStateChange(partialVizState) {
      this.$emit('vizStateChange', ramda.clone(_objectSpread(_objectSpread({}, this.vizState), partialVizState)));
    }
  },
  watch: {
    validatedQuery: {
      deep: true,
      handler: function handler(query, prevQuery) {
        var _this6 = this;

        var hasQueryChanged = !core.areQueriesEqual(query, prevQuery);

        if (hasQueryChanged) {
          this.emitVizStateChange({
            query: query
          });
        }

        if (core.isQueryPresent(query) && hasQueryChanged) {
          this.cubejsApi.dryRun(query, {
            mutexObj: this.mutex
          }).then(function (_ref5) {
            var pivotQuery = _ref5.pivotQuery;
            var pivotConfig = core.ResultSet.getNormalizedPivotConfig(pivotQuery, _this6.pivotConfig);

            if (!ramda.equals(pivotConfig, _this6.pivotConfig)) {
              _this6.pivotConfig = pivotConfig;
            }
          })["catch"](function (error) {
            return console.error(error);
          });
        }
      }
    },
    query: {
      deep: true,
      handler: function handler(query) {
        if (!this.meta) {
          // this is ok as if meta has not been loaded by the time query prop has changed,
          // then the promise for loading meta (found in mounted()) will call
          // copyQueryFromProps and will therefore update anyway.
          return;
        }

        this.copyQueryFromProps(query);
      }
    },
    pivotConfig: {
      deep: true,
      handler: function handler(pivotConfig, prevPivotConfig) {
        if (!ramda.equals(pivotConfig, prevPivotConfig)) {
          this.emitVizStateChange({
            pivotConfig: pivotConfig
          });
        }
      }
    },
    chartType: function chartType(value) {
      this.emitVizStateChange({
        chartType: value
      });
    }
  }
};

var index = {};

Object.defineProperty(exports, 'GRANULARITIES', {
  enumerable: true,
  get: function () {
    return core.GRANULARITIES;
  }
});
exports.QueryBuilder = QueryBuilder;
exports.QueryRenderer = QueryRenderer;
exports.default = index;
//# sourceMappingURL=cubejs-client-vue3.js.map
